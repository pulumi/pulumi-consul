{
    "name": "consul",
    "displayName": "Consul",
    "description": "A Pulumi package for creating and managing consul resources.",
    "keywords": [
        "pulumi",
        "consul"
    ],
    "homepage": "https://pulumi.io",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`consul` Terraform Provider](https://github.com/hashicorp/terraform-provider-consul).",
    "repository": "https://github.com/pulumi/pulumi-consul",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "packageReferences": {
                "Pulumi": "3.*"
            },
            "namespaces": {
                "consul": "Consul"
            },
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true
        },
        "go": {
            "importBasePath": "github.com/pulumi/pulumi-consul/sdk/v3/go/consul",
            "generateResourceContainerTypes": true,
            "generateExtraInputTypes": true,
            "respectSchemaVersion": true
        },
        "nodejs": {
            "packageDescription": "A Pulumi package for creating and managing consul resources.",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/hashicorp/terraform-provider-consul)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-consul` repo](https://github.com/pulumi/pulumi-consul/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-consul` repo](https://github.com/hashicorp/terraform-provider-consul/issues).",
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "compatibility": "tfbridge20",
            "disableUnionOutputTypes": true,
            "respectSchemaVersion": true
        },
        "python": {
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/hashicorp/terraform-provider-consul)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-consul` repo](https://github.com/pulumi/pulumi-consul/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-consul` repo](https://github.com/hashicorp/terraform-provider-consul/issues).",
            "compatibility": "tfbridge20",
            "respectSchemaVersion": true,
            "pyproject": {
                "enabled": true
            }
        }
    },
    "config": {
        "variables": {
            "address": {
                "type": "string",
                "description": "The HTTP(S) API address of the agent to use. Defaults to \"127.0.0.1:8500\"."
            },
            "authJwt": {
                "$ref": "#/types/consul:config/authJwt:authJwt",
                "description": "Authenticates to Consul using a JWT authentication method."
            },
            "caFile": {
                "type": "string",
                "description": "A path to a PEM-encoded certificate authority used to verify the remote agent's certificate."
            },
            "caPath": {
                "type": "string",
                "description": "A path to a directory of PEM-encoded certificate authority files to use to check the authenticity of client and server connections. Can also be specified with the `CONSUL_CAPATH` environment variable."
            },
            "caPem": {
                "type": "string",
                "description": "PEM-encoded certificate authority used to verify the remote agent's certificate."
            },
            "certFile": {
                "type": "string",
                "description": "A path to a PEM-encoded certificate provided to the remote agent; requires use of `key_file` or `key_pem`."
            },
            "certPem": {
                "type": "string",
                "description": "PEM-encoded certificate provided to the remote agent; requires use of `key_file` or `key_pem`."
            },
            "datacenter": {
                "type": "string",
                "description": "The datacenter to use. Defaults to that of the agent."
            },
            "headers": {
                "type": "array",
                "items": {
                    "$ref": "#/types/consul:config/headers:headers"
                },
                "description": "A configuration block, described below, that provides additional headers to be sent along with all requests to the Consul server. This block can be specified multiple times.",
                "secret": true
            },
            "httpAuth": {
                "type": "string",
                "description": "HTTP Basic Authentication credentials to be used when communicating with Consul, in the format of either `user` or `user:pass`. This may also be specified using the `CONSUL_HTTP_AUTH` environment variable."
            },
            "insecureHttps": {
                "type": "boolean",
                "description": "Boolean value to disable SSL certificate verification; setting this value to true is not recommended for production use. Only use this with scheme set to \"https\"."
            },
            "keyFile": {
                "type": "string",
                "description": "A path to a PEM-encoded private key, required if `cert_file` or `cert_pem` is specified."
            },
            "keyPem": {
                "type": "string",
                "description": "PEM-encoded private key, required if `cert_file` or `cert_pem` is specified."
            },
            "namespace": {
                "type": "string"
            },
            "scheme": {
                "type": "string",
                "description": "The URL scheme of the agent to use (\"http\" or \"https\"). Defaults to \"http\"."
            },
            "token": {
                "type": "string",
                "description": "The ACL token to use by default when making requests to the agent. Can also be specified with `CONSUL_HTTP_TOKEN` or `CONSUL_TOKEN` as an environment variable.",
                "secret": true
            }
        }
    },
    "types": {
        "consul:config/authJwt:authJwt": {
            "properties": {
                "authMethod": {
                    "type": "string",
                    "description": "The name of the auth method to use for login.\n"
                },
                "bearerToken": {
                    "type": "string",
                    "description": "The bearer token to present to the auth method during login for authentication purposes. For the Kubernetes auth method this is a [Service Account Token (JWT)](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#service-account-tokens).\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies arbitrary KV metadata linked to the token. Can be useful to track origins.\n"
                },
                "useTerraformCloudWorkloadIdentity": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "authMethod"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:config/headers:headers": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the header.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the header.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/AclAuthMethodNamespaceRule:AclAuthMethodNamespaceRule": {
            "properties": {
                "bindNamespace": {
                    "type": "string",
                    "description": "If the namespace rule's `selector` matches then this is used to control the namespace where the token is created.\n"
                },
                "selector": {
                    "type": "string",
                    "description": "Specifies the expression used to match this namespace rule against valid identities returned from an auth method validation.\n"
                }
            },
            "type": "object",
            "required": [
                "bindNamespace"
            ]
        },
        "consul:index/AclBindingRuleBindVars:AclBindingRuleBindVars": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of node, workload identity or service.\n"
                }
            },
            "type": "object"
        },
        "consul:index/AclRoleNodeIdentity:AclRoleNodeIdentity": {
            "properties": {
                "datacenter": {
                    "type": "string",
                    "description": "Specifies the node's datacenter.\n"
                },
                "nodeName": {
                    "type": "string",
                    "description": "The name of the node.\n"
                }
            },
            "type": "object",
            "required": [
                "datacenter",
                "nodeName"
            ]
        },
        "consul:index/AclRoleServiceIdentity:AclRoleServiceIdentity": {
            "properties": {
                "datacenters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The datacenters the effective policy is valid within. When no datacenters are provided the effective policy is valid in all datacenters including those which do not yet exist but may in the future.\n"
                },
                "serviceName": {
                    "type": "string",
                    "description": "The name of the service.\n"
                }
            },
            "type": "object",
            "required": [
                "serviceName"
            ]
        },
        "consul:index/AclRoleTemplatedPolicy:AclRoleTemplatedPolicy": {
            "properties": {
                "datacenters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the datacenters the effective policy is valid within.\n"
                },
                "templateName": {
                    "type": "string",
                    "description": "The name of the templated policies.\n"
                },
                "templateVariables": {
                    "$ref": "#/types/consul:index/AclRoleTemplatedPolicyTemplateVariables:AclRoleTemplatedPolicyTemplateVariables",
                    "description": "The templated policy variables.\n"
                }
            },
            "type": "object",
            "required": [
                "templateName"
            ]
        },
        "consul:index/AclRoleTemplatedPolicyTemplateVariables:AclRoleTemplatedPolicyTemplateVariables": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of node, workload identity or service.\n"
                }
            },
            "type": "object"
        },
        "consul:index/AclTokenNodeIdentity:AclTokenNodeIdentity": {
            "properties": {
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter of the node.\n"
                },
                "nodeName": {
                    "type": "string",
                    "description": "The name of the node.\n"
                }
            },
            "type": "object",
            "required": [
                "datacenter",
                "nodeName"
            ]
        },
        "consul:index/AclTokenServiceIdentity:AclTokenServiceIdentity": {
            "properties": {
                "datacenters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the datacenters the effective policy is valid within.\n"
                },
                "serviceName": {
                    "type": "string",
                    "description": "The name of the service.\n"
                }
            },
            "type": "object",
            "required": [
                "serviceName"
            ]
        },
        "consul:index/AclTokenTemplatedPolicy:AclTokenTemplatedPolicy": {
            "properties": {
                "datacenters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the datacenters the effective policy is valid within.\n"
                },
                "templateName": {
                    "type": "string",
                    "description": "The name of the templated policies.\n"
                },
                "templateVariables": {
                    "$ref": "#/types/consul:index/AclTokenTemplatedPolicyTemplateVariables:AclTokenTemplatedPolicyTemplateVariables",
                    "description": "The templated policy variables.\n"
                }
            },
            "type": "object",
            "required": [
                "templateName"
            ]
        },
        "consul:index/AclTokenTemplatedPolicyTemplateVariables:AclTokenTemplatedPolicyTemplateVariables": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of node, workload identity or service.\n"
                }
            },
            "type": "object"
        },
        "consul:index/CatalogEntryService:CatalogEntryService": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The address of the service. Defaults to the\nnode address.\n",
                    "willReplaceOnChanges": true
                },
                "id": {
                    "type": "string",
                    "description": "The ID of the service. Defaults to the `name`.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the service\n",
                    "willReplaceOnChanges": true
                },
                "port": {
                    "type": "integer",
                    "description": "The port of the service.\n",
                    "willReplaceOnChanges": true
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of values that are opaque to Consul,\nbut can be used to distinguish between services or nodes.\n",
                    "willReplaceOnChanges": true
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "id",
                        "name"
                    ]
                }
            }
        },
        "consul:index/ConfigEntryServiceDefaultsDestination:ConfigEntryServiceDefaultsDestination": {
            "properties": {
                "addresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "port": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "addresses",
                "port"
            ]
        },
        "consul:index/ConfigEntryServiceDefaultsEnvoyExtension:ConfigEntryServiceDefaultsEnvoyExtension": {
            "properties": {
                "arguments": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "consulVersion": {
                    "type": "string"
                },
                "envoyVersion": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "required": {
                    "type": "boolean"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceDefaultsExpose:ConfigEntryServiceDefaultsExpose": {
            "properties": {
                "checks": {
                    "type": "boolean",
                    "willReplaceOnChanges": true
                },
                "paths": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsExposePath:ConfigEntryServiceDefaultsExposePath"
                    },
                    "willReplaceOnChanges": true
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceDefaultsExposePath:ConfigEntryServiceDefaultsExposePath": {
            "properties": {
                "listenerPort": {
                    "type": "integer"
                },
                "localPathPort": {
                    "type": "integer"
                },
                "path": {
                    "type": "string"
                },
                "protocol": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceDefaultsMeshGateway:ConfigEntryServiceDefaultsMeshGateway": {
            "properties": {
                "mode": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "mode"
            ]
        },
        "consul:index/ConfigEntryServiceDefaultsTransparentProxy:ConfigEntryServiceDefaultsTransparentProxy": {
            "properties": {
                "dialedDirectly": {
                    "type": "boolean"
                },
                "outboundListenerPort": {
                    "type": "integer"
                }
            },
            "type": "object",
            "required": [
                "dialedDirectly",
                "outboundListenerPort"
            ]
        },
        "consul:index/ConfigEntryServiceDefaultsUpstreamConfig:ConfigEntryServiceDefaultsUpstreamConfig": {
            "properties": {
                "defaults": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsUpstreamConfigDefault:ConfigEntryServiceDefaultsUpstreamConfigDefault"
                    },
                    "description": "Specifies configurations that set default upstream settings. For information about overriding the default configurations for in for individual upstreams, refer to UpstreamConfig.Overrides.\n"
                },
                "overrides": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsUpstreamConfigOverride:ConfigEntryServiceDefaultsUpstreamConfigOverride"
                    },
                    "description": "Specifies options that override the default upstream configurations for individual upstreams.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceDefaultsUpstreamConfigDefault:ConfigEntryServiceDefaultsUpstreamConfigDefault": {
            "properties": {
                "balanceOutboundConnections": {
                    "type": "string",
                    "description": "Sets the strategy for allocating outbound connections from upstreams across Envoy proxy threads.\n"
                },
                "connectTimeoutMs": {
                    "type": "integer"
                },
                "limits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsUpstreamConfigDefaultLimit:ConfigEntryServiceDefaultsUpstreamConfigDefaultLimit"
                    },
                    "description": "Map that specifies a set of limits to apply to when connecting upstream services.\n"
                },
                "meshGateways": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsUpstreamConfigDefaultMeshGateway:ConfigEntryServiceDefaultsUpstreamConfigDefaultMeshGateway"
                    },
                    "description": "Specifies the default mesh gateway mode field for all upstreams.\n"
                },
                "passiveHealthChecks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsUpstreamConfigDefaultPassiveHealthCheck:ConfigEntryServiceDefaultsUpstreamConfigDefaultPassiveHealthCheck"
                    },
                    "description": "Map that specifies a set of rules that enable Consul to remove hosts from the upstream cluster that are unreachable or that return errors.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Specifies the default protocol for the service.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceDefaultsUpstreamConfigDefaultLimit:ConfigEntryServiceDefaultsUpstreamConfigDefaultLimit": {
            "properties": {
                "maxConcurrentRequests": {
                    "type": "integer",
                    "description": "Specifies the maximum number of concurrent requests.\n"
                },
                "maxConnections": {
                    "type": "integer",
                    "description": "Specifies the maximum number of connections a service instance can establish against the upstream.\n"
                },
                "maxPendingRequests": {
                    "type": "integer",
                    "description": "Specifies the maximum number of requests that are queued while waiting for a connection to establish.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceDefaultsUpstreamConfigDefaultMeshGateway:ConfigEntryServiceDefaultsUpstreamConfigDefaultMeshGateway": {
            "properties": {
                "mode": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceDefaultsUpstreamConfigDefaultPassiveHealthCheck:ConfigEntryServiceDefaultsUpstreamConfigDefaultPassiveHealthCheck": {
            "properties": {
                "baseEjectionTime": {
                    "type": "string",
                    "description": "Specifies the minimum amount of time that an ejected host must remain outside the cluster before rejoining.\n"
                },
                "enforcingConsecutive5xx": {
                    "type": "integer",
                    "description": "Specifies a percentage that indicates how many times out of 100 that Consul ejects the host when it detects an outlier status.\n"
                },
                "interval": {
                    "type": "string",
                    "description": "Specifies the time between checks.\n"
                },
                "maxEjectionPercent": {
                    "type": "integer",
                    "description": "Specifies the maximum percentage of an upstream cluster that Consul ejects when the proxy reports an outlier.\n"
                },
                "maxFailures": {
                    "type": "integer",
                    "description": "Specifies the number of consecutive failures allowed per check interval. If exceeded, Consul removes the host from the load balancer.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceDefaultsUpstreamConfigOverride:ConfigEntryServiceDefaultsUpstreamConfigOverride": {
            "properties": {
                "balanceOutboundConnections": {
                    "type": "string",
                    "description": "Sets the strategy for allocating outbound connections from upstreams across Envoy proxy threads.\n"
                },
                "connectTimeoutMs": {
                    "type": "integer"
                },
                "envoyListenerJson": {
                    "type": "string"
                },
                "limits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsUpstreamConfigOverrideLimit:ConfigEntryServiceDefaultsUpstreamConfigOverrideLimit"
                    },
                    "description": "Map that specifies a set of limits to apply to when connecting upstream services.\n"
                },
                "meshGateways": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsUpstreamConfigOverrideMeshGateway:ConfigEntryServiceDefaultsUpstreamConfigOverrideMeshGateway"
                    },
                    "description": "Specifies the default mesh gateway mode field for all upstreams.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the service you are setting the defaults for.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Specifies the namespace containing the upstream service that the configuration applies to.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "Specifies the name of the name of the Consul admin partition that the configuration entry applies to.\n"
                },
                "passiveHealthChecks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsUpstreamConfigOverridePassiveHealthCheck:ConfigEntryServiceDefaultsUpstreamConfigOverridePassiveHealthCheck"
                    },
                    "description": "Map that specifies a set of rules that enable Consul to remove hosts from the upstream cluster that are unreachable or that return errors.\n"
                },
                "peer": {
                    "type": "string",
                    "description": "Specifies the peer name of the upstream service that the configuration applies to.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Specifies the default protocol for the service.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceDefaultsUpstreamConfigOverrideLimit:ConfigEntryServiceDefaultsUpstreamConfigOverrideLimit": {
            "properties": {
                "maxConcurrentRequests": {
                    "type": "integer",
                    "description": "Specifies the maximum number of concurrent requests.\n"
                },
                "maxConnections": {
                    "type": "integer",
                    "description": "Specifies the maximum number of connections a service instance can establish against the upstream.\n"
                },
                "maxPendingRequests": {
                    "type": "integer",
                    "description": "Specifies the maximum number of requests that are queued while waiting for a connection to establish.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceDefaultsUpstreamConfigOverrideMeshGateway:ConfigEntryServiceDefaultsUpstreamConfigOverrideMeshGateway": {
            "properties": {
                "mode": {
                    "type": "string"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceDefaultsUpstreamConfigOverridePassiveHealthCheck:ConfigEntryServiceDefaultsUpstreamConfigOverridePassiveHealthCheck": {
            "properties": {
                "baseEjectionTime": {
                    "type": "string",
                    "description": "Specifies the minimum amount of time that an ejected host must remain outside the cluster before rejoining.\n"
                },
                "enforcingConsecutive5xx": {
                    "type": "integer",
                    "description": "Specifies a percentage that indicates how many times out of 100 that Consul ejects the host when it detects an outlier status.\n"
                },
                "interval": {
                    "type": "string",
                    "description": "Specifies the time between checks.\n"
                },
                "maxEjectionPercent": {
                    "type": "integer",
                    "description": "Specifies the maximum percentage of an upstream cluster that Consul ejects when the proxy reports an outlier.\n"
                },
                "maxFailures": {
                    "type": "integer",
                    "description": "Specifies the number of consecutive failures allowed per check interval. If exceeded, Consul removes the host from the load balancer.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceIntentionsJwt:ConfigEntryServiceIntentionsJwt": {
            "properties": {
                "providers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceIntentionsJwtProvider:ConfigEntryServiceIntentionsJwtProvider"
                    },
                    "description": "Specifies the names of one or more previously configured JWT provider configuration entries, which include the information necessary to validate a JSON web token.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceIntentionsJwtProvider:ConfigEntryServiceIntentionsJwtProvider": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "Specifies the name of a JWT provider defined in the Name field of the jwt-provider configuration entry.\n"
                },
                "verifyClaims": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceIntentionsJwtProviderVerifyClaim:ConfigEntryServiceIntentionsJwtProviderVerifyClaim"
                    },
                    "description": "Specifies additional token information to verify beyond what is configured in the JWT provider configuration entry.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceIntentionsJwtProviderVerifyClaim:ConfigEntryServiceIntentionsJwtProviderVerifyClaim": {
            "properties": {
                "paths": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the path to the claim in the JSON web token.\n"
                },
                "value": {
                    "type": "string",
                    "description": "Specifies the value to match on when verifying the the claim designated in path.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceIntentionsSource:ConfigEntryServiceIntentionsSource": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Specifies the action to take when the source sends traffic to the destination service.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Specifies a description of the intention.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the source that the intention allows or denies traffic from.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Specifies the traffic source namespace that the intention allows or denies traffic from.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "Specifies the name of an admin partition that the intention allows or denies traffic from.\n"
                },
                "peer": {
                    "type": "string",
                    "description": "Specifies the name of a peered Consul cluster that the intention allows or denies traffic from\n"
                },
                "permissions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceIntentionsSourcePermission:ConfigEntryServiceIntentionsSourcePermission"
                    },
                    "description": "Specifies a list of permissions for L7 traffic sources. The list contains one or more actions and a set of match criteria for each action.\n"
                },
                "precedence": {
                    "type": "integer",
                    "description": "The Precedence field contains a read-only integer. Consul generates the value based on name configurations for the source and destination services.\n"
                },
                "samenessGroup": {
                    "type": "string",
                    "description": "Specifies the name of a sameness group that the intention allows or denies traffic from.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Specifies the type of destination service that the configuration entry applies to.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceIntentionsSourcePermission:ConfigEntryServiceIntentionsSourcePermission": {
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Specifies the action to take when the source sends traffic to the destination service. The value is either allow or deny.\n"
                },
                "https": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceIntentionsSourcePermissionHttp:ConfigEntryServiceIntentionsSourcePermissionHttp"
                    },
                    "description": "Specifies a set of HTTP-specific match criteria.\n"
                }
            },
            "type": "object",
            "required": [
                "action",
                "https"
            ]
        },
        "consul:index/ConfigEntryServiceIntentionsSourcePermissionHttp:ConfigEntryServiceIntentionsSourcePermissionHttp": {
            "properties": {
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceIntentionsSourcePermissionHttpHeader:ConfigEntryServiceIntentionsSourcePermissionHttpHeader"
                    },
                    "description": "Specifies a header name and matching criteria for HTTP request headers.\n"
                },
                "methods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies a list of HTTP methods.\n"
                },
                "pathExact": {
                    "type": "string",
                    "description": "Specifies an exact path to match on the HTTP request path.\n"
                },
                "pathPrefix": {
                    "type": "string",
                    "description": "Specifies a path prefix to match on the HTTP request path.\n"
                },
                "pathRegex": {
                    "type": "string",
                    "description": "Defines a regular expression to match on the HTTP request path.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceIntentionsSourcePermissionHttpHeader:ConfigEntryServiceIntentionsSourcePermissionHttpHeader": {
            "properties": {
                "exact": {
                    "type": "string",
                    "description": "Specifies a value for the header key set in the Name field. If the request header value matches the Exact value, Consul applies the permission.\n"
                },
                "invert": {
                    "type": "boolean",
                    "description": "Inverts the matching logic configured in the Header.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the header to match.\n"
                },
                "prefix": {
                    "type": "string",
                    "description": "Specifies a prefix value for the header key set in the Name field.\n"
                },
                "present": {
                    "type": "boolean",
                    "description": "Enables a match if the header configured in the Name field appears in the request. Consul matches on any value as long as the header key appears in the request.\n"
                },
                "regex": {
                    "type": "string",
                    "description": "Specifies a regular expression pattern as the value for the header key set in the Name field.\n"
                },
                "suffix": {
                    "type": "string",
                    "description": "Specifies a suffix value for the header key set in the Name field.\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ]
        },
        "consul:index/ConfigEntryServiceResolverFailover:ConfigEntryServiceResolverFailover": {
            "properties": {
                "datacenters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies an ordered list of datacenters at the failover location to attempt connections to during a failover scenario. When Consul cannot establish a connection with the first datacenter in the list, it proceeds sequentially until establishing a connection with another datacenter.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Specifies the namespace at the failover location where the failover services are deployed.\n"
                },
                "samenessGroup": {
                    "type": "string",
                    "description": "Specifies the sameness group at the failover location where the failover services are deployed.\n"
                },
                "service": {
                    "type": "string",
                    "description": "Specifies the name of the service to resolve at the failover location during a failover scenario.\n"
                },
                "serviceSubset": {
                    "type": "string",
                    "description": "Specifies the name of a subset of service instances to resolve at the failover location during a failover scenario.\n"
                },
                "subsetName": {
                    "type": "string",
                    "description": "Name of subset.\n"
                },
                "targets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceResolverFailoverTarget:ConfigEntryServiceResolverFailoverTarget"
                    },
                    "description": "Specifies a fixed list of failover targets to try during failover. This list can express complicated failover scenarios.\n"
                }
            },
            "type": "object",
            "required": [
                "subsetName"
            ]
        },
        "consul:index/ConfigEntryServiceResolverFailoverTarget:ConfigEntryServiceResolverFailoverTarget": {
            "properties": {
                "datacenter": {
                    "type": "string",
                    "description": "Specifies the WAN federated datacenter to use for the failover target. If empty, the current datacenter is used.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Specifies the namespace to use for the failover target. If empty, the default namespace is used.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "Specifies the admin partition within the same datacenter to use for the failover target. If empty, the default partition is used.\n"
                },
                "peer": {
                    "type": "string",
                    "description": "Specifies the destination cluster peer to resolve the target service name from.\n"
                },
                "service": {
                    "type": "string",
                    "description": "Specifies the service name to use for the failover target. If empty, the current service name is used.\n"
                },
                "serviceSubset": {
                    "type": "string",
                    "description": "Specifies the named subset to use for the failover target. If empty, the default subset for the requested service name is used.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceResolverLoadBalancer:ConfigEntryServiceResolverLoadBalancer": {
            "properties": {
                "hashPolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceResolverLoadBalancerHashPolicy:ConfigEntryServiceResolverLoadBalancerHashPolicy"
                    },
                    "description": "Specifies a list of hash policies to use for hashing load balancing algorithms. Consul evaluates hash policies individually and combines them so that identical lists result in the same hash.\n"
                },
                "leastRequestConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceResolverLoadBalancerLeastRequestConfig:ConfigEntryServiceResolverLoadBalancerLeastRequestConfig"
                    },
                    "description": "Specifies configuration for the least*request policy type.\n"
                },
                "policy": {
                    "type": "string",
                    "description": "Specifies the type of load balancing policy for selecting a host.\n"
                },
                "ringHashConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceResolverLoadBalancerRingHashConfig:ConfigEntryServiceResolverLoadBalancerRingHashConfig"
                    },
                    "description": "Specifies configuration for the ring*hash policy type.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceResolverLoadBalancerHashPolicy:ConfigEntryServiceResolverLoadBalancerHashPolicy": {
            "properties": {
                "cookieConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceResolverLoadBalancerHashPolicyCookieConfig:ConfigEntryServiceResolverLoadBalancerHashPolicyCookieConfig"
                    },
                    "description": "Specifies additional configuration options for the cookie hash policy type.\n"
                },
                "field": {
                    "type": "string",
                    "description": "Specifies the attribute type to hash on. You cannot specify the Field parameter if SourceIP is also configured.\n"
                },
                "fieldValue": {
                    "type": "string",
                    "description": "Specifies the value to hash, such as a header name, cookie name, or a URL query parameter name.\n"
                },
                "sourceIp": {
                    "type": "boolean",
                    "description": "Determines if the hash type should be source IP address.\n"
                },
                "terminal": {
                    "type": "boolean",
                    "description": "Determines if Consul should stop computing the hash when multiple hash policies are present.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceResolverLoadBalancerHashPolicyCookieConfig:ConfigEntryServiceResolverLoadBalancerHashPolicyCookieConfig": {
            "properties": {
                "path": {
                    "type": "string",
                    "description": "Specifies the path to set for the cookie.\n"
                },
                "session": {
                    "type": "boolean",
                    "description": "Directs Consul to generate a session cookie with no expiration.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Specifies the TTL for generated cookies. Cannot be specified for session cookies.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceResolverLoadBalancerLeastRequestConfig:ConfigEntryServiceResolverLoadBalancerLeastRequestConfig": {
            "properties": {
                "choiceCount": {
                    "type": "integer"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceResolverLoadBalancerRingHashConfig:ConfigEntryServiceResolverLoadBalancerRingHashConfig": {
            "properties": {
                "maximumRingSize": {
                    "type": "integer",
                    "description": "Determines the maximum number of entries in the hash ring.\n"
                },
                "minimumRingSize": {
                    "type": "integer",
                    "description": "Determines the minimum number of entries in the hash ring.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceResolverRedirect:ConfigEntryServiceResolverRedirect": {
            "properties": {
                "datacenter": {
                    "type": "string",
                    "description": "Specifies the datacenter at the redirect’s destination that resolves local upstream requests.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Specifies the namespace at the redirect’s destination that resolves local upstream requests.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "Specifies the admin partition at the redirect’s destination that resolves local upstream requests.\n"
                },
                "peer": {
                    "type": "string",
                    "description": "Specifies the cluster with an active cluster peering connection at the redirect’s destination that resolves local upstream requests.\n"
                },
                "samenessGroup": {
                    "type": "string",
                    "description": "Specifies the sameness group at the redirect’s destination that resolves local upstream requests.\n"
                },
                "service": {
                    "type": "string",
                    "description": "Specifies the name of a service at the redirect’s destination that resolves local upstream requests.\n"
                },
                "serviceSubset": {
                    "type": "string",
                    "description": "Specifies the name of a subset of services at the redirect’s destination that resolves local upstream requests. If empty, the default subset is used. If specified, you must also specify at least one of the following in the same Redirect map: Service, Namespace, andDatacenter.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceResolverSubset:ConfigEntryServiceResolverSubset": {
            "properties": {
                "filter": {
                    "type": "string",
                    "description": "Specifies an expression that filters the DNS elements of service instances that belong to the subset. If empty, all healthy instances of a service are returned.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of subset.\n"
                },
                "onlyPassing": {
                    "type": "boolean",
                    "description": "Determines if instances that return a warning from a health check are allowed to resolve a request. When set to false, instances with passing and warning states are considered healthy. When set to true, only instances with a passing health check state are considered healthy.\n"
                }
            },
            "type": "object",
            "required": [
                "filter",
                "name",
                "onlyPassing"
            ]
        },
        "consul:index/ConfigEntryServiceRouterRoute:ConfigEntryServiceRouterRoute": {
            "properties": {
                "destination": {
                    "$ref": "#/types/consul:index/ConfigEntryServiceRouterRouteDestination:ConfigEntryServiceRouterRouteDestination",
                    "description": "Specifies the target service to route matching requests to, as well as behavior for the request to follow when routed.\n"
                },
                "match": {
                    "$ref": "#/types/consul:index/ConfigEntryServiceRouterRouteMatch:ConfigEntryServiceRouterRouteMatch",
                    "description": "Describes a set of criteria that Consul compares incoming L7 traffic with.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceRouterRouteDestination:ConfigEntryServiceRouterRouteDestination": {
            "properties": {
                "idleTimeout": {
                    "type": "string",
                    "description": "Specifies the total amount of time permitted for the request stream to be idle.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Specifies the Consul namespace to resolve the service from instead of the current namespace.\n"
                },
                "numRetries": {
                    "type": "integer",
                    "description": "Specifies the number of times to retry the request when a retry condition occurs.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "Specifies the Consul admin partition to resolve the service from instead of the current partition.\n"
                },
                "prefixRewrite": {
                    "type": "string",
                    "description": "Specifies rewrites to the HTTP request path before proxying it to its final destination.\n"
                },
                "requestHeaders": {
                    "$ref": "#/types/consul:index/ConfigEntryServiceRouterRouteDestinationRequestHeaders:ConfigEntryServiceRouterRouteDestinationRequestHeaders",
                    "description": "Specifies a set of HTTP-specific header modification rules applied to requests routed with the service router.\n"
                },
                "requestTimeout": {
                    "type": "string",
                    "description": "Specifies the total amount of time permitted for the entire downstream request to be processed, including retry attempts.\n"
                },
                "responseHeaders": {
                    "$ref": "#/types/consul:index/ConfigEntryServiceRouterRouteDestinationResponseHeaders:ConfigEntryServiceRouterRouteDestinationResponseHeaders",
                    "description": "Specifies a set of HTTP-specific header modification rules applied to responses routed with the service router.\n"
                },
                "retryOnConnectFailure": {
                    "type": "boolean",
                    "description": "Specifies that connection failure errors that trigger a retry request.\n"
                },
                "retryOnStatusCodes": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Specifies a list of integers for HTTP response status codes that trigger a retry request.\n"
                },
                "retryOns": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies a list of conditions for Consul to retry requests based on the response from an upstream service.\n"
                },
                "service": {
                    "type": "string",
                    "description": "Specifies the name of the service to resolve.\n"
                },
                "serviceSubset": {
                    "type": "string",
                    "description": "Specifies a named subset of the given service to resolve instead of the one defined as that service's `default_subset` in the service resolver configuration entry.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceRouterRouteDestinationRequestHeaders:ConfigEntryServiceRouterRouteDestinationRequestHeaders": {
            "properties": {
                "add": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Defines a set of key-value pairs to add to the header. Use header names as the keys.\n"
                },
                "removes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines a list of headers to remove.\n"
                },
                "set": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Defines a set of key-value pairs to add to the request header or to replace existing header values with.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceRouterRouteDestinationResponseHeaders:ConfigEntryServiceRouterRouteDestinationResponseHeaders": {
            "properties": {
                "add": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Defines a set of key-value pairs to add to the header. Use header names as the keys\n"
                },
                "removes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines a list of headers to remove.\n"
                },
                "set": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Defines a set of key-value pairs to add to the response header or to replace existing header values with\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceRouterRouteMatch:ConfigEntryServiceRouterRouteMatch": {
            "properties": {
                "http": {
                    "$ref": "#/types/consul:index/ConfigEntryServiceRouterRouteMatchHttp:ConfigEntryServiceRouterRouteMatchHttp",
                    "description": "Specifies a set of HTTP criteria used to evaluate incoming L7 traffic for matches.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceRouterRouteMatchHttp:ConfigEntryServiceRouterRouteMatchHttp": {
            "properties": {
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceRouterRouteMatchHttpHeader:ConfigEntryServiceRouterRouteMatchHttpHeader"
                    },
                    "description": "Specifies information in the HTTP request header to match with.\n"
                },
                "methods": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies HTTP methods that the match applies to.\n"
                },
                "pathExact": {
                    "type": "string",
                    "description": "Specifies the exact path to match on the HTTP request path.\n"
                },
                "pathPrefix": {
                    "type": "string",
                    "description": "Specifies the path prefix to match on the HTTP request path.\n"
                },
                "pathRegex": {
                    "type": "string",
                    "description": "Specifies a regular expression to match on the HTTP request path.\n"
                },
                "queryParams": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceRouterRouteMatchHttpQueryParam:ConfigEntryServiceRouterRouteMatchHttpQueryParam"
                    },
                    "description": "Specifies information to match to on HTTP query parameters.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceRouterRouteMatchHttpHeader:ConfigEntryServiceRouterRouteMatchHttpHeader": {
            "properties": {
                "exact": {
                    "type": "string",
                    "description": "Specifies that a request matches when the header with the given name is this exact value.\n"
                },
                "invert": {
                    "type": "boolean",
                    "description": "Specifies that the logic for the HTTP header match should be inverted.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the HTTP header to match.\n"
                },
                "prefix": {
                    "type": "string",
                    "description": "Specifies that a request matches when the header with the given name has this prefix.\n"
                },
                "present": {
                    "type": "boolean",
                    "description": "Specifies that a request matches when the value in the `name` argument is present anywhere in the HTTP header.\n"
                },
                "regex": {
                    "type": "string",
                    "description": "Specifies that a request matches when the header with the given name matches this regular expression.\n"
                },
                "suffix": {
                    "type": "string",
                    "description": "Specifies that a request matches when the header with the given name has this suffix.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceRouterRouteMatchHttpQueryParam:ConfigEntryServiceRouterRouteMatchHttpQueryParam": {
            "properties": {
                "exact": {
                    "type": "string",
                    "description": "Specifies that a request matches when the query parameter with the given name is this exact value.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the HTTP query parameter to match.\n"
                },
                "present": {
                    "type": "boolean",
                    "description": "Specifies that a request matches when the value in the `name` argument is present anywhere in the HTTP query parameter.\n"
                },
                "regex": {
                    "type": "string",
                    "description": "Specifies that a request matches when the query parameter with the given name matches this regular expression.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceSplitterSplit:ConfigEntryServiceSplitterSplit": {
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": "Specifies the namespace to use in the FQDN when resolving the service.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "Specifies the admin partition to use in the FQDN when resolving the service.\n"
                },
                "requestHeaders": {
                    "$ref": "#/types/consul:index/ConfigEntryServiceSplitterSplitRequestHeaders:ConfigEntryServiceSplitterSplitRequestHeaders",
                    "description": "Specifies a set of HTTP-specific header modification rules applied to requests routed with the service split. You cannot configure request headers if the listener protocol is set to `tcp`.\n"
                },
                "responseHeaders": {
                    "$ref": "#/types/consul:index/ConfigEntryServiceSplitterSplitResponseHeaders:ConfigEntryServiceSplitterSplitResponseHeaders",
                    "description": "Specifies a set of HTTP-specific header modification rules applied to responses routed with the service split. You cannot configure request headers if the listener protocol is set to `tcp`.\n"
                },
                "service": {
                    "type": "string",
                    "description": "Specifies the name of the service to resolve.\n"
                },
                "serviceSubset": {
                    "type": "string",
                    "description": "Specifies a subset of the service to resolve. A service subset assigns a name to a specific subset of discoverable service instances within a datacenter, such as `version2` or `canary`. All services have an unnamed default subset that returns all healthy instances.\n"
                },
                "weight": {
                    "type": "number",
                    "description": "Specifies the percentage of traffic sent to the set of service instances specified in the `service` field. Each weight must be a floating integer between `0` and `100`. The smallest representable value is `.01`. The sum of weights across all splits must add up to `100`.\n"
                }
            },
            "type": "object",
            "required": [
                "service",
                "weight"
            ]
        },
        "consul:index/ConfigEntryServiceSplitterSplitRequestHeaders:ConfigEntryServiceSplitterSplitRequestHeaders": {
            "properties": {
                "add": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of one or more key-value pairs. Defines a set of key-value pairs to add to the header. Use header names as the keys. Header names are not case-sensitive. If header values with the same name already exist, the value is appended and Consul applies both headers.\n"
                },
                "removes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines an list of headers to remove. Consul removes only headers containing exact matches. Header names are not case-sensitive.\n"
                },
                "set": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of one or more key-value pairs. Defines a set of key-value pairs to add to the request header or to replace existing header values with. Use header names as the keys. Header names are not case-sensitive. If header values with the same names already exist, Consul replaces the header values.\n"
                }
            },
            "type": "object"
        },
        "consul:index/ConfigEntryServiceSplitterSplitResponseHeaders:ConfigEntryServiceSplitterSplitResponseHeaders": {
            "properties": {
                "add": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of one or more key-value pairs. Defines a set of key-value pairs to add to the header. Use header names as the keys. Header names are not case-sensitive. If header values with the same name already exist, the value is appended and Consul applies both headers.\n"
                },
                "removes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Defines an list of headers to remove. Consul removes only headers containing exact matches. Header names are not case-sensitive.\n"
                },
                "set": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Map of one or more key-value pairs. Defines a set of key-value pairs to add to the request header or to replace existing header values with. Use header names as the keys. Header names are not case-sensitive. If header values with the same names already exist, Consul replaces the header values.\n"
                }
            },
            "type": "object"
        },
        "consul:index/KeyPrefixSubkeyCollection:KeyPrefixSubkeyCollection": {
            "properties": {
                "flags": {
                    "type": "integer",
                    "description": "An [unsigned integer value](https://www.consul.io/api/kv.html#flags-1)\nto attach to the key (defaults to 0).\n"
                },
                "path": {
                    "type": "string",
                    "description": "This is the path (which will be appended to the given\n`path_prefix`) in Consul that should be written to.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value to write to the given path.\n"
                }
            },
            "type": "object",
            "required": [
                "path",
                "value"
            ]
        },
        "consul:index/KeysKey:KeysKey": {
            "properties": {
                "default": {
                    "type": "string"
                },
                "delete": {
                    "type": "boolean",
                    "description": "If true, then the key will be deleted when\neither its configuration block is removed from the configuration or\nthe entire resource is destroyed. Otherwise, it will be left in Consul.\nDefaults to false.\n"
                },
                "flags": {
                    "type": "integer",
                    "description": "An [unsigned integer value](https://www.consul.io/api/kv.html#flags-1)\nto attach to the key (defaults to 0).\n"
                },
                "name": {
                    "type": "string",
                    "deprecationMessage": "Using consul.Keys resource to *read* is deprecated; please use consul.Keys data source instead"
                },
                "path": {
                    "type": "string",
                    "description": "This is the path in Consul that should be written to.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value to write to the given path.\n"
                }
            },
            "type": "object",
            "required": [
                "path"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "path",
                        "value"
                    ]
                }
            }
        },
        "consul:index/PreparedQueryDns:PreparedQueryDns": {
            "properties": {
                "ttl": {
                    "type": "string",
                    "description": "The TTL to send when returning DNS results.\n"
                }
            },
            "type": "object"
        },
        "consul:index/PreparedQueryFailover:PreparedQueryFailover": {
            "properties": {
                "datacenters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Remote datacenters to return results from.\n"
                },
                "nearestN": {
                    "type": "integer",
                    "description": "Return results from this many datacenters, sorted in ascending order of estimated RTT.\n"
                },
                "targets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/PreparedQueryFailoverTarget:PreparedQueryFailoverTarget"
                    },
                    "description": "Specifies a sequential list of remote datacenters and cluster peers to failover to if there are no healthy service instances in the local datacenter. This option cannot be used with `nearest_n` or `datacenters`.\n"
                }
            },
            "type": "object"
        },
        "consul:index/PreparedQueryFailoverTarget:PreparedQueryFailoverTarget": {
            "properties": {
                "datacenter": {
                    "type": "string",
                    "description": "Specifies a WAN federated datacenter to forward the query to.\n"
                },
                "peer": {
                    "type": "string",
                    "description": "Specifies a cluster peer to use for failover.\n"
                }
            },
            "type": "object"
        },
        "consul:index/PreparedQueryTemplate:PreparedQueryTemplate": {
            "properties": {
                "regexp": {
                    "type": "string",
                    "description": "The regular expression to match with. When using `name_prefix_match`, this regex is applied against the query name.\n"
                },
                "removeEmptyTags": {
                    "type": "boolean",
                    "description": "If set to true, will cause the tags list inside the service structure to be stripped of any empty strings.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of template matching to perform. Currently only `name_prefix_match` is supported.\n"
                }
            },
            "type": "object",
            "required": [
                "regexp",
                "type"
            ]
        },
        "consul:index/ProviderAuthJwt:ProviderAuthJwt": {
            "properties": {
                "authMethod": {
                    "type": "string",
                    "description": "The name of the auth method to use for login.\n"
                },
                "bearerToken": {
                    "type": "string",
                    "description": "The bearer token to present to the auth method during login for authentication purposes. For the Kubernetes auth method this is a [Service Account Token (JWT)](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#service-account-tokens).\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies arbitrary KV metadata linked to the token. Can be useful to track origins.\n"
                },
                "useTerraformCloudWorkloadIdentity": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "authMethod"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "consul:index/ProviderHeader:ProviderHeader": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the header.\n"
                },
                "value": {
                    "type": "string",
                    "description": "The value of the header.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "value"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": []
                }
            }
        },
        "consul:index/ServiceCheck:ServiceCheck": {
            "properties": {
                "checkId": {
                    "type": "string",
                    "description": "An ID, *unique per agent*.\n"
                },
                "deregisterCriticalServiceAfter": {
                    "type": "string",
                    "description": "The time after which the service is automatically deregistered when in the `critical` state. Defaults to `30s`. Setting to `0` will disable.\n"
                },
                "headers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ServiceCheckHeader:ServiceCheckHeader"
                    },
                    "description": "The headers to send for an HTTP check. The attributes of each header is given below.\n"
                },
                "http": {
                    "type": "string",
                    "description": "The HTTP endpoint to call for an HTTP check.\n"
                },
                "interval": {
                    "type": "string",
                    "description": "The interval to wait between each health-check invocation.\n"
                },
                "method": {
                    "type": "string",
                    "description": "The method to use for HTTP health-checks. Defaults to `GET`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the health-check.\n"
                },
                "notes": {
                    "type": "string",
                    "description": "An opaque field meant to hold human readable text.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The initial health-check status.\n"
                },
                "tcp": {
                    "type": "string",
                    "description": "The TCP address and port to connect to for a TCP check.\n"
                },
                "timeout": {
                    "type": "string",
                    "description": "Specifies a timeout for outgoing connections in the case of a HTTP or TCP check.\n"
                },
                "tlsSkipVerify": {
                    "type": "boolean",
                    "description": "Whether to deactivate certificate verification for HTTP health-checks. Defaults to `false`.\n"
                }
            },
            "type": "object",
            "required": [
                "checkId",
                "interval",
                "name",
                "timeout"
            ],
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "checkId",
                        "interval",
                        "name",
                        "status",
                        "timeout"
                    ]
                }
            }
        },
        "consul:index/ServiceCheckHeader:ServiceCheckHeader": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of the header.\n"
                },
                "values": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The header's list of values.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "values"
            ]
        },
        "consul:index/getAclAuthMethodNamespaceRule:getAclAuthMethodNamespaceRule": {
            "properties": {
                "bindNamespace": {
                    "type": "string"
                },
                "selector": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "bindNamespace",
                "selector"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getAclRoleNodeIdentity:getAclRoleNodeIdentity": {
            "properties": {
                "datacenter": {
                    "type": "string",
                    "description": "Specifies the nodes datacenter. This will result in effective policy only being valid in that datacenter.\n"
                },
                "nodeName": {
                    "type": "string",
                    "description": "The name of the node.\n"
                }
            },
            "type": "object",
            "required": [
                "datacenter",
                "nodeName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getAclRolePolicy:getAclRolePolicy": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The ID of the policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the policy.\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getAclRoleServiceIdentity:getAclRoleServiceIdentity": {
            "properties": {
                "datacenters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the datacenters the effective policy is valid within.\n"
                },
                "serviceName": {
                    "type": "string",
                    "description": "The name of the service.\n"
                }
            },
            "type": "object"
        },
        "consul:index/getAclRoleTemplatedPolicy:getAclRoleTemplatedPolicy": {
            "properties": {
                "datacenters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the datacenters the effective policy is valid within.\n"
                },
                "templateName": {
                    "type": "string",
                    "description": "The name of the templated policies.\n"
                },
                "templateVariables": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/getAclRoleTemplatedPolicyTemplateVariable:getAclRoleTemplatedPolicyTemplateVariable"
                    },
                    "description": "The templated policy variables.\n"
                }
            },
            "type": "object",
            "required": [
                "datacenters",
                "templateName",
                "templateVariables"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getAclRoleTemplatedPolicyTemplateVariable:getAclRoleTemplatedPolicyTemplateVariable": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of node, workload identity or service.\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getAclTokenNodeIdentity:getAclTokenNodeIdentity": {
            "properties": {
                "datacenter": {
                    "type": "string",
                    "description": "Specifies the node's datacenter.\n"
                },
                "nodeName": {
                    "type": "string",
                    "description": "The list of node identities that should be applied to the token.\n"
                }
            },
            "type": "object",
            "required": [
                "datacenter",
                "nodeName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getAclTokenPolicy:getAclTokenPolicy": {
            "properties": {
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "id",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getAclTokenRole:getAclTokenRole": {
            "properties": {
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "id",
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getAclTokenServiceIdentity:getAclTokenServiceIdentity": {
            "properties": {
                "datacenters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the datacenters the effective policy is valid within.\n"
                },
                "serviceName": {
                    "type": "string",
                    "description": "The name of the service.\n"
                }
            },
            "type": "object",
            "required": [
                "datacenters",
                "serviceName"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getAclTokenTemplatedPolicy:getAclTokenTemplatedPolicy": {
            "properties": {
                "datacenters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies the datacenters the effective policy is valid within.\n"
                },
                "templateName": {
                    "type": "string",
                    "description": "The name of the templated policies.\n"
                },
                "templateVariables": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/getAclTokenTemplatedPolicyTemplateVariable:getAclTokenTemplatedPolicyTemplateVariable"
                    },
                    "description": "The templated policy variables.\n"
                }
            },
            "type": "object",
            "required": [
                "datacenters",
                "templateName",
                "templateVariables"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getAclTokenTemplatedPolicyTemplateVariable:getAclTokenTemplatedPolicyTemplateVariable": {
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The name of node, workload identity or service.\n"
                }
            },
            "type": "object",
            "required": [
                "name"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getAutopilotHealthServer:getAutopilotHealthServer": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The address of the server\n"
                },
                "healthy": {
                    "type": "boolean",
                    "description": "Whether the server is healthy according to the current Autopilot\nconfiguration\n"
                },
                "id": {
                    "type": "string",
                    "description": "The Raft ID of the server\n"
                },
                "lastContact": {
                    "type": "string",
                    "description": "The time elapsed since the server's last contact with\nthe leader\n"
                },
                "lastIndex": {
                    "type": "integer",
                    "description": "The index of the server's last committed Raft log entry\n"
                },
                "lastTerm": {
                    "type": "integer",
                    "description": "The server's last known Raft leader term\n"
                },
                "leader": {
                    "type": "boolean",
                    "description": "Whether the server is currently leader\n"
                },
                "name": {
                    "type": "string",
                    "description": "The node name of the server\n"
                },
                "serfStatus": {
                    "type": "string",
                    "description": "The status of the SerfHealth check of the server\n"
                },
                "stableSince": {
                    "type": "string",
                    "description": "The time this server has been in its current ``Healthy``\nstate\n"
                },
                "version": {
                    "type": "string",
                    "description": "The Consul version of the server\n"
                },
                "voter": {
                    "type": "boolean",
                    "description": "Whether the server is a voting member of the Raft cluster\n"
                }
            },
            "type": "object",
            "required": [
                "address",
                "healthy",
                "id",
                "lastContact",
                "lastIndex",
                "lastTerm",
                "leader",
                "name",
                "serfStatus",
                "stableSince",
                "version",
                "voter"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getCatalogNodesNode:getCatalogNodesNode": {
            "properties": {
                "address": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "The Node ID of the Consul agent.\n* [`meta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Node meta\ndata tag information, if any.\n* [`name`](https://www.consul.io/docs/agent/http/catalog.html#Node) - The name\nof the Consul node.\n* [`address`](https://www.consul.io/docs/agent/http/catalog.html#Address) - The\nIP address the node is advertising to the Consul cluster.\n* [`tagged_addresses`](https://www.consul.io/docs/agent/http/catalog.html#TaggedAddresses) -\nList of explicit LAN and WAN IP addresses for the agent.\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "name": {
                    "type": "string"
                },
                "taggedAddresses": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                }
            },
            "type": "object",
            "required": [
                "address",
                "id",
                "meta",
                "name",
                "taggedAddresses"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getCatalogNodesQueryOption:getCatalogNodesQueryOption": {
            "properties": {
                "allowStale": {
                    "type": "boolean",
                    "description": "When `true`, the default, allow responses from\nConsul servers that are followers.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The Consul datacenter to query.  Defaults to the\nsame value found in `query_options` parameter specified below, or if that is\nempty, the `datacenter` value found in the Consul agent that this provider is\nconfigured to talk to then the datacenter in the provider setup.\n"
                },
                "near": {
                    "type": "string"
                },
                "nodeMeta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "partition": {
                    "type": "string"
                },
                "requireConsistent": {
                    "type": "boolean",
                    "description": "When `true` force the client to perform a\nread on at least quorum servers and verify the result is the same.  Defaults\nto `false`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "Specify the Consul ACL token to use when performing the\nrequest.  This defaults to the same API token configured by the `consul`\nprovider but may be overridden if necessary.\n",
                    "secret": true
                },
                "waitIndex": {
                    "type": "integer",
                    "description": "Index number used to enable blocking queries.\n"
                },
                "waitTime": {
                    "type": "string",
                    "description": "Max time the client should wait for a blocking query\nto return.\n"
                }
            },
            "type": "object"
        },
        "consul:index/getCatalogServiceQueryOption:getCatalogServiceQueryOption": {
            "properties": {
                "allowStale": {
                    "type": "boolean",
                    "description": "When `true`, the default, allow responses from\nConsul servers that are followers.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The Consul datacenter to query.  Defaults to the\nsame value found in `query_options` parameter specified below, or if that is\nempty, the `datacenter` value found in the Consul agent that this provider is\nconfigured to talk to.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to lookup the service.\n"
                },
                "near": {
                    "type": "string"
                },
                "nodeMeta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "partition": {
                    "type": "string"
                },
                "requireConsistent": {
                    "type": "boolean",
                    "description": "When `true` force the client to perform a\nread on at least quorum servers and verify the result is the same.  Defaults\nto `false`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "Specify the Consul ACL token to use when performing the\nrequest.  This defaults to the same API token configured by the `consul`\nprovider but may be overridden if necessary.\n",
                    "secret": true
                },
                "waitIndex": {
                    "type": "integer",
                    "description": "Index number used to enable blocking queries.\n"
                },
                "waitTime": {
                    "type": "string",
                    "description": "Max time the client should wait for a blocking query\nto return.\n"
                }
            },
            "type": "object"
        },
        "consul:index/getCatalogServiceService:getCatalogServiceService": {
            "properties": {
                "address": {
                    "type": "string"
                },
                "createIndex": {
                    "type": "string"
                },
                "enableTagOverride": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "modifyIndex": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "The service name to select.\n"
                },
                "nodeAddress": {
                    "type": "string"
                },
                "nodeId": {
                    "type": "string",
                    "description": "The Node ID of the Consul agent advertising the service.\n* [`node_meta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Node\nmeta data tag information, if any.\n* [`node_name`](https://www.consul.io/docs/agent/http/catalog.html#Node) - The\nname of the Consul node.\n* [`address`](https://www.consul.io/docs/agent/http/catalog.html#ServiceAddress) -\nThe IP address of the service.  If the `ServiceAddress` in the Consul catalog\nis empty, this value is automatically populated with the `node_address` (the\n`Address` in the Consul Catalog).\n* [`enable_tag_override`](https://www.consul.io/docs/agent/http/catalog.html#ServiceEnableTagOverride) -\nWhether service tags can be overridden on this service.\n* [`id`](https://www.consul.io/docs/agent/http/catalog.html#ServiceID) - A\nunique service instance identifier.\n* [`name`](https://www.consul.io/docs/agent/http/catalog.html#ServiceName) - The\nname of the service.\n* [`port`](https://www.consul.io/docs/agent/http/catalog.html#ServicePort) -\nPort number of the service.\n* [`tagged_addresses`](https://www.consul.io/docs/agent/http/catalog.html#TaggedAddresses) -\nList of explicit LAN and WAN IP addresses for the agent.\n* [`tags`](https://www.consul.io/docs/agent/http/catalog.html#ServiceTags) -\nList of tags for the service.\n* [`meta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Service meta\ndata tag information, if any.\n"
                },
                "nodeMeta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "nodeName": {
                    "type": "string"
                },
                "port": {
                    "type": "string"
                },
                "taggedAddresses": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object",
            "required": [
                "address",
                "createIndex",
                "enableTagOverride",
                "id",
                "meta",
                "modifyIndex",
                "name",
                "nodeAddress",
                "nodeId",
                "nodeMeta",
                "nodeName",
                "port",
                "taggedAddresses",
                "tags"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getCatalogServicesQueryOption:getCatalogServicesQueryOption": {
            "properties": {
                "allowStale": {
                    "type": "boolean",
                    "description": "When `true`, the default, allow responses from\nConsul servers that are followers.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The Consul datacenter to query.  Defaults to the\nsame value found in `query_options` parameter specified below, or if that is\nempty, the `datacenter` value found in the Consul agent that this provider is\nconfigured to talk to.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to lookup the services.\n"
                },
                "near": {
                    "type": "string"
                },
                "nodeMeta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "partition": {
                    "type": "string"
                },
                "requireConsistent": {
                    "type": "boolean",
                    "description": "When `true` force the client to perform a\nread on at least quorum servers and verify the result is the same.  Defaults\nto `false`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "Specify the Consul ACL token to use when performing the\nrequest.  This defaults to the same API token configured by the `consul`\nprovider but may be overridden if necessary.\n",
                    "secret": true
                },
                "waitIndex": {
                    "type": "integer",
                    "description": "Index number used to enable blocking queries.\n"
                },
                "waitTime": {
                    "type": "string",
                    "description": "Max time the client should wait for a blocking query\nto return.\n"
                }
            },
            "type": "object"
        },
        "consul:index/getKeyPrefixSubkeyCollection:getKeyPrefixSubkeyCollection": {
            "properties": {
                "default": {
                    "type": "string",
                    "description": "This is the default value to set for `var.\u003cname\u003e`\nif the key does not exist in Consul. Defaults to an empty string.\n"
                },
                "name": {
                    "type": "string",
                    "description": "This is the name of the key. This value of the\nkey is exposed as `var.\u003cname\u003e`. This is not the path of the subkey\nin Consul.\n"
                },
                "path": {
                    "type": "string",
                    "description": "This is the subkey path in Consul (which will be appended\nto the given `path_prefix`) to construct the full key that will be used\nto read the value.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "path"
            ]
        },
        "consul:index/getKeysKey:getKeysKey": {
            "properties": {
                "default": {
                    "type": "string",
                    "description": "This is the default value to set for `var.\u003cname\u003e` if the key does not exist in Consul. Defaults to an empty string.\n"
                },
                "name": {
                    "type": "string",
                    "description": "This is the name of the key. This value of the key is exposed as `var.\u003cname\u003e`. This is not the path of the key in Consul.\n"
                },
                "path": {
                    "type": "string",
                    "description": "This is the path in Consul that should be read or written to.\n"
                }
            },
            "type": "object",
            "required": [
                "name",
                "path"
            ]
        },
        "consul:index/getNetworkAreaMembersMember:getNetworkAreaMembersMember": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The IP address of the server.\n"
                },
                "build": {
                    "type": "string",
                    "description": "The Consul version running on the node.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The node ID of the server.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The node name of the server, with its datacenter appended.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The server RPC port the node.\n"
                },
                "protocol": {
                    "type": "integer",
                    "description": "The protocol version being spoken by the node.\n"
                },
                "role": {
                    "type": "string",
                    "description": "Role is always `\"server\"` since only Consul servers can participate\nin network areas.\n"
                },
                "rtt": {
                    "type": "integer",
                    "description": "An estimated network round trip time from the server answering the\nquery to the given server, in nanoseconds. This is computed using network\ncoordinates.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The current health status of the node, as determined by the\nnetwork area distributed failure detector. This will be `\"alive\"`, `\"leaving\"`,\nor `\"failed\"`. A `\"failed\"` status means that other servers are not able to\nprobe this server over its server RPC interface.\n"
                }
            },
            "type": "object",
            "required": [
                "address",
                "build",
                "datacenter",
                "id",
                "name",
                "port",
                "protocol",
                "role",
                "rtt",
                "status"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getNodesNode:getNodesNode": {
            "properties": {
                "address": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "The Node ID of the Consul agent.\n* [`meta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Node meta\ndata tag information, if any.\n* [`name`](https://www.consul.io/docs/agent/http/catalog.html#Node) - The name\nof the Consul node.\n* [`address`](https://www.consul.io/docs/agent/http/catalog.html#Address) - The\nIP address the node is advertising to the Consul cluster.\n* [`tagged_addresses`](https://www.consul.io/docs/agent/http/catalog.html#TaggedAddresses) -\nList of explicit LAN and WAN IP addresses for the agent.\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "name": {
                    "type": "string"
                },
                "taggedAddresses": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                }
            },
            "type": "object",
            "required": [
                "address",
                "id",
                "meta",
                "name",
                "taggedAddresses"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getNodesQueryOption:getNodesQueryOption": {
            "properties": {
                "allowStale": {
                    "type": "boolean",
                    "description": "When `true`, the default, allow responses from\nConsul servers that are followers.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The Consul datacenter to query.  Defaults to the\nsame value found in `query_options` parameter specified below, or if that is\nempty, the `datacenter` value found in the Consul agent that this provider is\nconfigured to talk to then the datacenter in the provider setup.\n"
                },
                "near": {
                    "type": "string"
                },
                "nodeMeta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "partition": {
                    "type": "string"
                },
                "requireConsistent": {
                    "type": "boolean",
                    "description": "When `true` force the client to perform a\nread on at least quorum servers and verify the result is the same.  Defaults\nto `false`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "Specify the Consul ACL token to use when performing the\nrequest.  This defaults to the same API token configured by the `consul`\nprovider but may be overridden if necessary.\n",
                    "secret": true
                },
                "waitIndex": {
                    "type": "integer",
                    "description": "Index number used to enable blocking queries.\n"
                },
                "waitTime": {
                    "type": "string",
                    "description": "Max time the client should wait for a blocking query\nto return.\n"
                }
            },
            "type": "object"
        },
        "consul:index/getPeeringsPeer:getPeeringsPeer": {
            "properties": {
                "deletedAt": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "name": {
                    "type": "string"
                },
                "partition": {
                    "type": "string"
                },
                "peerCaPems": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "peerId": {
                    "type": "string"
                },
                "peerServerAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "peerServerName": {
                    "type": "string"
                },
                "state": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "deletedAt",
                "id",
                "meta",
                "name",
                "partition",
                "peerCaPems",
                "peerId",
                "peerServerAddresses",
                "peerServerName",
                "state"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getServiceHealthResult:getServiceHealthResult": {
            "properties": {
                "checks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/getServiceHealthResultCheck:getServiceHealthResultCheck"
                    }
                },
                "nodes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/getServiceHealthResultNode:getServiceHealthResultNode"
                    },
                    "description": "The name of the node associated with this health-check.\n"
                },
                "services": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/getServiceHealthResultService:getServiceHealthResultService"
                    }
                }
            },
            "type": "object",
            "required": [
                "checks",
                "nodes",
                "services"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getServiceHealthResultCheck:getServiceHealthResultCheck": {
            "properties": {
                "id": {
                    "type": "string",
                    "description": "The ID of this health-check.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The service name to select.\n"
                },
                "node": {
                    "type": "string",
                    "description": "The name of the node associated with this health-check.\n"
                },
                "notes": {
                    "type": "string",
                    "description": "A human readable description of the current state of the health-check.\n"
                },
                "output": {
                    "type": "string",
                    "description": "The output of the health-check.\n"
                },
                "serviceId": {
                    "type": "string",
                    "description": "The ID of the service associated to this health-check.\n"
                },
                "serviceName": {
                    "type": "string",
                    "description": "The name of the service associated with this health-check.\n"
                },
                "serviceTags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of tags associated with this health-check.\n"
                },
                "status": {
                    "type": "string",
                    "description": "The status of this health-check.\n"
                }
            },
            "type": "object",
            "required": [
                "id",
                "name",
                "node",
                "notes",
                "output",
                "serviceId",
                "serviceName",
                "serviceTags",
                "status"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getServiceHealthResultNode:getServiceHealthResultNode": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The address of this instance.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The Consul datacenter to query.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of this health-check.\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Service metadata tag information, if any.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The service name to select.\n"
                },
                "taggedAddresses": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                }
            },
            "type": "object",
            "required": [
                "address",
                "datacenter",
                "id",
                "meta",
                "name",
                "taggedAddresses"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getServiceHealthResultService:getServiceHealthResultService": {
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The address of this instance.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of this health-check.\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Service metadata tag information, if any.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The service name to select.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port of this instance.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of tags associated with this instance.\n"
                }
            },
            "type": "object",
            "required": [
                "address",
                "id",
                "meta",
                "name",
                "port",
                "tags"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getServiceQueryOption:getServiceQueryOption": {
            "properties": {
                "allowStale": {
                    "type": "boolean",
                    "description": "When `true`, the default, allow responses from\nConsul servers that are followers.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The Consul datacenter to query.  Defaults to the\nsame value found in `query_options` parameter specified below, or if that is\nempty, the `datacenter` value found in the Consul agent that this provider is\nconfigured to talk to.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to lookup the service.\n"
                },
                "near": {
                    "type": "string"
                },
                "nodeMeta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "partition": {
                    "type": "string"
                },
                "requireConsistent": {
                    "type": "boolean",
                    "description": "When `true` force the client to perform a\nread on at least quorum servers and verify the result is the same.  Defaults\nto `false`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "Specify the Consul ACL token to use when performing the\nrequest.  This defaults to the same API token configured by the `consul`\nprovider but may be overridden if necessary.\n",
                    "secret": true
                },
                "waitIndex": {
                    "type": "integer",
                    "description": "Index number used to enable blocking queries.\n"
                },
                "waitTime": {
                    "type": "string",
                    "description": "Max time the client should wait for a blocking query\nto return.\n"
                }
            },
            "type": "object"
        },
        "consul:index/getServiceService:getServiceService": {
            "properties": {
                "address": {
                    "type": "string"
                },
                "createIndex": {
                    "type": "string"
                },
                "enableTagOverride": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "modifyIndex": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "The service name to select.\n"
                },
                "nodeAddress": {
                    "type": "string"
                },
                "nodeId": {
                    "type": "string",
                    "description": "The Node ID of the Consul agent advertising the service.\n* [`node_meta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Node\nmeta data tag information, if any.\n* [`node_name`](https://www.consul.io/docs/agent/http/catalog.html#Node) - The\nname of the Consul node.\n* [`address`](https://www.consul.io/docs/agent/http/catalog.html#ServiceAddress) -\nThe IP address of the service.  If the `ServiceAddress` in the Consul catalog\nis empty, this value is automatically populated with the `node_address` (the\n`Address` in the Consul Catalog).\n* [`enable_tag_override`](https://www.consul.io/docs/agent/http/catalog.html#ServiceEnableTagOverride) -\nWhether service tags can be overridden on this service.\n* [`id`](https://www.consul.io/docs/agent/http/catalog.html#ServiceID) - A\nunique service instance identifier.\n* [`name`](https://www.consul.io/docs/agent/http/catalog.html#ServiceName) - The\nname of the service.\n* [`port`](https://www.consul.io/docs/agent/http/catalog.html#ServicePort) -\nPort number of the service.\n* [`tagged_addresses`](https://www.consul.io/docs/agent/http/catalog.html#TaggedAddresses) -\nList of explicit LAN and WAN IP addresses for the agent.\n* [`tags`](https://www.consul.io/docs/agent/http/catalog.html#ServiceTags) -\nList of tags for the service.\n* [`meta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Service meta\ndata tag information, if any.\n"
                },
                "nodeMeta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "nodeName": {
                    "type": "string"
                },
                "port": {
                    "type": "string"
                },
                "taggedAddresses": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "type": "object",
            "required": [
                "address",
                "createIndex",
                "enableTagOverride",
                "id",
                "meta",
                "modifyIndex",
                "name",
                "nodeAddress",
                "nodeId",
                "nodeMeta",
                "nodeName",
                "port",
                "taggedAddresses",
                "tags"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "consul:index/getServicesQueryOption:getServicesQueryOption": {
            "properties": {
                "allowStale": {
                    "type": "boolean",
                    "description": "When `true`, the default, allow responses from\nConsul servers that are followers.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The Consul datacenter to query.  Defaults to the\nsame value found in `query_options` parameter specified below, or if that is\nempty, the `datacenter` value found in the Consul agent that this provider is\nconfigured to talk to.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to lookup the services.\n"
                },
                "near": {
                    "type": "string"
                },
                "nodeMeta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "partition": {
                    "type": "string"
                },
                "requireConsistent": {
                    "type": "boolean",
                    "description": "When `true` force the client to perform a\nread on at least quorum servers and verify the result is the same.  Defaults\nto `false`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "Specify the Consul ACL token to use when performing the\nrequest.  This defaults to the same API token configured by the `consul`\nprovider but may be overridden if necessary.\n",
                    "secret": true
                },
                "waitIndex": {
                    "type": "integer",
                    "description": "Index number used to enable blocking queries.\n"
                },
                "waitTime": {
                    "type": "string",
                    "description": "Max time the client should wait for a blocking query\nto return.\n"
                }
            },
            "type": "object"
        }
    },
    "provider": {
        "description": "The provider type for the consul package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "address": {
                "type": "string",
                "description": "The HTTP(S) API address of the agent to use. Defaults to \"127.0.0.1:8500\"."
            },
            "authJwt": {
                "$ref": "#/types/consul:index/ProviderAuthJwt:ProviderAuthJwt",
                "description": "Authenticates to Consul using a JWT authentication method."
            },
            "caFile": {
                "type": "string",
                "description": "A path to a PEM-encoded certificate authority used to verify the remote agent's certificate."
            },
            "caPath": {
                "type": "string",
                "description": "A path to a directory of PEM-encoded certificate authority files to use to check the authenticity of client and server connections. Can also be specified with the `CONSUL_CAPATH` environment variable."
            },
            "caPem": {
                "type": "string",
                "description": "PEM-encoded certificate authority used to verify the remote agent's certificate."
            },
            "certFile": {
                "type": "string",
                "description": "A path to a PEM-encoded certificate provided to the remote agent; requires use of `key_file` or `key_pem`."
            },
            "certPem": {
                "type": "string",
                "description": "PEM-encoded certificate provided to the remote agent; requires use of `key_file` or `key_pem`."
            },
            "datacenter": {
                "type": "string",
                "description": "The datacenter to use. Defaults to that of the agent."
            },
            "headers": {
                "type": "array",
                "items": {
                    "$ref": "#/types/consul:index/ProviderHeader:ProviderHeader"
                },
                "description": "A configuration block, described below, that provides additional headers to be sent along with all requests to the Consul server. This block can be specified multiple times.",
                "secret": true
            },
            "httpAuth": {
                "type": "string",
                "description": "HTTP Basic Authentication credentials to be used when communicating with Consul, in the format of either `user` or `user:pass`. This may also be specified using the `CONSUL_HTTP_AUTH` environment variable."
            },
            "insecureHttps": {
                "type": "boolean",
                "description": "Boolean value to disable SSL certificate verification; setting this value to true is not recommended for production use. Only use this with scheme set to \"https\"."
            },
            "keyFile": {
                "type": "string",
                "description": "A path to a PEM-encoded private key, required if `cert_file` or `cert_pem` is specified."
            },
            "keyPem": {
                "type": "string",
                "description": "PEM-encoded private key, required if `cert_file` or `cert_pem` is specified."
            },
            "namespace": {
                "type": "string"
            },
            "scheme": {
                "type": "string",
                "description": "The URL scheme of the agent to use (\"http\" or \"https\"). Defaults to \"http\"."
            },
            "token": {
                "type": "string",
                "description": "The ACL token to use by default when making requests to the agent. Can also be specified with `CONSUL_HTTP_TOKEN` or `CONSUL_TOKEN` as an environment variable.",
                "secret": true
            }
        },
        "inputProperties": {
            "address": {
                "type": "string",
                "description": "The HTTP(S) API address of the agent to use. Defaults to \"127.0.0.1:8500\"."
            },
            "authJwt": {
                "$ref": "#/types/consul:index/ProviderAuthJwt:ProviderAuthJwt",
                "description": "Authenticates to Consul using a JWT authentication method."
            },
            "caFile": {
                "type": "string",
                "description": "A path to a PEM-encoded certificate authority used to verify the remote agent's certificate."
            },
            "caPath": {
                "type": "string",
                "description": "A path to a directory of PEM-encoded certificate authority files to use to check the authenticity of client and server connections. Can also be specified with the `CONSUL_CAPATH` environment variable."
            },
            "caPem": {
                "type": "string",
                "description": "PEM-encoded certificate authority used to verify the remote agent's certificate."
            },
            "certFile": {
                "type": "string",
                "description": "A path to a PEM-encoded certificate provided to the remote agent; requires use of `key_file` or `key_pem`."
            },
            "certPem": {
                "type": "string",
                "description": "PEM-encoded certificate provided to the remote agent; requires use of `key_file` or `key_pem`."
            },
            "datacenter": {
                "type": "string",
                "description": "The datacenter to use. Defaults to that of the agent."
            },
            "headers": {
                "type": "array",
                "items": {
                    "$ref": "#/types/consul:index/ProviderHeader:ProviderHeader"
                },
                "description": "A configuration block, described below, that provides additional headers to be sent along with all requests to the Consul server. This block can be specified multiple times.",
                "secret": true
            },
            "httpAuth": {
                "type": "string",
                "description": "HTTP Basic Authentication credentials to be used when communicating with Consul, in the format of either `user` or `user:pass`. This may also be specified using the `CONSUL_HTTP_AUTH` environment variable."
            },
            "insecureHttps": {
                "type": "boolean",
                "description": "Boolean value to disable SSL certificate verification; setting this value to true is not recommended for production use. Only use this with scheme set to \"https\"."
            },
            "keyFile": {
                "type": "string",
                "description": "A path to a PEM-encoded private key, required if `cert_file` or `cert_pem` is specified."
            },
            "keyPem": {
                "type": "string",
                "description": "PEM-encoded private key, required if `cert_file` or `cert_pem` is specified."
            },
            "namespace": {
                "type": "string"
            },
            "scheme": {
                "type": "string",
                "description": "The URL scheme of the agent to use (\"http\" or \"https\"). Defaults to \"http\"."
            },
            "token": {
                "type": "string",
                "description": "The ACL token to use by default when making requests to the agent. Can also be specified with `CONSUL_HTTP_TOKEN` or `CONSUL_TOKEN` as an environment variable.",
                "secret": true
            }
        },
        "methods": {
            "terraformConfig": "pulumi:providers:consul/terraformConfig"
        }
    },
    "resources": {
        "consul:index/aclAuthMethod:AclAuthMethod": {
            "description": "Starting with Consul 1.5.0, the `consul.AclAuthMethod` resource can be used to managed [Consul ACL auth methods](https://www.consul.io/docs/acl/auth-methods).\n\n## Example Usage\n\nDefine a `kubernetes` auth method:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst minikube = new consul.AclAuthMethod(\"minikube\", {\n    name: \"minikube\",\n    type: \"kubernetes\",\n    description: \"dev minikube cluster\",\n    configJson: JSON.stringify({\n        Host: \"https://192.0.2.42:8443\",\n        CACert: `-----BEGIN CERTIFICATE-----\n...-----END CERTIFICATE-----\n`,\n        ServiceAccountJWT: \"eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9...\",\n    }),\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_consul as consul\n\nminikube = consul.AclAuthMethod(\"minikube\",\n    name=\"minikube\",\n    type=\"kubernetes\",\n    description=\"dev minikube cluster\",\n    config_json=json.dumps({\n        \"Host\": \"https://192.0.2.42:8443\",\n        \"CACert\": \"\"\"-----BEGIN CERTIFICATE-----\n...-----END CERTIFICATE-----\n\"\"\",\n        \"ServiceAccountJWT\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9...\",\n    }))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var minikube = new Consul.AclAuthMethod(\"minikube\", new()\n    {\n        Name = \"minikube\",\n        Type = \"kubernetes\",\n        Description = \"dev minikube cluster\",\n        ConfigJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"Host\"] = \"https://192.0.2.42:8443\",\n            [\"CACert\"] = @\"-----BEGIN CERTIFICATE-----\n...-----END CERTIFICATE-----\n\",\n            [\"ServiceAccountJWT\"] = \"eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9...\",\n        }),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"Host\":              \"https://192.0.2.42:8443\",\n\t\t\t\"CACert\":            \"-----BEGIN CERTIFICATE-----\\n...-----END CERTIFICATE-----\\n\",\n\t\t\t\"ServiceAccountJWT\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9...\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\t_, err = consul.NewAclAuthMethod(ctx, \"minikube\", \u0026consul.AclAuthMethodArgs{\n\t\t\tName:        pulumi.String(\"minikube\"),\n\t\t\tType:        pulumi.String(\"kubernetes\"),\n\t\t\tDescription: pulumi.String(\"dev minikube cluster\"),\n\t\t\tConfigJson:  pulumi.String(json0),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.AclAuthMethod;\nimport com.pulumi.consul.AclAuthMethodArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var minikube = new AclAuthMethod(\"minikube\", AclAuthMethodArgs.builder()\n            .name(\"minikube\")\n            .type(\"kubernetes\")\n            .description(\"dev minikube cluster\")\n            .configJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"Host\", \"https://192.0.2.42:8443\"),\n                    jsonProperty(\"CACert\", \"\"\"\n-----BEGIN CERTIFICATE-----\n...-----END CERTIFICATE-----\n                    \"\"\"),\n                    jsonProperty(\"ServiceAccountJWT\", \"eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9...\")\n                )))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  minikube:\n    type: consul:AclAuthMethod\n    properties:\n      name: minikube\n      type: kubernetes\n      description: dev minikube cluster\n      configJson:\n        fn::toJSON:\n          Host: https://192.0.2.42:8443\n          CACert: |\n            -----BEGIN CERTIFICATE-----\n            ...-----END CERTIFICATE-----\n          ServiceAccountJWT: eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9...\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\nDefine a `jwt` auth method:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst oidc = new consul.AclAuthMethod(\"oidc\", {\n    name: \"auth0\",\n    type: \"oidc\",\n    maxTokenTtl: \"5m\",\n    configJson: JSON.stringify({\n        AllowedRedirectURIs: [\n            \"http://localhost:8550/oidc/callback\",\n            \"http://localhost:8500/ui/oidc/callback\",\n        ],\n        BoundAudiences: [\"V1RPi2MYptMV1RPi2MYptMV1RPi2MYpt\"],\n        ClaimMappings: {\n            \"http://example.com/first_name\": \"first_name\",\n            \"http://example.com/last_name\": \"last_name\",\n        },\n        ListClaimMappings: {\n            \"http://consul.com/groups\": \"groups\",\n        },\n        OIDCClientID: \"V1RPi2MYptMV1RPi2MYptMV1RPi2MYpt\",\n        OIDCClientSecret: \"...(omitted)...\",\n        OIDCDiscoveryURL: \"https://my-corp-app-name.auth0.com/\",\n    }),\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_consul as consul\n\noidc = consul.AclAuthMethod(\"oidc\",\n    name=\"auth0\",\n    type=\"oidc\",\n    max_token_ttl=\"5m\",\n    config_json=json.dumps({\n        \"AllowedRedirectURIs\": [\n            \"http://localhost:8550/oidc/callback\",\n            \"http://localhost:8500/ui/oidc/callback\",\n        ],\n        \"BoundAudiences\": [\"V1RPi2MYptMV1RPi2MYptMV1RPi2MYpt\"],\n        \"ClaimMappings\": {\n            \"http://example.com/first_name\": \"first_name\",\n            \"http://example.com/last_name\": \"last_name\",\n        },\n        \"ListClaimMappings\": {\n            \"http://consul.com/groups\": \"groups\",\n        },\n        \"OIDCClientID\": \"V1RPi2MYptMV1RPi2MYptMV1RPi2MYpt\",\n        \"OIDCClientSecret\": \"...(omitted)...\",\n        \"OIDCDiscoveryURL\": \"https://my-corp-app-name.auth0.com/\",\n    }))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var oidc = new Consul.AclAuthMethod(\"oidc\", new()\n    {\n        Name = \"auth0\",\n        Type = \"oidc\",\n        MaxTokenTtl = \"5m\",\n        ConfigJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"AllowedRedirectURIs\"] = new[]\n            {\n                \"http://localhost:8550/oidc/callback\",\n                \"http://localhost:8500/ui/oidc/callback\",\n            },\n            [\"BoundAudiences\"] = new[]\n            {\n                \"V1RPi2MYptMV1RPi2MYptMV1RPi2MYpt\",\n            },\n            [\"ClaimMappings\"] = new Dictionary\u003cstring, object?\u003e\n            {\n                [\"http://example.com/first_name\"] = \"first_name\",\n                [\"http://example.com/last_name\"] = \"last_name\",\n            },\n            [\"ListClaimMappings\"] = new Dictionary\u003cstring, object?\u003e\n            {\n                [\"http://consul.com/groups\"] = \"groups\",\n            },\n            [\"OIDCClientID\"] = \"V1RPi2MYptMV1RPi2MYptMV1RPi2MYpt\",\n            [\"OIDCClientSecret\"] = \"...(omitted)...\",\n            [\"OIDCDiscoveryURL\"] = \"https://my-corp-app-name.auth0.com/\",\n        }),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"AllowedRedirectURIs\": []string{\n\t\t\t\t\"http://localhost:8550/oidc/callback\",\n\t\t\t\t\"http://localhost:8500/ui/oidc/callback\",\n\t\t\t},\n\t\t\t\"BoundAudiences\": []string{\n\t\t\t\t\"V1RPi2MYptMV1RPi2MYptMV1RPi2MYpt\",\n\t\t\t},\n\t\t\t\"ClaimMappings\": map[string]interface{}{\n\t\t\t\t\"http://example.com/first_name\": \"first_name\",\n\t\t\t\t\"http://example.com/last_name\":  \"last_name\",\n\t\t\t},\n\t\t\t\"ListClaimMappings\": map[string]interface{}{\n\t\t\t\t\"http://consul.com/groups\": \"groups\",\n\t\t\t},\n\t\t\t\"OIDCClientID\":     \"V1RPi2MYptMV1RPi2MYptMV1RPi2MYpt\",\n\t\t\t\"OIDCClientSecret\": \"...(omitted)...\",\n\t\t\t\"OIDCDiscoveryURL\": \"https://my-corp-app-name.auth0.com/\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\t_, err = consul.NewAclAuthMethod(ctx, \"oidc\", \u0026consul.AclAuthMethodArgs{\n\t\t\tName:        pulumi.String(\"auth0\"),\n\t\t\tType:        pulumi.String(\"oidc\"),\n\t\t\tMaxTokenTtl: pulumi.String(\"5m\"),\n\t\t\tConfigJson:  pulumi.String(json0),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.AclAuthMethod;\nimport com.pulumi.consul.AclAuthMethodArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var oidc = new AclAuthMethod(\"oidc\", AclAuthMethodArgs.builder()\n            .name(\"auth0\")\n            .type(\"oidc\")\n            .maxTokenTtl(\"5m\")\n            .configJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"AllowedRedirectURIs\", jsonArray(\n                        \"http://localhost:8550/oidc/callback\", \n                        \"http://localhost:8500/ui/oidc/callback\"\n                    )),\n                    jsonProperty(\"BoundAudiences\", jsonArray(\"V1RPi2MYptMV1RPi2MYptMV1RPi2MYpt\")),\n                    jsonProperty(\"ClaimMappings\", jsonObject(\n                        jsonProperty(\"http://example.com/first_name\", \"first_name\"),\n                        jsonProperty(\"http://example.com/last_name\", \"last_name\")\n                    )),\n                    jsonProperty(\"ListClaimMappings\", jsonObject(\n                        jsonProperty(\"http://consul.com/groups\", \"groups\")\n                    )),\n                    jsonProperty(\"OIDCClientID\", \"V1RPi2MYptMV1RPi2MYptMV1RPi2MYpt\"),\n                    jsonProperty(\"OIDCClientSecret\", \"...(omitted)...\"),\n                    jsonProperty(\"OIDCDiscoveryURL\", \"https://my-corp-app-name.auth0.com/\")\n                )))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  oidc:\n    type: consul:AclAuthMethod\n    properties:\n      name: auth0\n      type: oidc\n      maxTokenTtl: 5m\n      configJson:\n        fn::toJSON:\n          AllowedRedirectURIs:\n            - http://localhost:8550/oidc/callback\n            - http://localhost:8500/ui/oidc/callback\n          BoundAudiences:\n            - V1RPi2MYptMV1RPi2MYptMV1RPi2MYpt\n          ClaimMappings:\n            http://example.com/first_name: first_name\n            http://example.com/last_name: last_name\n          ListClaimMappings:\n            http://consul.com/groups: groups\n          OIDCClientID: V1RPi2MYptMV1RPi2MYptMV1RPi2MYpt\n          OIDCClientSecret: '...(omitted)...'\n          OIDCDiscoveryURL: https://my-corp-app-name.auth0.com/\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The raw configuration for this ACL auth method.\n",
                    "deprecationMessage": "The config attribute is deprecated, please use `config_json` instead."
                },
                "configJson": {
                    "type": "string",
                    "description": "The raw configuration for this ACL auth method.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A free form human readable description of the auth method.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "An optional name to use instead of the name attribute when displaying information about this auth method.\n"
                },
                "maxTokenTtl": {
                    "type": "string",
                    "description": "The maximum life of any token created by this auth method. **This attribute is required and must be set to a nonzero for the OIDC auth method.**\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the ACL auth method.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace in which to create the auth method.\n"
                },
                "namespaceRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/AclAuthMethodNamespaceRule:AclAuthMethodNamespaceRule"
                    },
                    "description": "A set of rules that control which namespace tokens created via this auth method will be created within.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "The partition the ACL auth method is associated with.\n"
                },
                "tokenLocality": {
                    "type": "string",
                    "description": "The kind of token that this auth method produces. This can be either 'local' or 'global'.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the ACL auth method.\n"
                }
            },
            "required": [
                "name",
                "type"
            ],
            "inputProperties": {
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "The raw configuration for this ACL auth method.\n",
                    "deprecationMessage": "The config attribute is deprecated, please use `config_json` instead."
                },
                "configJson": {
                    "type": "string",
                    "description": "The raw configuration for this ACL auth method.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A free form human readable description of the auth method.\n"
                },
                "displayName": {
                    "type": "string",
                    "description": "An optional name to use instead of the name attribute when displaying information about this auth method.\n"
                },
                "maxTokenTtl": {
                    "type": "string",
                    "description": "The maximum life of any token created by this auth method. **This attribute is required and must be set to a nonzero for the OIDC auth method.**\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the ACL auth method.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace in which to create the auth method.\n",
                    "willReplaceOnChanges": true
                },
                "namespaceRules": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/AclAuthMethodNamespaceRule:AclAuthMethodNamespaceRule"
                    },
                    "description": "A set of rules that control which namespace tokens created via this auth method will be created within.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "The partition the ACL auth method is associated with.\n",
                    "willReplaceOnChanges": true
                },
                "tokenLocality": {
                    "type": "string",
                    "description": "The kind of token that this auth method produces. This can be either 'local' or 'global'.\n"
                },
                "type": {
                    "type": "string",
                    "description": "The type of the ACL auth method.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AclAuthMethod resources.\n",
                "properties": {
                    "config": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The raw configuration for this ACL auth method.\n",
                        "deprecationMessage": "The config attribute is deprecated, please use `config_json` instead."
                    },
                    "configJson": {
                        "type": "string",
                        "description": "The raw configuration for this ACL auth method.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A free form human readable description of the auth method.\n"
                    },
                    "displayName": {
                        "type": "string",
                        "description": "An optional name to use instead of the name attribute when displaying information about this auth method.\n"
                    },
                    "maxTokenTtl": {
                        "type": "string",
                        "description": "The maximum life of any token created by this auth method. **This attribute is required and must be set to a nonzero for the OIDC auth method.**\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the ACL auth method.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace in which to create the auth method.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespaceRules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/AclAuthMethodNamespaceRule:AclAuthMethodNamespaceRule"
                        },
                        "description": "A set of rules that control which namespace tokens created via this auth method will be created within.\n"
                    },
                    "partition": {
                        "type": "string",
                        "description": "The partition the ACL auth method is associated with.\n",
                        "willReplaceOnChanges": true
                    },
                    "tokenLocality": {
                        "type": "string",
                        "description": "The kind of token that this auth method produces. This can be either 'local' or 'global'.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "The type of the ACL auth method.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "consul:index/aclBindingRule:AclBindingRule": {
            "description": "Starting with Consul 1.5.0, the consul.AclBindingRule resource can be used to managed Consul ACL binding rules.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst minikube = new consul.AclAuthMethod(\"minikube\", {\n    name: \"minikube\",\n    type: \"kubernetes\",\n    description: \"dev minikube cluster\",\n    config: {\n        Host: \"https://192.0.2.42:8443\",\n        CACert: `-----BEGIN CERTIFICATE-----\n...-----END CERTIFICATE-----\n`,\n        ServiceAccountJWT: \"eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9...\",\n    },\n});\nconst test = new consul.AclBindingRule(\"test\", {\n    authMethod: minikube.name,\n    description: \"foobar\",\n    selector: \"serviceaccount.namespace==default\",\n    bindType: \"service\",\n    bindName: \"minikube\",\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\nminikube = consul.AclAuthMethod(\"minikube\",\n    name=\"minikube\",\n    type=\"kubernetes\",\n    description=\"dev minikube cluster\",\n    config={\n        \"Host\": \"https://192.0.2.42:8443\",\n        \"CACert\": \"\"\"-----BEGIN CERTIFICATE-----\n...-----END CERTIFICATE-----\n\"\"\",\n        \"ServiceAccountJWT\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9...\",\n    })\ntest = consul.AclBindingRule(\"test\",\n    auth_method=minikube.name,\n    description=\"foobar\",\n    selector=\"serviceaccount.namespace==default\",\n    bind_type=\"service\",\n    bind_name=\"minikube\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var minikube = new Consul.AclAuthMethod(\"minikube\", new()\n    {\n        Name = \"minikube\",\n        Type = \"kubernetes\",\n        Description = \"dev minikube cluster\",\n        Config = \n        {\n            { \"Host\", \"https://192.0.2.42:8443\" },\n            { \"CACert\", @\"-----BEGIN CERTIFICATE-----\n...-----END CERTIFICATE-----\n\" },\n            { \"ServiceAccountJWT\", \"eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9...\" },\n        },\n    });\n\n    var test = new Consul.AclBindingRule(\"test\", new()\n    {\n        AuthMethod = minikube.Name,\n        Description = \"foobar\",\n        Selector = \"serviceaccount.namespace==default\",\n        BindType = \"service\",\n        BindName = \"minikube\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tminikube, err := consul.NewAclAuthMethod(ctx, \"minikube\", \u0026consul.AclAuthMethodArgs{\n\t\t\tName:        pulumi.String(\"minikube\"),\n\t\t\tType:        pulumi.String(\"kubernetes\"),\n\t\t\tDescription: pulumi.String(\"dev minikube cluster\"),\n\t\t\tConfig: pulumi.StringMap{\n\t\t\t\t\"Host\":              pulumi.String(\"https://192.0.2.42:8443\"),\n\t\t\t\t\"CACert\":            pulumi.String(\"-----BEGIN CERTIFICATE-----\\n...-----END CERTIFICATE-----\\n\"),\n\t\t\t\t\"ServiceAccountJWT\": pulumi.String(\"eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9...\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = consul.NewAclBindingRule(ctx, \"test\", \u0026consul.AclBindingRuleArgs{\n\t\t\tAuthMethod:  minikube.Name,\n\t\t\tDescription: pulumi.String(\"foobar\"),\n\t\t\tSelector:    pulumi.String(\"serviceaccount.namespace==default\"),\n\t\t\tBindType:    pulumi.String(\"service\"),\n\t\t\tBindName:    pulumi.String(\"minikube\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.AclAuthMethod;\nimport com.pulumi.consul.AclAuthMethodArgs;\nimport com.pulumi.consul.AclBindingRule;\nimport com.pulumi.consul.AclBindingRuleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var minikube = new AclAuthMethod(\"minikube\", AclAuthMethodArgs.builder()\n            .name(\"minikube\")\n            .type(\"kubernetes\")\n            .description(\"dev minikube cluster\")\n            .config(Map.ofEntries(\n                Map.entry(\"Host\", \"https://192.0.2.42:8443\"),\n                Map.entry(\"CACert\", \"\"\"\n-----BEGIN CERTIFICATE-----\n...-----END CERTIFICATE-----\n                \"\"\"),\n                Map.entry(\"ServiceAccountJWT\", \"eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9...\")\n            ))\n            .build());\n\n        var test = new AclBindingRule(\"test\", AclBindingRuleArgs.builder()\n            .authMethod(minikube.name())\n            .description(\"foobar\")\n            .selector(\"serviceaccount.namespace==default\")\n            .bindType(\"service\")\n            .bindName(\"minikube\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  minikube:\n    type: consul:AclAuthMethod\n    properties:\n      name: minikube\n      type: kubernetes\n      description: dev minikube cluster\n      config:\n        Host: https://192.0.2.42:8443\n        CACert: |\n          -----BEGIN CERTIFICATE-----\n          ...-----END CERTIFICATE-----\n        ServiceAccountJWT: eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9...\n  test:\n    type: consul:AclBindingRule\n    properties:\n      authMethod: ${minikube.name}\n      description: foobar\n      selector: serviceaccount.namespace==default\n      bindType: service\n      bindName: minikube\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "authMethod": {
                    "type": "string",
                    "description": "The name of the ACL auth method this rule apply.\n"
                },
                "bindName": {
                    "type": "string",
                    "description": "The name to bind to a token at login-time.\n"
                },
                "bindType": {
                    "type": "string",
                    "description": "Specifies the way the binding rule affects a token created at login.\n"
                },
                "bindVars": {
                    "$ref": "#/types/consul:index/AclBindingRuleBindVars:AclBindingRuleBindVars",
                    "description": "The variables used when binding rule type is `templated-policy`. Can be lightly templated using HIL `${foo}` syntax from available field names.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A free form human readable description of the binding rule.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to create the binding rule within.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "The partition the ACL binding rule is associated with.\n"
                },
                "selector": {
                    "type": "string",
                    "description": "The expression used to match this rule against valid identities returned from an auth method validation.\n"
                }
            },
            "required": [
                "authMethod",
                "bindName",
                "bindType"
            ],
            "inputProperties": {
                "authMethod": {
                    "type": "string",
                    "description": "The name of the ACL auth method this rule apply.\n",
                    "willReplaceOnChanges": true
                },
                "bindName": {
                    "type": "string",
                    "description": "The name to bind to a token at login-time.\n"
                },
                "bindType": {
                    "type": "string",
                    "description": "Specifies the way the binding rule affects a token created at login.\n",
                    "willReplaceOnChanges": true
                },
                "bindVars": {
                    "$ref": "#/types/consul:index/AclBindingRuleBindVars:AclBindingRuleBindVars",
                    "description": "The variables used when binding rule type is `templated-policy`. Can be lightly templated using HIL `${foo}` syntax from available field names.\n"
                },
                "description": {
                    "type": "string",
                    "description": "A free form human readable description of the binding rule.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to create the binding rule within.\n",
                    "willReplaceOnChanges": true
                },
                "partition": {
                    "type": "string",
                    "description": "The partition the ACL binding rule is associated with.\n",
                    "willReplaceOnChanges": true
                },
                "selector": {
                    "type": "string",
                    "description": "The expression used to match this rule against valid identities returned from an auth method validation.\n"
                }
            },
            "requiredInputs": [
                "authMethod",
                "bindName",
                "bindType"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AclBindingRule resources.\n",
                "properties": {
                    "authMethod": {
                        "type": "string",
                        "description": "The name of the ACL auth method this rule apply.\n",
                        "willReplaceOnChanges": true
                    },
                    "bindName": {
                        "type": "string",
                        "description": "The name to bind to a token at login-time.\n"
                    },
                    "bindType": {
                        "type": "string",
                        "description": "Specifies the way the binding rule affects a token created at login.\n",
                        "willReplaceOnChanges": true
                    },
                    "bindVars": {
                        "$ref": "#/types/consul:index/AclBindingRuleBindVars:AclBindingRuleBindVars",
                        "description": "The variables used when binding rule type is `templated-policy`. Can be lightly templated using HIL `${foo}` syntax from available field names.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "A free form human readable description of the binding rule.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to create the binding rule within.\n",
                        "willReplaceOnChanges": true
                    },
                    "partition": {
                        "type": "string",
                        "description": "The partition the ACL binding rule is associated with.\n",
                        "willReplaceOnChanges": true
                    },
                    "selector": {
                        "type": "string",
                        "description": "The expression used to match this rule against valid identities returned from an auth method validation.\n"
                    }
                },
                "type": "object"
            }
        },
        "consul:index/aclPolicy:AclPolicy": {
            "description": "Starting with Consul 1.4.0, the consul.AclPolicy can be used to managed Consul ACL policies.\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst test = new consul.AclPolicy(\"test\", {\n    name: \"my_policy\",\n    datacenters: [\"dc1\"],\n    rules: `node_prefix \"\" {\n  policy = \"read\"\n}\n`,\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\ntest = consul.AclPolicy(\"test\",\n    name=\"my_policy\",\n    datacenters=[\"dc1\"],\n    rules=\"\"\"node_prefix \"\" {\n  policy = \"read\"\n}\n\"\"\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Consul.AclPolicy(\"test\", new()\n    {\n        Name = \"my_policy\",\n        Datacenters = new[]\n        {\n            \"dc1\",\n        },\n        Rules = @\"node_prefix \"\"\"\" {\n  policy = \"\"read\"\"\n}\n\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.NewAclPolicy(ctx, \"test\", \u0026consul.AclPolicyArgs{\n\t\t\tName: pulumi.String(\"my_policy\"),\n\t\t\tDatacenters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dc1\"),\n\t\t\t},\n\t\t\tRules: pulumi.String(\"node_prefix \\\"\\\" {\\n  policy = \\\"read\\\"\\n}\\n\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.AclPolicy;\nimport com.pulumi.consul.AclPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new AclPolicy(\"test\", AclPolicyArgs.builder()\n            .name(\"my_policy\")\n            .datacenters(\"dc1\")\n            .rules(\"\"\"\nnode_prefix \"\" {\n  policy = \"read\"\n}\n            \"\"\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: consul:AclPolicy\n    properties:\n      name: my_policy\n      datacenters:\n        - dc1\n      rules: |\n        node_prefix \"\" {\n          policy = \"read\"\n        }\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n`consul_acl_policy` can be imported:\n\n```sh\n$ pulumi import consul:index/aclPolicy:AclPolicy my-policy 1c90ef03-a6dd-6a8c-ac49-042ad3752896\n```\n",
            "properties": {
                "datacenters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The datacenters of the policy.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the policy.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to create the policy within.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "The partition the ACL policy is associated with.\n"
                },
                "rules": {
                    "type": "string",
                    "description": "The rules of the policy.\n"
                }
            },
            "required": [
                "name",
                "rules"
            ],
            "inputProperties": {
                "datacenters": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The datacenters of the policy.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the policy.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the policy.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to create the policy within.\n",
                    "willReplaceOnChanges": true
                },
                "partition": {
                    "type": "string",
                    "description": "The partition the ACL policy is associated with.\n",
                    "willReplaceOnChanges": true
                },
                "rules": {
                    "type": "string",
                    "description": "The rules of the policy.\n"
                }
            },
            "requiredInputs": [
                "rules"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AclPolicy resources.\n",
                "properties": {
                    "datacenters": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The datacenters of the policy.\n"
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the policy.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the policy.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to create the policy within.\n",
                        "willReplaceOnChanges": true
                    },
                    "partition": {
                        "type": "string",
                        "description": "The partition the ACL policy is associated with.\n",
                        "willReplaceOnChanges": true
                    },
                    "rules": {
                        "type": "string",
                        "description": "The rules of the policy.\n"
                    }
                },
                "type": "object"
            }
        },
        "consul:index/aclRole:AclRole": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst read_policy = new consul.AclPolicy(\"read-policy\", {\n    name: \"read-policy\",\n    rules: \"node \\\"\\\" { policy = \\\"read\\\" }\",\n    datacenters: [\"dc1\"],\n});\nconst read = new consul.AclRole(\"read\", {\n    name: \"foo\",\n    description: \"bar\",\n    policies: [read_policy.id],\n    serviceIdentities: [{\n        serviceName: \"foo\",\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\nread_policy = consul.AclPolicy(\"read-policy\",\n    name=\"read-policy\",\n    rules=\"node \\\"\\\" { policy = \\\"read\\\" }\",\n    datacenters=[\"dc1\"])\nread = consul.AclRole(\"read\",\n    name=\"foo\",\n    description=\"bar\",\n    policies=[read_policy.id],\n    service_identities=[{\n        \"service_name\": \"foo\",\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var read_policy = new Consul.AclPolicy(\"read-policy\", new()\n    {\n        Name = \"read-policy\",\n        Rules = \"node \\\"\\\" { policy = \\\"read\\\" }\",\n        Datacenters = new[]\n        {\n            \"dc1\",\n        },\n    });\n\n    var read = new Consul.AclRole(\"read\", new()\n    {\n        Name = \"foo\",\n        Description = \"bar\",\n        Policies = new[]\n        {\n            read_policy.Id,\n        },\n        ServiceIdentities = new[]\n        {\n            new Consul.Inputs.AclRoleServiceIdentityArgs\n            {\n                ServiceName = \"foo\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tread_policy, err := consul.NewAclPolicy(ctx, \"read-policy\", \u0026consul.AclPolicyArgs{\n\t\t\tName:  pulumi.String(\"read-policy\"),\n\t\t\tRules: pulumi.String(\"node \\\"\\\" { policy = \\\"read\\\" }\"),\n\t\t\tDatacenters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dc1\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = consul.NewAclRole(ctx, \"read\", \u0026consul.AclRoleArgs{\n\t\t\tName:        pulumi.String(\"foo\"),\n\t\t\tDescription: pulumi.String(\"bar\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tread_policy.ID(),\n\t\t\t},\n\t\t\tServiceIdentities: consul.AclRoleServiceIdentityArray{\n\t\t\t\t\u0026consul.AclRoleServiceIdentityArgs{\n\t\t\t\t\tServiceName: pulumi.String(\"foo\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.AclPolicy;\nimport com.pulumi.consul.AclPolicyArgs;\nimport com.pulumi.consul.AclRole;\nimport com.pulumi.consul.AclRoleArgs;\nimport com.pulumi.consul.inputs.AclRoleServiceIdentityArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var read_policy = new AclPolicy(\"read-policy\", AclPolicyArgs.builder()\n            .name(\"read-policy\")\n            .rules(\"node \\\"\\\" { policy = \\\"read\\\" }\")\n            .datacenters(\"dc1\")\n            .build());\n\n        var read = new AclRole(\"read\", AclRoleArgs.builder()\n            .name(\"foo\")\n            .description(\"bar\")\n            .policies(read_policy.id())\n            .serviceIdentities(AclRoleServiceIdentityArgs.builder()\n                .serviceName(\"foo\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  read-policy:\n    type: consul:AclPolicy\n    properties:\n      name: read-policy\n      rules: node \"\" { policy = \"read\" }\n      datacenters:\n        - dc1\n  read:\n    type: consul:AclRole\n    properties:\n      name: foo\n      description: bar\n      policies:\n        - ${[\"read-policy\"].id}\n      serviceIdentities:\n        - serviceName: foo\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import consul:index/aclRole:AclRole read 816a195f-6cb1-2e8d-92af-3011ae706318\n```\n\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "A free form human readable description of the role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the ACL role.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to create the role within.\n"
                },
                "nodeIdentities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/AclRoleNodeIdentity:AclRoleNodeIdentity"
                    },
                    "description": "The list of node identities that should be applied to the role.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "The partition the ACL role is associated with.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of policies that should be applied to the role. Both the policy ID or its name can be used.\n"
                },
                "serviceIdentities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/AclRoleServiceIdentity:AclRoleServiceIdentity"
                    },
                    "description": "The list of service identities that should be applied to the role.\n"
                },
                "templatedPolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/AclRoleTemplatedPolicy:AclRoleTemplatedPolicy"
                    },
                    "description": "The list of templated policies that should be applied to the token.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "A free form human readable description of the role.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the ACL role.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to create the role within.\n",
                    "willReplaceOnChanges": true
                },
                "nodeIdentities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/AclRoleNodeIdentity:AclRoleNodeIdentity"
                    },
                    "description": "The list of node identities that should be applied to the role.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "The partition the ACL role is associated with.\n",
                    "willReplaceOnChanges": true
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of policies that should be applied to the role. Both the policy ID or its name can be used.\n"
                },
                "serviceIdentities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/AclRoleServiceIdentity:AclRoleServiceIdentity"
                    },
                    "description": "The list of service identities that should be applied to the role.\n"
                },
                "templatedPolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/AclRoleTemplatedPolicy:AclRoleTemplatedPolicy"
                    },
                    "description": "The list of templated policies that should be applied to the token.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AclRole resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "A free form human readable description of the role.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the ACL role.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to create the role within.\n",
                        "willReplaceOnChanges": true
                    },
                    "nodeIdentities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/AclRoleNodeIdentity:AclRoleNodeIdentity"
                        },
                        "description": "The list of node identities that should be applied to the role.\n"
                    },
                    "partition": {
                        "type": "string",
                        "description": "The partition the ACL role is associated with.\n",
                        "willReplaceOnChanges": true
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of policies that should be applied to the role. Both the policy ID or its name can be used.\n"
                    },
                    "serviceIdentities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/AclRoleServiceIdentity:AclRoleServiceIdentity"
                        },
                        "description": "The list of service identities that should be applied to the role.\n"
                    },
                    "templatedPolicies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/AclRoleTemplatedPolicy:AclRoleTemplatedPolicy"
                        },
                        "description": "The list of templated policies that should be applied to the token.\n"
                    }
                },
                "type": "object"
            }
        },
        "consul:index/aclRolePolicyAttachment:AclRolePolicyAttachment": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst myRole = consul.getAclRole({\n    name: \"my_role\",\n});\nconst readPolicy = new consul.AclPolicy(\"read_policy\", {\n    name: \"read-policy\",\n    rules: \"node \\\"\\\" { policy = \\\"read\\\" }\",\n    datacenters: [\"dc1\"],\n});\nconst myRoleReadPolicy = new consul.AclRolePolicyAttachment(\"my_role_read_policy\", {\n    roleId: test.id,\n    policy: readPolicy.name,\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\nmy_role = consul.get_acl_role(name=\"my_role\")\nread_policy = consul.AclPolicy(\"read_policy\",\n    name=\"read-policy\",\n    rules=\"node \\\"\\\" { policy = \\\"read\\\" }\",\n    datacenters=[\"dc1\"])\nmy_role_read_policy = consul.AclRolePolicyAttachment(\"my_role_read_policy\",\n    role_id=test[\"id\"],\n    policy=read_policy.name)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myRole = Consul.GetAclRole.Invoke(new()\n    {\n        Name = \"my_role\",\n    });\n\n    var readPolicy = new Consul.AclPolicy(\"read_policy\", new()\n    {\n        Name = \"read-policy\",\n        Rules = \"node \\\"\\\" { policy = \\\"read\\\" }\",\n        Datacenters = new[]\n        {\n            \"dc1\",\n        },\n    });\n\n    var myRoleReadPolicy = new Consul.AclRolePolicyAttachment(\"my_role_read_policy\", new()\n    {\n        RoleId = test.Id,\n        Policy = readPolicy.Name,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.LookupAclRole(ctx, \u0026consul.LookupAclRoleArgs{\n\t\t\tName: \"my_role\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treadPolicy, err := consul.NewAclPolicy(ctx, \"read_policy\", \u0026consul.AclPolicyArgs{\n\t\t\tName:  pulumi.String(\"read-policy\"),\n\t\t\tRules: pulumi.String(\"node \\\"\\\" { policy = \\\"read\\\" }\"),\n\t\t\tDatacenters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dc1\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = consul.NewAclRolePolicyAttachment(ctx, \"my_role_read_policy\", \u0026consul.AclRolePolicyAttachmentArgs{\n\t\t\tRoleId: pulumi.Any(test.Id),\n\t\t\tPolicy: readPolicy.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConsulFunctions;\nimport com.pulumi.consul.inputs.GetAclRoleArgs;\nimport com.pulumi.consul.AclPolicy;\nimport com.pulumi.consul.AclPolicyArgs;\nimport com.pulumi.consul.AclRolePolicyAttachment;\nimport com.pulumi.consul.AclRolePolicyAttachmentArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var myRole = ConsulFunctions.getAclRole(GetAclRoleArgs.builder()\n            .name(\"my_role\")\n            .build());\n\n        var readPolicy = new AclPolicy(\"readPolicy\", AclPolicyArgs.builder()\n            .name(\"read-policy\")\n            .rules(\"node \\\"\\\" { policy = \\\"read\\\" }\")\n            .datacenters(\"dc1\")\n            .build());\n\n        var myRoleReadPolicy = new AclRolePolicyAttachment(\"myRoleReadPolicy\", AclRolePolicyAttachmentArgs.builder()\n            .roleId(test.id())\n            .policy(readPolicy.name())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  readPolicy:\n    type: consul:AclPolicy\n    name: read_policy\n    properties:\n      name: read-policy\n      rules: node \"\" { policy = \"read\" }\n      datacenters:\n        - dc1\n  myRoleReadPolicy:\n    type: consul:AclRolePolicyAttachment\n    name: my_role_read_policy\n    properties:\n      roleId: ${test.id}\n      policy: ${readPolicy.name}\nvariables:\n  myRole:\n    fn::invoke:\n      function: consul:getAclRole\n      arguments:\n        name: my_role\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import consul:index/aclRolePolicyAttachment:AclRolePolicyAttachment my_role_read_policy 624d94ca-bc5c-f960-4e83-0a609cf588be:policy_name\n```\n\n",
            "properties": {
                "policy": {
                    "type": "string",
                    "description": "The policy name.\n"
                },
                "roleId": {
                    "type": "string",
                    "description": "The id of the role.\n"
                }
            },
            "required": [
                "policy",
                "roleId"
            ],
            "inputProperties": {
                "policy": {
                    "type": "string",
                    "description": "The policy name.\n",
                    "willReplaceOnChanges": true
                },
                "roleId": {
                    "type": "string",
                    "description": "The id of the role.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "policy",
                "roleId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AclRolePolicyAttachment resources.\n",
                "properties": {
                    "policy": {
                        "type": "string",
                        "description": "The policy name.\n",
                        "willReplaceOnChanges": true
                    },
                    "roleId": {
                        "type": "string",
                        "description": "The id of the role.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "consul:index/aclToken:AclToken": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\nimport * as random from \"@pulumi/random\";\n\n// Basic usage\nconst agent = new consul.AclPolicy(\"agent\", {\n    name: \"agent\",\n    rules: `node_prefix \"\" {\n  policy = \"read\"\n}\n`,\n});\nconst test = new consul.AclToken(\"test\", {\n    description: \"my test token\",\n    policies: [agent.name],\n    local: true,\n});\n// Explicitly set the `accessor_id`\nconst testRandomUuid = new random.RandomUuid(\"test\", {});\nconst testPredefinedId = new consul.AclToken(\"test_predefined_id\", {\n    accessorId: testUuid.result,\n    description: \"my test uuid token\",\n    policies: [agent.name],\n    local: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\nimport pulumi_random as random\n\n# Basic usage\nagent = consul.AclPolicy(\"agent\",\n    name=\"agent\",\n    rules=\"\"\"node_prefix \"\" {\n  policy = \"read\"\n}\n\"\"\")\ntest = consul.AclToken(\"test\",\n    description=\"my test token\",\n    policies=[agent.name],\n    local=True)\n# Explicitly set the `accessor_id`\ntest_random_uuid = random.RandomUuid(\"test\")\ntest_predefined_id = consul.AclToken(\"test_predefined_id\",\n    accessor_id=test_uuid[\"result\"],\n    description=\"my test uuid token\",\n    policies=[agent.name],\n    local=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\nusing Random = Pulumi.Random;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Basic usage\n    var agent = new Consul.AclPolicy(\"agent\", new()\n    {\n        Name = \"agent\",\n        Rules = @\"node_prefix \"\"\"\" {\n  policy = \"\"read\"\"\n}\n\",\n    });\n\n    var test = new Consul.AclToken(\"test\", new()\n    {\n        Description = \"my test token\",\n        Policies = new[]\n        {\n            agent.Name,\n        },\n        Local = true,\n    });\n\n    // Explicitly set the `accessor_id`\n    var testRandomUuid = new Random.RandomUuid(\"test\");\n\n    var testPredefinedId = new Consul.AclToken(\"test_predefined_id\", new()\n    {\n        AccessorId = testUuid.Result,\n        Description = \"my test uuid token\",\n        Policies = new[]\n        {\n            agent.Name,\n        },\n        Local = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi-random/sdk/v4/go/random\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Basic usage\n\t\tagent, err := consul.NewAclPolicy(ctx, \"agent\", \u0026consul.AclPolicyArgs{\n\t\t\tName:  pulumi.String(\"agent\"),\n\t\t\tRules: pulumi.String(\"node_prefix \\\"\\\" {\\n  policy = \\\"read\\\"\\n}\\n\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = consul.NewAclToken(ctx, \"test\", \u0026consul.AclTokenArgs{\n\t\t\tDescription: pulumi.String(\"my test token\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tagent.Name,\n\t\t\t},\n\t\t\tLocal: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Explicitly set the `accessor_id`\n\t\t_, err = random.NewRandomUuid(ctx, \"test\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = consul.NewAclToken(ctx, \"test_predefined_id\", \u0026consul.AclTokenArgs{\n\t\t\tAccessorId:  pulumi.Any(testUuid.Result),\n\t\t\tDescription: pulumi.String(\"my test uuid token\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\tagent.Name,\n\t\t\t},\n\t\t\tLocal: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.AclPolicy;\nimport com.pulumi.consul.AclPolicyArgs;\nimport com.pulumi.consul.AclToken;\nimport com.pulumi.consul.AclTokenArgs;\nimport com.pulumi.random.RandomUuid;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Basic usage\n        var agent = new AclPolicy(\"agent\", AclPolicyArgs.builder()\n            .name(\"agent\")\n            .rules(\"\"\"\nnode_prefix \"\" {\n  policy = \"read\"\n}\n            \"\"\")\n            .build());\n\n        var test = new AclToken(\"test\", AclTokenArgs.builder()\n            .description(\"my test token\")\n            .policies(agent.name())\n            .local(true)\n            .build());\n\n        // Explicitly set the `accessor_id`\n        var testRandomUuid = new RandomUuid(\"testRandomUuid\");\n\n        var testPredefinedId = new AclToken(\"testPredefinedId\", AclTokenArgs.builder()\n            .accessorId(testUuid.result())\n            .description(\"my test uuid token\")\n            .policies(agent.name())\n            .local(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Basic usage\n  agent:\n    type: consul:AclPolicy\n    properties:\n      name: agent\n      rules: |\n        node_prefix \"\" {\n          policy = \"read\"\n        }\n  test:\n    type: consul:AclToken\n    properties:\n      description: my test token\n      policies:\n        - ${agent.name}\n      local: true\n  # Explicitly set the `accessor_id`\n  testRandomUuid:\n    type: random:RandomUuid\n    name: test\n  testPredefinedId:\n    type: consul:AclToken\n    name: test_predefined_id\n    properties:\n      accessorId: ${testUuid.result}\n      description: my test uuid token\n      policies:\n        - ${agent.name}\n      local: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import consul:index/aclToken:AclToken anonymous 00000000-0000-0000-0000-000000000002\n```\n\n```sh\n$ pulumi import consul:index/aclToken:AclToken master-token 624d94ca-bc5c-f960-4e83-0a609cf588be\n```\n\n",
            "properties": {
                "accessorId": {
                    "type": "string",
                    "description": "The uuid of the token. If omitted, Consul will generate a random uuid.\n"
                },
                "description": {
                    "type": "string",
                    "description": "The description of the token.\n"
                },
                "expirationTime": {
                    "type": "string",
                    "description": "If set this represents the point after which a token should be considered revoked and is eligible for destruction.\n"
                },
                "local": {
                    "type": "boolean",
                    "description": "The flag to set the token local to the current datacenter.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to create the token within.\n"
                },
                "nodeIdentities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/AclTokenNodeIdentity:AclTokenNodeIdentity"
                    },
                    "description": "The list of node identities that should be applied to the token.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "The partition the ACL token is associated with.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of policies attached to the token.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of roles attached to the token.\n"
                },
                "serviceIdentities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/AclTokenServiceIdentity:AclTokenServiceIdentity"
                    },
                    "description": "The list of service identities that should be applied to the token.\n"
                },
                "templatedPolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/AclTokenTemplatedPolicy:AclTokenTemplatedPolicy"
                    },
                    "description": "The list of templated policies that should be applied to the token.\n"
                }
            },
            "required": [
                "accessorId"
            ],
            "inputProperties": {
                "accessorId": {
                    "type": "string",
                    "description": "The uuid of the token. If omitted, Consul will generate a random uuid.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "The description of the token.\n"
                },
                "expirationTime": {
                    "type": "string",
                    "description": "If set this represents the point after which a token should be considered revoked and is eligible for destruction.\n",
                    "willReplaceOnChanges": true
                },
                "local": {
                    "type": "boolean",
                    "description": "The flag to set the token local to the current datacenter.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to create the token within.\n",
                    "willReplaceOnChanges": true
                },
                "nodeIdentities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/AclTokenNodeIdentity:AclTokenNodeIdentity"
                    },
                    "description": "The list of node identities that should be applied to the token.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "The partition the ACL token is associated with.\n",
                    "willReplaceOnChanges": true
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of policies attached to the token.\n"
                },
                "roles": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of roles attached to the token.\n"
                },
                "serviceIdentities": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/AclTokenServiceIdentity:AclTokenServiceIdentity"
                    },
                    "description": "The list of service identities that should be applied to the token.\n"
                },
                "templatedPolicies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/AclTokenTemplatedPolicy:AclTokenTemplatedPolicy"
                    },
                    "description": "The list of templated policies that should be applied to the token.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AclToken resources.\n",
                "properties": {
                    "accessorId": {
                        "type": "string",
                        "description": "The uuid of the token. If omitted, Consul will generate a random uuid.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "The description of the token.\n"
                    },
                    "expirationTime": {
                        "type": "string",
                        "description": "If set this represents the point after which a token should be considered revoked and is eligible for destruction.\n",
                        "willReplaceOnChanges": true
                    },
                    "local": {
                        "type": "boolean",
                        "description": "The flag to set the token local to the current datacenter.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to create the token within.\n",
                        "willReplaceOnChanges": true
                    },
                    "nodeIdentities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/AclTokenNodeIdentity:AclTokenNodeIdentity"
                        },
                        "description": "The list of node identities that should be applied to the token.\n"
                    },
                    "partition": {
                        "type": "string",
                        "description": "The partition the ACL token is associated with.\n",
                        "willReplaceOnChanges": true
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of policies attached to the token.\n"
                    },
                    "roles": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of roles attached to the token.\n"
                    },
                    "serviceIdentities": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/AclTokenServiceIdentity:AclTokenServiceIdentity"
                        },
                        "description": "The list of service identities that should be applied to the token.\n"
                    },
                    "templatedPolicies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/AclTokenTemplatedPolicy:AclTokenTemplatedPolicy"
                        },
                        "description": "The list of templated policies that should be applied to the token.\n"
                    }
                },
                "type": "object"
            }
        },
        "consul:index/aclTokenPolicyAttachment:AclTokenPolicyAttachment": {
            "description": "\n\n## Import\n\n`consul_acl_token_policy_attachment` can be imported. This is especially useful to manage the\n\npolicies attached to the anonymous and the master tokens with Terraform:\n\n```sh\n$ pulumi import consul:index/aclTokenPolicyAttachment:AclTokenPolicyAttachment anonymous 00000000-0000-0000-0000-000000000002:policy_name\n```\n\n```sh\n$ pulumi import consul:index/aclTokenPolicyAttachment:AclTokenPolicyAttachment master-token 624d94ca-bc5c-f960-4e83-0a609cf588be:policy_name\n```\n\n",
            "properties": {
                "policy": {
                    "type": "string",
                    "description": "The name of the policy attached to the token.\n"
                },
                "tokenId": {
                    "type": "string",
                    "description": "The id of the token.\n"
                }
            },
            "required": [
                "policy",
                "tokenId"
            ],
            "inputProperties": {
                "policy": {
                    "type": "string",
                    "description": "The name of the policy attached to the token.\n",
                    "willReplaceOnChanges": true
                },
                "tokenId": {
                    "type": "string",
                    "description": "The id of the token.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "policy",
                "tokenId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AclTokenPolicyAttachment resources.\n",
                "properties": {
                    "policy": {
                        "type": "string",
                        "description": "The name of the policy attached to the token.\n",
                        "willReplaceOnChanges": true
                    },
                    "tokenId": {
                        "type": "string",
                        "description": "The id of the token.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "consul:index/aclTokenRoleAttachment:AclTokenRoleAttachment": {
            "description": "\n\n## Import\n\n`consul_acl_token_role_attachment` can be imported. This is especially useful to manage the\npolicies attached to the anonymous and the master tokens with Terraform:\n\n```sh\n$ pulumi import consul:index/aclTokenRoleAttachment:AclTokenRoleAttachment anonymous token_id:role_id\n```\n",
            "properties": {
                "role": {
                    "type": "string",
                    "description": "The role name."
                },
                "tokenId": {
                    "type": "string",
                    "description": "The id of the token.\n"
                }
            },
            "required": [
                "role",
                "tokenId"
            ],
            "inputProperties": {
                "role": {
                    "type": "string",
                    "description": "The role name.",
                    "willReplaceOnChanges": true
                },
                "tokenId": {
                    "type": "string",
                    "description": "The id of the token.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "role",
                "tokenId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AclTokenRoleAttachment resources.\n",
                "properties": {
                    "role": {
                        "type": "string",
                        "description": "The role name.",
                        "willReplaceOnChanges": true
                    },
                    "tokenId": {
                        "type": "string",
                        "description": "The id of the token.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "consul:index/adminPartition:AdminPartition": {
            "description": "\u003e **NOTE:** This feature requires Consul Enterprise.\n\nThe `consul.AdminPartition` resource manages [Consul Enterprise Admin Partitions](https://www.consul.io/docs/enterprise/admin-partitions).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst naWest = new consul.AdminPartition(\"na_west\", {\n    name: \"na-west\",\n    description: \"Partition for North America West\",\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\nna_west = consul.AdminPartition(\"na_west\",\n    name=\"na-west\",\n    description=\"Partition for North America West\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var naWest = new Consul.AdminPartition(\"na_west\", new()\n    {\n        Name = \"na-west\",\n        Description = \"Partition for North America West\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.NewAdminPartition(ctx, \"na_west\", \u0026consul.AdminPartitionArgs{\n\t\t\tName:        pulumi.String(\"na-west\"),\n\t\t\tDescription: pulumi.String(\"Partition for North America West\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.AdminPartition;\nimport com.pulumi.consul.AdminPartitionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var naWest = new AdminPartition(\"naWest\", AdminPartitionArgs.builder()\n            .name(\"na-west\")\n            .description(\"Partition for North America West\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  naWest:\n    type: consul:AdminPartition\n    name: na_west\n    properties:\n      name: na-west\n      description: Partition for North America West\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n`consul_admin_partition` can be imported:\n\n```sh\n$ pulumi import consul:index/adminPartition:AdminPartition na_west na-west\n```\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Free form partition description.\n"
                },
                "disableGossip": {
                    "type": "boolean",
                    "description": ". Disable gossip pool for the partition. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The partition name. This must be a valid DNS hostname label.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Free form partition description.\n"
                },
                "disableGossip": {
                    "type": "boolean",
                    "description": ". Disable gossip pool for the partition. Defaults to `false`.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The partition name. This must be a valid DNS hostname label.\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AdminPartition resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Free form partition description.\n"
                    },
                    "disableGossip": {
                        "type": "boolean",
                        "description": ". Disable gossip pool for the partition. Defaults to `false`.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The partition name. This must be a valid DNS hostname label.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "consul:index/agentService:AgentService": {
            "description": "!\u003e The `consul.AgentService` resource has been deprecated in version 2.0.0 of the provider\nand will be removed in a future release. Please read the [upgrade guide](https://www.terraform.io/docs/providers/consul/guides/upgrading.html#deprecation-of-consul_agent_service)\nfor more information.\n\nProvides access to the agent service data in Consul. This can be used to\ndefine a service associated with a particular agent. Currently, defining\nhealth checks for an agent service is not supported.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst app = new consul.AgentService(\"app\", {\n    address: \"www.google.com\",\n    name: \"google\",\n    port: 80,\n    tags: [\n        \"tag0\",\n        \"tag1\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\napp = consul.AgentService(\"app\",\n    address=\"www.google.com\",\n    name=\"google\",\n    port=80,\n    tags=[\n        \"tag0\",\n        \"tag1\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var app = new Consul.AgentService(\"app\", new()\n    {\n        Address = \"www.google.com\",\n        Name = \"google\",\n        Port = 80,\n        Tags = new[]\n        {\n            \"tag0\",\n            \"tag1\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.NewAgentService(ctx, \"app\", \u0026consul.AgentServiceArgs{\n\t\t\tAddress: pulumi.String(\"www.google.com\"),\n\t\t\tName:    pulumi.String(\"google\"),\n\t\t\tPort:    pulumi.Int(80),\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"tag0\"),\n\t\t\t\tpulumi.String(\"tag1\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.AgentService;\nimport com.pulumi.consul.AgentServiceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var app = new AgentService(\"app\", AgentServiceArgs.builder()\n            .address(\"www.google.com\")\n            .name(\"google\")\n            .port(80)\n            .tags(            \n                \"tag0\",\n                \"tag1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  app:\n    type: consul:AgentService\n    properties:\n      address: www.google.com\n      name: google\n      port: 80\n      tags:\n        - tag0\n        - tag1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The address of the service. Defaults to the\naddress of the agent.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the service.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port of the service.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of values that are opaque to Consul,\nbut can be used to distinguish between services or nodes.\n"
                }
            },
            "required": [
                "address",
                "name"
            ],
            "inputProperties": {
                "address": {
                    "type": "string",
                    "description": "The address of the service. Defaults to the\naddress of the agent.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the service.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port of the service.\n",
                    "willReplaceOnChanges": true
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of values that are opaque to Consul,\nbut can be used to distinguish between services or nodes.\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AgentService resources.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The address of the service. Defaults to the\naddress of the agent.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the service.\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "The port of the service.\n",
                        "willReplaceOnChanges": true
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of values that are opaque to Consul,\nbut can be used to distinguish between services or nodes.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "consul:index/autopilotConfig:AutopilotConfig": {
            "description": "Provides access to the [Autopilot Configuration](https://www.consul.io/docs/guides/autopilot.html)\nof Consul to automatically manage Consul servers.\n\nIt includes to automatically cleanup dead servers, monitor the status of the Raft\ncluster and stable server introduction.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst config = new consul.AutopilotConfig(\"config\", {\n    cleanupDeadServers: false,\n    lastContactThreshold: \"1s\",\n    maxTrailingLogs: 500,\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\nconfig = consul.AutopilotConfig(\"config\",\n    cleanup_dead_servers=False,\n    last_contact_threshold=\"1s\",\n    max_trailing_logs=500)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var config = new Consul.AutopilotConfig(\"config\", new()\n    {\n        CleanupDeadServers = false,\n        LastContactThreshold = \"1s\",\n        MaxTrailingLogs = 500,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.NewAutopilotConfig(ctx, \"config\", \u0026consul.AutopilotConfigArgs{\n\t\t\tCleanupDeadServers:   pulumi.Bool(false),\n\t\t\tLastContactThreshold: pulumi.String(\"1s\"),\n\t\t\tMaxTrailingLogs:      pulumi.Int(500),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.AutopilotConfig;\nimport com.pulumi.consul.AutopilotConfigArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var config = new AutopilotConfig(\"config\", AutopilotConfigArgs.builder()\n            .cleanupDeadServers(false)\n            .lastContactThreshold(\"1s\")\n            .maxTrailingLogs(500)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  config:\n    type: consul:AutopilotConfig\n    properties:\n      cleanupDeadServers: false\n      lastContactThreshold: 1s\n      maxTrailingLogs: 500\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "cleanupDeadServers": {
                    "type": "boolean",
                    "description": "Whether to remove failing servers when a\nreplacement comes online. Defaults to true.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the agent's\ndefault datacenter and the datacenter in the provider setup.\n"
                },
                "disableUpgradeMigration": {
                    "type": "boolean",
                    "description": "Whether to disable [upgrade migrations](https://www.consul.io/docs/guides/autopilot.html#redundancy-zones).\nDefaults to false.\n"
                },
                "lastContactThreshold": {
                    "type": "string",
                    "description": "The time after which a server is\nconsidered as unhealthy and will be removed. Defaults to `\"200ms\"`.\n"
                },
                "maxTrailingLogs": {
                    "type": "integer",
                    "description": "The maximum number of Raft log entries a\nserver can trail the leader. Defaults to 250.\n"
                },
                "redundancyZoneTag": {
                    "type": "string",
                    "description": "The [redundancy zone](https://www.consul.io/docs/guides/autopilot.html#redundancy-zones)\ntag to use. Consul will try to keep one voting server by zone to take advantage\nof isolated failure domains. Defaults to an empty string.\n"
                },
                "serverStabilizationTime": {
                    "type": "string",
                    "description": "The period to wait for a server to be\nhealthy and stable before being promoted to a full, voting member. Defaults to\n`\"10s\"`.\n"
                },
                "upgradeVersionTag": {
                    "type": "string",
                    "description": "The tag to override the version information\nused during a migration. Defaults to an empty string.\n"
                }
            },
            "inputProperties": {
                "cleanupDeadServers": {
                    "type": "boolean",
                    "description": "Whether to remove failing servers when a\nreplacement comes online. Defaults to true.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the agent's\ndefault datacenter and the datacenter in the provider setup.\n",
                    "willReplaceOnChanges": true
                },
                "disableUpgradeMigration": {
                    "type": "boolean",
                    "description": "Whether to disable [upgrade migrations](https://www.consul.io/docs/guides/autopilot.html#redundancy-zones).\nDefaults to false.\n"
                },
                "lastContactThreshold": {
                    "type": "string",
                    "description": "The time after which a server is\nconsidered as unhealthy and will be removed. Defaults to `\"200ms\"`.\n"
                },
                "maxTrailingLogs": {
                    "type": "integer",
                    "description": "The maximum number of Raft log entries a\nserver can trail the leader. Defaults to 250.\n"
                },
                "redundancyZoneTag": {
                    "type": "string",
                    "description": "The [redundancy zone](https://www.consul.io/docs/guides/autopilot.html#redundancy-zones)\ntag to use. Consul will try to keep one voting server by zone to take advantage\nof isolated failure domains. Defaults to an empty string.\n"
                },
                "serverStabilizationTime": {
                    "type": "string",
                    "description": "The period to wait for a server to be\nhealthy and stable before being promoted to a full, voting member. Defaults to\n`\"10s\"`.\n"
                },
                "upgradeVersionTag": {
                    "type": "string",
                    "description": "The tag to override the version information\nused during a migration. Defaults to an empty string.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering AutopilotConfig resources.\n",
                "properties": {
                    "cleanupDeadServers": {
                        "type": "boolean",
                        "description": "Whether to remove failing servers when a\nreplacement comes online. Defaults to true.\n"
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The datacenter to use. This overrides the agent's\ndefault datacenter and the datacenter in the provider setup.\n",
                        "willReplaceOnChanges": true
                    },
                    "disableUpgradeMigration": {
                        "type": "boolean",
                        "description": "Whether to disable [upgrade migrations](https://www.consul.io/docs/guides/autopilot.html#redundancy-zones).\nDefaults to false.\n"
                    },
                    "lastContactThreshold": {
                        "type": "string",
                        "description": "The time after which a server is\nconsidered as unhealthy and will be removed. Defaults to `\"200ms\"`.\n"
                    },
                    "maxTrailingLogs": {
                        "type": "integer",
                        "description": "The maximum number of Raft log entries a\nserver can trail the leader. Defaults to 250.\n"
                    },
                    "redundancyZoneTag": {
                        "type": "string",
                        "description": "The [redundancy zone](https://www.consul.io/docs/guides/autopilot.html#redundancy-zones)\ntag to use. Consul will try to keep one voting server by zone to take advantage\nof isolated failure domains. Defaults to an empty string.\n"
                    },
                    "serverStabilizationTime": {
                        "type": "string",
                        "description": "The period to wait for a server to be\nhealthy and stable before being promoted to a full, voting member. Defaults to\n`\"10s\"`.\n"
                    },
                    "upgradeVersionTag": {
                        "type": "string",
                        "description": "The tag to override the version information\nused during a migration. Defaults to an empty string.\n"
                    }
                },
                "type": "object"
            }
        },
        "consul:index/catalogEntry:CatalogEntry": {
            "description": "!\u003e The `consul.CatalogEntry` resource has been deprecated in version 2.0.0 of the provider\nand will be removed in a future release. Please read the [upgrade guide](https://www.terraform.io/docs/providers/consul/guides/upgrading.html#deprecation-of-consul_catalog_entry)\nfor more information.\n\nRegisters a node or service with the [Consul Catalog](https://www.consul.io/docs/agent/http/catalog.html#catalog_register).\nCurrently, defining health checks is not supported.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  app:\n    type: consul:CatalogEntry\n    properties:\n      address: 192.168.10.10\n      node: foobar\n      services:\n        address: 127.0.0.1\n        id: redis1\n        name: redis\n        port: 8000\n        tags:\n          - master\n          - v1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The address of the node being added to,\nor referenced in the catalog.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n"
                },
                "node": {
                    "type": "string",
                    "description": "The name of the node being added to, or\nreferenced in the catalog.\n"
                },
                "services": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/CatalogEntryService:CatalogEntryService"
                    },
                    "description": "A service to optionally associated with\nthe node. Supported values are documented below.\n"
                },
                "token": {
                    "type": "string",
                    "description": "ACL token.\n",
                    "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                    "secret": true
                }
            },
            "required": [
                "address",
                "datacenter",
                "node"
            ],
            "inputProperties": {
                "address": {
                    "type": "string",
                    "description": "The address of the node being added to,\nor referenced in the catalog.\n",
                    "willReplaceOnChanges": true
                },
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n",
                    "willReplaceOnChanges": true
                },
                "node": {
                    "type": "string",
                    "description": "The name of the node being added to, or\nreferenced in the catalog.\n",
                    "willReplaceOnChanges": true
                },
                "services": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/CatalogEntryService:CatalogEntryService"
                    },
                    "description": "A service to optionally associated with\nthe node. Supported values are documented below.\n",
                    "willReplaceOnChanges": true
                },
                "token": {
                    "type": "string",
                    "description": "ACL token.\n",
                    "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                    "secret": true
                }
            },
            "requiredInputs": [
                "address",
                "node"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CatalogEntry resources.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The address of the node being added to,\nor referenced in the catalog.\n",
                        "willReplaceOnChanges": true
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n",
                        "willReplaceOnChanges": true
                    },
                    "node": {
                        "type": "string",
                        "description": "The name of the node being added to, or\nreferenced in the catalog.\n",
                        "willReplaceOnChanges": true
                    },
                    "services": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/CatalogEntryService:CatalogEntryService"
                        },
                        "description": "A service to optionally associated with\nthe node. Supported values are documented below.\n",
                        "willReplaceOnChanges": true
                    },
                    "token": {
                        "type": "string",
                        "description": "ACL token.\n",
                        "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "consul:index/certificateAuthority:CertificateAuthority": {
            "description": "The `consul.CertificateAuthority` resource can be used to manage the configuration of the Certificate Authority used by [Consul Connect](https://www.consul.io/docs/connect/ca).\n\n\u003e **Note:** The keys in the `config` argument must be using Camel case.\n\n## Import\n\n```sh\n$ pulumi import consul:index/certificateAuthority:CertificateAuthority connect connect-ca\n```\n\n",
            "properties": {
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "deprecationMessage": "The config attribute is deprecated, please use config_json instead."
                },
                "configJson": {
                    "type": "string"
                },
                "connectProvider": {
                    "type": "string",
                    "description": "Specifies the CA provider type to use.\n"
                }
            },
            "required": [
                "connectProvider"
            ],
            "inputProperties": {
                "config": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "deprecationMessage": "The config attribute is deprecated, please use config_json instead.",
                    "willReplaceOnChanges": true
                },
                "configJson": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "connectProvider": {
                    "type": "string",
                    "description": "Specifies the CA provider type to use.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "connectProvider"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering CertificateAuthority resources.\n",
                "properties": {
                    "config": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "The config attribute is deprecated, please use config_json instead.",
                        "willReplaceOnChanges": true
                    },
                    "configJson": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "connectProvider": {
                        "type": "string",
                        "description": "Specifies the CA provider type to use.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "consul:index/configEntry:ConfigEntry": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst proxyDefaults = new consul.ConfigEntry(\"proxy_defaults\", {\n    kind: \"proxy-defaults\",\n    name: \"global\",\n    configJson: JSON.stringify({\n        Config: {\n            local_connect_timeout_ms: 1000,\n            handshake_timeout_ms: 10000,\n        },\n    }),\n});\nconst web = new consul.ConfigEntry(\"web\", {\n    name: \"web\",\n    kind: \"service-defaults\",\n    configJson: JSON.stringify({\n        Protocol: \"http\",\n    }),\n});\nconst admin = new consul.ConfigEntry(\"admin\", {\n    name: \"admin\",\n    kind: \"service-defaults\",\n    configJson: JSON.stringify({\n        Protocol: \"http\",\n    }),\n});\nconst serviceResolver = new consul.ConfigEntry(\"service_resolver\", {\n    kind: \"service-resolver\",\n    name: web.name,\n    configJson: JSON.stringify({\n        DefaultSubset: \"v1\",\n        Subsets: {\n            v1: {\n                Filter: \"Service.Meta.version == v1\",\n            },\n            v2: {\n                Filter: \"Service.Meta.version == v2\",\n            },\n        },\n    }),\n});\nconst serviceSplitter = new consul.ConfigEntry(\"service_splitter\", {\n    kind: \"service-splitter\",\n    name: serviceResolver.name,\n    configJson: JSON.stringify({\n        Splits: [\n            {\n                Weight: 90,\n                ServiceSubset: \"v1\",\n            },\n            {\n                Weight: 10,\n                ServiceSubset: \"v2\",\n            },\n        ],\n    }),\n});\nconst serviceRouter = new consul.ConfigEntry(\"service_router\", {\n    kind: \"service-router\",\n    name: \"web\",\n    configJson: JSON.stringify({\n        Routes: [{\n            Match: {\n                HTTP: {\n                    PathPrefix: \"/admin\",\n                },\n            },\n            Destination: {\n                Service: \"admin\",\n            },\n        }],\n    }),\n});\nconst ingressGateway = new consul.ConfigEntry(\"ingress_gateway\", {\n    name: \"us-east-ingress\",\n    kind: \"ingress-gateway\",\n    configJson: JSON.stringify({\n        TLS: {\n            Enabled: true,\n        },\n        Listeners: [{\n            Port: 8000,\n            Protocol: \"http\",\n            Services: [{\n                Name: \"*\",\n            }],\n        }],\n    }),\n});\nconst terminatingGateway = new consul.ConfigEntry(\"terminating_gateway\", {\n    name: \"us-west-gateway\",\n    kind: \"terminating-gateway\",\n    configJson: JSON.stringify({\n        Services: [{\n            Name: \"billing\",\n        }],\n    }),\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_consul as consul\n\nproxy_defaults = consul.ConfigEntry(\"proxy_defaults\",\n    kind=\"proxy-defaults\",\n    name=\"global\",\n    config_json=json.dumps({\n        \"Config\": {\n            \"local_connect_timeout_ms\": 1000,\n            \"handshake_timeout_ms\": 10000,\n        },\n    }))\nweb = consul.ConfigEntry(\"web\",\n    name=\"web\",\n    kind=\"service-defaults\",\n    config_json=json.dumps({\n        \"Protocol\": \"http\",\n    }))\nadmin = consul.ConfigEntry(\"admin\",\n    name=\"admin\",\n    kind=\"service-defaults\",\n    config_json=json.dumps({\n        \"Protocol\": \"http\",\n    }))\nservice_resolver = consul.ConfigEntry(\"service_resolver\",\n    kind=\"service-resolver\",\n    name=web.name,\n    config_json=json.dumps({\n        \"DefaultSubset\": \"v1\",\n        \"Subsets\": {\n            \"v1\": {\n                \"Filter\": \"Service.Meta.version == v1\",\n            },\n            \"v2\": {\n                \"Filter\": \"Service.Meta.version == v2\",\n            },\n        },\n    }))\nservice_splitter = consul.ConfigEntry(\"service_splitter\",\n    kind=\"service-splitter\",\n    name=service_resolver.name,\n    config_json=json.dumps({\n        \"Splits\": [\n            {\n                \"Weight\": 90,\n                \"ServiceSubset\": \"v1\",\n            },\n            {\n                \"Weight\": 10,\n                \"ServiceSubset\": \"v2\",\n            },\n        ],\n    }))\nservice_router = consul.ConfigEntry(\"service_router\",\n    kind=\"service-router\",\n    name=\"web\",\n    config_json=json.dumps({\n        \"Routes\": [{\n            \"Match\": {\n                \"HTTP\": {\n                    \"PathPrefix\": \"/admin\",\n                },\n            },\n            \"Destination\": {\n                \"Service\": \"admin\",\n            },\n        }],\n    }))\ningress_gateway = consul.ConfigEntry(\"ingress_gateway\",\n    name=\"us-east-ingress\",\n    kind=\"ingress-gateway\",\n    config_json=json.dumps({\n        \"TLS\": {\n            \"Enabled\": True,\n        },\n        \"Listeners\": [{\n            \"Port\": 8000,\n            \"Protocol\": \"http\",\n            \"Services\": [{\n                \"Name\": \"*\",\n            }],\n        }],\n    }))\nterminating_gateway = consul.ConfigEntry(\"terminating_gateway\",\n    name=\"us-west-gateway\",\n    kind=\"terminating-gateway\",\n    config_json=json.dumps({\n        \"Services\": [{\n            \"Name\": \"billing\",\n        }],\n    }))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var proxyDefaults = new Consul.ConfigEntry(\"proxy_defaults\", new()\n    {\n        Kind = \"proxy-defaults\",\n        Name = \"global\",\n        ConfigJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"Config\"] = new Dictionary\u003cstring, object?\u003e\n            {\n                [\"local_connect_timeout_ms\"] = 1000,\n                [\"handshake_timeout_ms\"] = 10000,\n            },\n        }),\n    });\n\n    var web = new Consul.ConfigEntry(\"web\", new()\n    {\n        Name = \"web\",\n        Kind = \"service-defaults\",\n        ConfigJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"Protocol\"] = \"http\",\n        }),\n    });\n\n    var admin = new Consul.ConfigEntry(\"admin\", new()\n    {\n        Name = \"admin\",\n        Kind = \"service-defaults\",\n        ConfigJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"Protocol\"] = \"http\",\n        }),\n    });\n\n    var serviceResolver = new Consul.ConfigEntry(\"service_resolver\", new()\n    {\n        Kind = \"service-resolver\",\n        Name = web.Name,\n        ConfigJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"DefaultSubset\"] = \"v1\",\n            [\"Subsets\"] = new Dictionary\u003cstring, object?\u003e\n            {\n                [\"v1\"] = new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"Filter\"] = \"Service.Meta.version == v1\",\n                },\n                [\"v2\"] = new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"Filter\"] = \"Service.Meta.version == v2\",\n                },\n            },\n        }),\n    });\n\n    var serviceSplitter = new Consul.ConfigEntry(\"service_splitter\", new()\n    {\n        Kind = \"service-splitter\",\n        Name = serviceResolver.Name,\n        ConfigJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"Splits\"] = new[]\n            {\n                new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"Weight\"] = 90,\n                    [\"ServiceSubset\"] = \"v1\",\n                },\n                new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"Weight\"] = 10,\n                    [\"ServiceSubset\"] = \"v2\",\n                },\n            },\n        }),\n    });\n\n    var serviceRouter = new Consul.ConfigEntry(\"service_router\", new()\n    {\n        Kind = \"service-router\",\n        Name = \"web\",\n        ConfigJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"Routes\"] = new[]\n            {\n                new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"Match\"] = new Dictionary\u003cstring, object?\u003e\n                    {\n                        [\"HTTP\"] = new Dictionary\u003cstring, object?\u003e\n                        {\n                            [\"PathPrefix\"] = \"/admin\",\n                        },\n                    },\n                    [\"Destination\"] = new Dictionary\u003cstring, object?\u003e\n                    {\n                        [\"Service\"] = \"admin\",\n                    },\n                },\n            },\n        }),\n    });\n\n    var ingressGateway = new Consul.ConfigEntry(\"ingress_gateway\", new()\n    {\n        Name = \"us-east-ingress\",\n        Kind = \"ingress-gateway\",\n        ConfigJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"TLS\"] = new Dictionary\u003cstring, object?\u003e\n            {\n                [\"Enabled\"] = true,\n            },\n            [\"Listeners\"] = new[]\n            {\n                new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"Port\"] = 8000,\n                    [\"Protocol\"] = \"http\",\n                    [\"Services\"] = new[]\n                    {\n                        new Dictionary\u003cstring, object?\u003e\n                        {\n                            [\"Name\"] = \"*\",\n                        },\n                    },\n                },\n            },\n        }),\n    });\n\n    var terminatingGateway = new Consul.ConfigEntry(\"terminating_gateway\", new()\n    {\n        Name = \"us-west-gateway\",\n        Kind = \"terminating-gateway\",\n        ConfigJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"Services\"] = new[]\n            {\n                new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"Name\"] = \"billing\",\n                },\n            },\n        }),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"Config\": map[string]interface{}{\n\t\t\t\t\"local_connect_timeout_ms\": 1000,\n\t\t\t\t\"handshake_timeout_ms\":     10000,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\t_, err = consul.NewConfigEntry(ctx, \"proxy_defaults\", \u0026consul.ConfigEntryArgs{\n\t\t\tKind:       pulumi.String(\"proxy-defaults\"),\n\t\t\tName:       pulumi.String(\"global\"),\n\t\t\tConfigJson: pulumi.String(json0),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON1, err := json.Marshal(map[string]interface{}{\n\t\t\t\"Protocol\": \"http\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson1 := string(tmpJSON1)\n\t\tweb, err := consul.NewConfigEntry(ctx, \"web\", \u0026consul.ConfigEntryArgs{\n\t\t\tName:       pulumi.String(\"web\"),\n\t\t\tKind:       pulumi.String(\"service-defaults\"),\n\t\t\tConfigJson: pulumi.String(json1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON2, err := json.Marshal(map[string]interface{}{\n\t\t\t\"Protocol\": \"http\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson2 := string(tmpJSON2)\n\t\t_, err = consul.NewConfigEntry(ctx, \"admin\", \u0026consul.ConfigEntryArgs{\n\t\t\tName:       pulumi.String(\"admin\"),\n\t\t\tKind:       pulumi.String(\"service-defaults\"),\n\t\t\tConfigJson: pulumi.String(json2),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON3, err := json.Marshal(map[string]interface{}{\n\t\t\t\"DefaultSubset\": \"v1\",\n\t\t\t\"Subsets\": map[string]interface{}{\n\t\t\t\t\"v1\": map[string]interface{}{\n\t\t\t\t\t\"Filter\": \"Service.Meta.version == v1\",\n\t\t\t\t},\n\t\t\t\t\"v2\": map[string]interface{}{\n\t\t\t\t\t\"Filter\": \"Service.Meta.version == v2\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson3 := string(tmpJSON3)\n\t\tserviceResolver, err := consul.NewConfigEntry(ctx, \"service_resolver\", \u0026consul.ConfigEntryArgs{\n\t\t\tKind:       pulumi.String(\"service-resolver\"),\n\t\t\tName:       web.Name,\n\t\t\tConfigJson: pulumi.String(json3),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON4, err := json.Marshal(map[string]interface{}{\n\t\t\t\"Splits\": []interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"Weight\":        90,\n\t\t\t\t\t\"ServiceSubset\": \"v1\",\n\t\t\t\t},\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"Weight\":        10,\n\t\t\t\t\t\"ServiceSubset\": \"v2\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson4 := string(tmpJSON4)\n\t\t_, err = consul.NewConfigEntry(ctx, \"service_splitter\", \u0026consul.ConfigEntryArgs{\n\t\t\tKind:       pulumi.String(\"service-splitter\"),\n\t\t\tName:       serviceResolver.Name,\n\t\t\tConfigJson: pulumi.String(json4),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON5, err := json.Marshal(map[string]interface{}{\n\t\t\t\"Routes\": []map[string]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"Match\": map[string]interface{}{\n\t\t\t\t\t\t\"HTTP\": map[string]interface{}{\n\t\t\t\t\t\t\t\"PathPrefix\": \"/admin\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"Destination\": map[string]interface{}{\n\t\t\t\t\t\t\"Service\": \"admin\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson5 := string(tmpJSON5)\n\t\t_, err = consul.NewConfigEntry(ctx, \"service_router\", \u0026consul.ConfigEntryArgs{\n\t\t\tKind:       pulumi.String(\"service-router\"),\n\t\t\tName:       pulumi.String(\"web\"),\n\t\t\tConfigJson: pulumi.String(json5),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON6, err := json.Marshal(map[string]interface{}{\n\t\t\t\"TLS\": map[string]interface{}{\n\t\t\t\t\"Enabled\": true,\n\t\t\t},\n\t\t\t\"Listeners\": []map[string]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"Port\":     8000,\n\t\t\t\t\t\"Protocol\": \"http\",\n\t\t\t\t\t\"Services\": []map[string]interface{}{\n\t\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\t\"Name\": \"*\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson6 := string(tmpJSON6)\n\t\t_, err = consul.NewConfigEntry(ctx, \"ingress_gateway\", \u0026consul.ConfigEntryArgs{\n\t\t\tName:       pulumi.String(\"us-east-ingress\"),\n\t\t\tKind:       pulumi.String(\"ingress-gateway\"),\n\t\t\tConfigJson: pulumi.String(json6),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON7, err := json.Marshal(map[string]interface{}{\n\t\t\t\"Services\": []map[string]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"Name\": \"billing\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson7 := string(tmpJSON7)\n\t\t_, err = consul.NewConfigEntry(ctx, \"terminating_gateway\", \u0026consul.ConfigEntryArgs{\n\t\t\tName:       pulumi.String(\"us-west-gateway\"),\n\t\t\tKind:       pulumi.String(\"terminating-gateway\"),\n\t\t\tConfigJson: pulumi.String(json7),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConfigEntry;\nimport com.pulumi.consul.ConfigEntryArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var proxyDefaults = new ConfigEntry(\"proxyDefaults\", ConfigEntryArgs.builder()\n            .kind(\"proxy-defaults\")\n            .name(\"global\")\n            .configJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"Config\", jsonObject(\n                        jsonProperty(\"local_connect_timeout_ms\", 1000),\n                        jsonProperty(\"handshake_timeout_ms\", 10000)\n                    ))\n                )))\n            .build());\n\n        var web = new ConfigEntry(\"web\", ConfigEntryArgs.builder()\n            .name(\"web\")\n            .kind(\"service-defaults\")\n            .configJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"Protocol\", \"http\")\n                )))\n            .build());\n\n        var admin = new ConfigEntry(\"admin\", ConfigEntryArgs.builder()\n            .name(\"admin\")\n            .kind(\"service-defaults\")\n            .configJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"Protocol\", \"http\")\n                )))\n            .build());\n\n        var serviceResolver = new ConfigEntry(\"serviceResolver\", ConfigEntryArgs.builder()\n            .kind(\"service-resolver\")\n            .name(web.name())\n            .configJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"DefaultSubset\", \"v1\"),\n                    jsonProperty(\"Subsets\", jsonObject(\n                        jsonProperty(\"v1\", jsonObject(\n                            jsonProperty(\"Filter\", \"Service.Meta.version == v1\")\n                        )),\n                        jsonProperty(\"v2\", jsonObject(\n                            jsonProperty(\"Filter\", \"Service.Meta.version == v2\")\n                        ))\n                    ))\n                )))\n            .build());\n\n        var serviceSplitter = new ConfigEntry(\"serviceSplitter\", ConfigEntryArgs.builder()\n            .kind(\"service-splitter\")\n            .name(serviceResolver.name())\n            .configJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"Splits\", jsonArray(\n                        jsonObject(\n                            jsonProperty(\"Weight\", 90),\n                            jsonProperty(\"ServiceSubset\", \"v1\")\n                        ), \n                        jsonObject(\n                            jsonProperty(\"Weight\", 10),\n                            jsonProperty(\"ServiceSubset\", \"v2\")\n                        )\n                    ))\n                )))\n            .build());\n\n        var serviceRouter = new ConfigEntry(\"serviceRouter\", ConfigEntryArgs.builder()\n            .kind(\"service-router\")\n            .name(\"web\")\n            .configJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"Routes\", jsonArray(jsonObject(\n                        jsonProperty(\"Match\", jsonObject(\n                            jsonProperty(\"HTTP\", jsonObject(\n                                jsonProperty(\"PathPrefix\", \"/admin\")\n                            ))\n                        )),\n                        jsonProperty(\"Destination\", jsonObject(\n                            jsonProperty(\"Service\", \"admin\")\n                        ))\n                    )))\n                )))\n            .build());\n\n        var ingressGateway = new ConfigEntry(\"ingressGateway\", ConfigEntryArgs.builder()\n            .name(\"us-east-ingress\")\n            .kind(\"ingress-gateway\")\n            .configJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"TLS\", jsonObject(\n                        jsonProperty(\"Enabled\", true)\n                    )),\n                    jsonProperty(\"Listeners\", jsonArray(jsonObject(\n                        jsonProperty(\"Port\", 8000),\n                        jsonProperty(\"Protocol\", \"http\"),\n                        jsonProperty(\"Services\", jsonArray(jsonObject(\n                            jsonProperty(\"Name\", \"*\")\n                        )))\n                    )))\n                )))\n            .build());\n\n        var terminatingGateway = new ConfigEntry(\"terminatingGateway\", ConfigEntryArgs.builder()\n            .name(\"us-west-gateway\")\n            .kind(\"terminating-gateway\")\n            .configJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"Services\", jsonArray(jsonObject(\n                        jsonProperty(\"Name\", \"billing\")\n                    )))\n                )))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  proxyDefaults:\n    type: consul:ConfigEntry\n    name: proxy_defaults\n    properties:\n      kind: proxy-defaults\n      name: global\n      configJson:\n        fn::toJSON:\n          Config:\n            local_connect_timeout_ms: 1000\n            handshake_timeout_ms: 10000\n  web:\n    type: consul:ConfigEntry\n    properties:\n      name: web\n      kind: service-defaults\n      configJson:\n        fn::toJSON:\n          Protocol: http\n  admin:\n    type: consul:ConfigEntry\n    properties:\n      name: admin\n      kind: service-defaults\n      configJson:\n        fn::toJSON:\n          Protocol: http\n  serviceResolver:\n    type: consul:ConfigEntry\n    name: service_resolver\n    properties:\n      kind: service-resolver\n      name: ${web.name}\n      configJson:\n        fn::toJSON:\n          DefaultSubset: v1\n          Subsets:\n            v1:\n              Filter: Service.Meta.version == v1\n            v2:\n              Filter: Service.Meta.version == v2\n  serviceSplitter:\n    type: consul:ConfigEntry\n    name: service_splitter\n    properties:\n      kind: service-splitter\n      name: ${serviceResolver.name}\n      configJson:\n        fn::toJSON:\n          Splits:\n            - Weight: 90\n              ServiceSubset: v1\n            - Weight: 10\n              ServiceSubset: v2\n  serviceRouter:\n    type: consul:ConfigEntry\n    name: service_router\n    properties:\n      kind: service-router\n      name: web\n      configJson:\n        fn::toJSON:\n          Routes:\n            - Match:\n                HTTP:\n                  PathPrefix: /admin\n              Destination:\n                Service: admin\n  ingressGateway:\n    type: consul:ConfigEntry\n    name: ingress_gateway\n    properties:\n      name: us-east-ingress\n      kind: ingress-gateway\n      configJson:\n        fn::toJSON:\n          TLS:\n            Enabled: true\n          Listeners:\n            - Port: 8000\n              Protocol: http\n              Services:\n                - Name: '*'\n  terminatingGateway:\n    type: consul:ConfigEntry\n    name: terminating_gateway\n    properties:\n      name: us-west-gateway\n      kind: terminating-gateway\n      configJson:\n        fn::toJSON:\n          Services:\n            - Name: billing\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### `service-intentions` config entry\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst serviceIntentions = new consul.ConfigEntry(\"service_intentions\", {\n    name: \"api-service\",\n    kind: \"service-intentions\",\n    configJson: JSON.stringify({\n        Sources: [\n            {\n                Action: \"allow\",\n                Name: \"frontend-webapp\",\n                Precedence: 9,\n                Type: \"consul\",\n            },\n            {\n                Action: \"allow\",\n                Name: \"nightly-cronjob\",\n                Precedence: 9,\n                Type: \"consul\",\n            },\n        ],\n    }),\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_consul as consul\n\nservice_intentions = consul.ConfigEntry(\"service_intentions\",\n    name=\"api-service\",\n    kind=\"service-intentions\",\n    config_json=json.dumps({\n        \"Sources\": [\n            {\n                \"Action\": \"allow\",\n                \"Name\": \"frontend-webapp\",\n                \"Precedence\": 9,\n                \"Type\": \"consul\",\n            },\n            {\n                \"Action\": \"allow\",\n                \"Name\": \"nightly-cronjob\",\n                \"Precedence\": 9,\n                \"Type\": \"consul\",\n            },\n        ],\n    }))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var serviceIntentions = new Consul.ConfigEntry(\"service_intentions\", new()\n    {\n        Name = \"api-service\",\n        Kind = \"service-intentions\",\n        ConfigJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"Sources\"] = new[]\n            {\n                new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"Action\"] = \"allow\",\n                    [\"Name\"] = \"frontend-webapp\",\n                    [\"Precedence\"] = 9,\n                    [\"Type\"] = \"consul\",\n                },\n                new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"Action\"] = \"allow\",\n                    [\"Name\"] = \"nightly-cronjob\",\n                    [\"Precedence\"] = 9,\n                    [\"Type\"] = \"consul\",\n                },\n            },\n        }),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"Sources\": []map[string]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"Action\":     \"allow\",\n\t\t\t\t\t\"Name\":       \"frontend-webapp\",\n\t\t\t\t\t\"Precedence\": 9,\n\t\t\t\t\t\"Type\":       \"consul\",\n\t\t\t\t},\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"Action\":     \"allow\",\n\t\t\t\t\t\"Name\":       \"nightly-cronjob\",\n\t\t\t\t\t\"Precedence\": 9,\n\t\t\t\t\t\"Type\":       \"consul\",\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\t_, err = consul.NewConfigEntry(ctx, \"service_intentions\", \u0026consul.ConfigEntryArgs{\n\t\t\tName:       pulumi.String(\"api-service\"),\n\t\t\tKind:       pulumi.String(\"service-intentions\"),\n\t\t\tConfigJson: pulumi.String(json0),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConfigEntry;\nimport com.pulumi.consul.ConfigEntryArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var serviceIntentions = new ConfigEntry(\"serviceIntentions\", ConfigEntryArgs.builder()\n            .name(\"api-service\")\n            .kind(\"service-intentions\")\n            .configJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"Sources\", jsonArray(\n                        jsonObject(\n                            jsonProperty(\"Action\", \"allow\"),\n                            jsonProperty(\"Name\", \"frontend-webapp\"),\n                            jsonProperty(\"Precedence\", 9),\n                            jsonProperty(\"Type\", \"consul\")\n                        ), \n                        jsonObject(\n                            jsonProperty(\"Action\", \"allow\"),\n                            jsonProperty(\"Name\", \"nightly-cronjob\"),\n                            jsonProperty(\"Precedence\", 9),\n                            jsonProperty(\"Type\", \"consul\")\n                        )\n                    ))\n                )))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  serviceIntentions:\n    type: consul:ConfigEntry\n    name: service_intentions\n    properties:\n      name: api-service\n      kind: service-intentions\n      configJson:\n        fn::toJSON:\n          Sources:\n            - Action: allow\n              Name: frontend-webapp\n              Precedence: 9\n              Type: consul\n            - Action: allow\n              Name: nightly-cronjob\n              Precedence: 9\n              Type: consul\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst sd = new consul.ConfigEntry(\"sd\", {\n    name: \"fort-knox\",\n    kind: \"service-defaults\",\n    configJson: JSON.stringify({\n        Protocol: \"http\",\n    }),\n});\nconst jwtProvider = new consul.ConfigEntry(\"jwt_provider\", {\n    name: \"test-provider\",\n    kind: \"jwt-provider\",\n    configJson: JSON.stringify({\n        Issuer: \"test-issuer\",\n        JSONWebKeySet: {\n            Remote: {\n                URI: \"https://127.0.0.1:9091\",\n                FetchAsynchronously: true,\n            },\n        },\n        Forwarding: {\n            HeaderName: \"test-token\",\n        },\n    }),\n});\nconst serviceIntentions = new consul.ConfigEntry(\"service_intentions\", {\n    name: sd.name,\n    kind: \"service-intentions\",\n    configJson: pulumi.jsonStringify({\n        Sources: [\n            {\n                Name: \"contractor-webapp\",\n                Permissions: [{\n                    Action: \"allow\",\n                    HTTP: {\n                        Methods: [\n                            \"GET\",\n                            \"HEAD\",\n                        ],\n                        PathExact: \"/healtz\",\n                    },\n                    JWT: {\n                        Providers: [{\n                            Name: jwtProvider.name,\n                        }],\n                    },\n                }],\n                Precedence: 9,\n                Type: \"consul\",\n            },\n            {\n                Name: \"admin-dashboard-webapp\",\n                Permissions: [\n                    {\n                        Action: \"deny\",\n                        HTTP: {\n                            PathPrefix: \"/debugz\",\n                        },\n                    },\n                    {\n                        Action: \"allow\",\n                        HTTP: {\n                            PathPrefix: \"/\",\n                        },\n                    },\n                ],\n                Precedence: 9,\n                Type: \"consul\",\n            },\n        ],\n    }),\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_consul as consul\n\nsd = consul.ConfigEntry(\"sd\",\n    name=\"fort-knox\",\n    kind=\"service-defaults\",\n    config_json=json.dumps({\n        \"Protocol\": \"http\",\n    }))\njwt_provider = consul.ConfigEntry(\"jwt_provider\",\n    name=\"test-provider\",\n    kind=\"jwt-provider\",\n    config_json=json.dumps({\n        \"Issuer\": \"test-issuer\",\n        \"JSONWebKeySet\": {\n            \"Remote\": {\n                \"URI\": \"https://127.0.0.1:9091\",\n                \"FetchAsynchronously\": True,\n            },\n        },\n        \"Forwarding\": {\n            \"HeaderName\": \"test-token\",\n        },\n    }))\nservice_intentions = consul.ConfigEntry(\"service_intentions\",\n    name=sd.name,\n    kind=\"service-intentions\",\n    config_json=pulumi.Output.json_dumps({\n        \"Sources\": [\n            {\n                \"Name\": \"contractor-webapp\",\n                \"Permissions\": [{\n                    \"Action\": \"allow\",\n                    \"HTTP\": {\n                        \"Methods\": [\n                            \"GET\",\n                            \"HEAD\",\n                        ],\n                        \"PathExact\": \"/healtz\",\n                    },\n                    \"JWT\": {\n                        \"Providers\": [{\n                            \"Name\": jwt_provider.name,\n                        }],\n                    },\n                }],\n                \"Precedence\": 9,\n                \"Type\": \"consul\",\n            },\n            {\n                \"Name\": \"admin-dashboard-webapp\",\n                \"Permissions\": [\n                    {\n                        \"Action\": \"deny\",\n                        \"HTTP\": {\n                            \"PathPrefix\": \"/debugz\",\n                        },\n                    },\n                    {\n                        \"Action\": \"allow\",\n                        \"HTTP\": {\n                            \"PathPrefix\": \"/\",\n                        },\n                    },\n                ],\n                \"Precedence\": 9,\n                \"Type\": \"consul\",\n            },\n        ],\n    }))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var sd = new Consul.ConfigEntry(\"sd\", new()\n    {\n        Name = \"fort-knox\",\n        Kind = \"service-defaults\",\n        ConfigJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"Protocol\"] = \"http\",\n        }),\n    });\n\n    var jwtProvider = new Consul.ConfigEntry(\"jwt_provider\", new()\n    {\n        Name = \"test-provider\",\n        Kind = \"jwt-provider\",\n        ConfigJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"Issuer\"] = \"test-issuer\",\n            [\"JSONWebKeySet\"] = new Dictionary\u003cstring, object?\u003e\n            {\n                [\"Remote\"] = new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"URI\"] = \"https://127.0.0.1:9091\",\n                    [\"FetchAsynchronously\"] = true,\n                },\n            },\n            [\"Forwarding\"] = new Dictionary\u003cstring, object?\u003e\n            {\n                [\"HeaderName\"] = \"test-token\",\n            },\n        }),\n    });\n\n    var serviceIntentions = new Consul.ConfigEntry(\"service_intentions\", new()\n    {\n        Name = sd.Name,\n        Kind = \"service-intentions\",\n        ConfigJson = Output.JsonSerialize(Output.Create(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"Sources\"] = new[]\n            {\n                new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"Name\"] = \"contractor-webapp\",\n                    [\"Permissions\"] = new[]\n                    {\n                        new Dictionary\u003cstring, object?\u003e\n                        {\n                            [\"Action\"] = \"allow\",\n                            [\"HTTP\"] = new Dictionary\u003cstring, object?\u003e\n                            {\n                                [\"Methods\"] = new[]\n                                {\n                                    \"GET\",\n                                    \"HEAD\",\n                                },\n                                [\"PathExact\"] = \"/healtz\",\n                            },\n                            [\"JWT\"] = new Dictionary\u003cstring, object?\u003e\n                            {\n                                [\"Providers\"] = new[]\n                                {\n                                    new Dictionary\u003cstring, object?\u003e\n                                    {\n                                        [\"Name\"] = jwtProvider.Name,\n                                    },\n                                },\n                            },\n                        },\n                    },\n                    [\"Precedence\"] = 9,\n                    [\"Type\"] = \"consul\",\n                },\n                new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"Name\"] = \"admin-dashboard-webapp\",\n                    [\"Permissions\"] = new[]\n                    {\n                        new Dictionary\u003cstring, object?\u003e\n                        {\n                            [\"Action\"] = \"deny\",\n                            [\"HTTP\"] = new Dictionary\u003cstring, object?\u003e\n                            {\n                                [\"PathPrefix\"] = \"/debugz\",\n                            },\n                        },\n                        new Dictionary\u003cstring, object?\u003e\n                        {\n                            [\"Action\"] = \"allow\",\n                            [\"HTTP\"] = new Dictionary\u003cstring, object?\u003e\n                            {\n                                [\"PathPrefix\"] = \"/\",\n                            },\n                        },\n                    },\n                    [\"Precedence\"] = 9,\n                    [\"Type\"] = \"consul\",\n                },\n            },\n        })),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"Protocol\": \"http\",\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\tsd, err := consul.NewConfigEntry(ctx, \"sd\", \u0026consul.ConfigEntryArgs{\n\t\t\tName:       pulumi.String(\"fort-knox\"),\n\t\t\tKind:       pulumi.String(\"service-defaults\"),\n\t\t\tConfigJson: pulumi.String(json0),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttmpJSON1, err := json.Marshal(map[string]interface{}{\n\t\t\t\"Issuer\": \"test-issuer\",\n\t\t\t\"JSONWebKeySet\": map[string]interface{}{\n\t\t\t\t\"Remote\": map[string]interface{}{\n\t\t\t\t\t\"URI\":                 \"https://127.0.0.1:9091\",\n\t\t\t\t\t\"FetchAsynchronously\": true,\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"Forwarding\": map[string]interface{}{\n\t\t\t\t\"HeaderName\": \"test-token\",\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson1 := string(tmpJSON1)\n\t\tjwtProvider, err := consul.NewConfigEntry(ctx, \"jwt_provider\", \u0026consul.ConfigEntryArgs{\n\t\t\tName:       pulumi.String(\"test-provider\"),\n\t\t\tKind:       pulumi.String(\"jwt-provider\"),\n\t\t\tConfigJson: pulumi.String(json1),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = consul.NewConfigEntry(ctx, \"service_intentions\", \u0026consul.ConfigEntryArgs{\n\t\t\tName: sd.Name,\n\t\t\tKind: pulumi.String(\"service-intentions\"),\n\t\t\tConfigJson: jwtProvider.Name.ApplyT(func(name string) (pulumi.String, error) {\n\t\t\t\tvar _zero pulumi.String\n\t\t\t\ttmpJSON2, err := json.Marshal(map[string]interface{}{\n\t\t\t\t\t\"Sources\": []interface{}{\n\t\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\t\"Name\": \"contractor-webapp\",\n\t\t\t\t\t\t\t\"Permissions\": []map[string]interface{}{\n\t\t\t\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\t\t\t\"Action\": \"allow\",\n\t\t\t\t\t\t\t\t\t\"HTTP\": map[string]interface{}{\n\t\t\t\t\t\t\t\t\t\t\"Methods\": []string{\n\t\t\t\t\t\t\t\t\t\t\t\"GET\",\n\t\t\t\t\t\t\t\t\t\t\t\"HEAD\",\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\"PathExact\": \"/healtz\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"JWT\": map[string]interface{}{\n\t\t\t\t\t\t\t\t\t\t\"Providers\": []map[string]interface{}{\n\t\t\t\t\t\t\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\t\t\t\t\t\t\"Name\": name,\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"Precedence\": 9,\n\t\t\t\t\t\t\t\"Type\":       \"consul\",\n\t\t\t\t\t\t},\n\t\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\t\"Name\": \"admin-dashboard-webapp\",\n\t\t\t\t\t\t\t\"Permissions\": []map[string]interface{}{\n\t\t\t\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\t\t\t\"Action\": \"deny\",\n\t\t\t\t\t\t\t\t\t\"HTTP\": map[string]interface{}{\n\t\t\t\t\t\t\t\t\t\t\"PathPrefix\": \"/debugz\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\t\t\t\"Action\": \"allow\",\n\t\t\t\t\t\t\t\t\t\"HTTP\": map[string]interface{}{\n\t\t\t\t\t\t\t\t\t\t\"PathPrefix\": \"/\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"Precedence\": 9,\n\t\t\t\t\t\t\t\"Type\":       \"consul\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn _zero, err\n\t\t\t\t}\n\t\t\t\tjson2 := string(tmpJSON2)\n\t\t\t\treturn pulumi.String(json2), nil\n\t\t\t}).(pulumi.StringOutput),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConfigEntry;\nimport com.pulumi.consul.ConfigEntryArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var sd = new ConfigEntry(\"sd\", ConfigEntryArgs.builder()\n            .name(\"fort-knox\")\n            .kind(\"service-defaults\")\n            .configJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"Protocol\", \"http\")\n                )))\n            .build());\n\n        var jwtProvider = new ConfigEntry(\"jwtProvider\", ConfigEntryArgs.builder()\n            .name(\"test-provider\")\n            .kind(\"jwt-provider\")\n            .configJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"Issuer\", \"test-issuer\"),\n                    jsonProperty(\"JSONWebKeySet\", jsonObject(\n                        jsonProperty(\"Remote\", jsonObject(\n                            jsonProperty(\"URI\", \"https://127.0.0.1:9091\"),\n                            jsonProperty(\"FetchAsynchronously\", true)\n                        ))\n                    )),\n                    jsonProperty(\"Forwarding\", jsonObject(\n                        jsonProperty(\"HeaderName\", \"test-token\")\n                    ))\n                )))\n            .build());\n\n        var serviceIntentions = new ConfigEntry(\"serviceIntentions\", ConfigEntryArgs.builder()\n            .name(sd.name())\n            .kind(\"service-intentions\")\n            .configJson(jwtProvider.name().applyValue(_name -\u003e serializeJson(\n                jsonObject(\n                    jsonProperty(\"Sources\", jsonArray(\n                        jsonObject(\n                            jsonProperty(\"Name\", \"contractor-webapp\"),\n                            jsonProperty(\"Permissions\", jsonArray(jsonObject(\n                                jsonProperty(\"Action\", \"allow\"),\n                                jsonProperty(\"HTTP\", jsonObject(\n                                    jsonProperty(\"Methods\", jsonArray(\n                                        \"GET\", \n                                        \"HEAD\"\n                                    )),\n                                    jsonProperty(\"PathExact\", \"/healtz\")\n                                )),\n                                jsonProperty(\"JWT\", jsonObject(\n                                    jsonProperty(\"Providers\", jsonArray(jsonObject(\n                                        jsonProperty(\"Name\", _name)\n                                    )))\n                                ))\n                            ))),\n                            jsonProperty(\"Precedence\", 9),\n                            jsonProperty(\"Type\", \"consul\")\n                        ), \n                        jsonObject(\n                            jsonProperty(\"Name\", \"admin-dashboard-webapp\"),\n                            jsonProperty(\"Permissions\", jsonArray(\n                                jsonObject(\n                                    jsonProperty(\"Action\", \"deny\"),\n                                    jsonProperty(\"HTTP\", jsonObject(\n                                        jsonProperty(\"PathPrefix\", \"/debugz\")\n                                    ))\n                                ), \n                                jsonObject(\n                                    jsonProperty(\"Action\", \"allow\"),\n                                    jsonProperty(\"HTTP\", jsonObject(\n                                        jsonProperty(\"PathPrefix\", \"/\")\n                                    ))\n                                )\n                            )),\n                            jsonProperty(\"Precedence\", 9),\n                            jsonProperty(\"Type\", \"consul\")\n                        )\n                    ))\n                ))))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  sd:\n    type: consul:ConfigEntry\n    properties:\n      name: fort-knox\n      kind: service-defaults\n      configJson:\n        fn::toJSON:\n          Protocol: http\n  jwtProvider:\n    type: consul:ConfigEntry\n    name: jwt_provider\n    properties:\n      name: test-provider\n      kind: jwt-provider\n      configJson:\n        fn::toJSON:\n          Issuer: test-issuer\n          JSONWebKeySet:\n            Remote:\n              URI: https://127.0.0.1:9091\n              FetchAsynchronously: true\n          Forwarding:\n            HeaderName: test-token\n  serviceIntentions:\n    type: consul:ConfigEntry\n    name: service_intentions\n    properties:\n      name: ${sd.name}\n      kind: service-intentions\n      configJson:\n        fn::toJSON:\n          Sources:\n            - Name: contractor-webapp\n              Permissions:\n                - Action: allow\n                  HTTP:\n                    Methods:\n                      - GET\n                      - HEAD\n                    PathExact: /healtz\n                  JWT:\n                    Providers:\n                      - Name: ${jwtProvider.name}\n              Precedence: 9\n              Type: consul\n            - Name: admin-dashboard-webapp\n              Permissions:\n                - Action: deny\n                  HTTP:\n                    PathPrefix: /debugz\n                - Action: allow\n                  HTTP:\n                    PathPrefix: /\n              Precedence: 9\n              Type: consul\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### `exported-services` config entry\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst exportedServices = new consul.ConfigEntry(\"exported_services\", {\n    name: \"test\",\n    kind: \"exported-services\",\n    configJson: JSON.stringify({\n        Services: [{\n            Name: \"test\",\n            Namespace: \"default\",\n            Consumers: [{\n                Partition: \"default\",\n            }],\n        }],\n    }),\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_consul as consul\n\nexported_services = consul.ConfigEntry(\"exported_services\",\n    name=\"test\",\n    kind=\"exported-services\",\n    config_json=json.dumps({\n        \"Services\": [{\n            \"Name\": \"test\",\n            \"Namespace\": \"default\",\n            \"Consumers\": [{\n                \"Partition\": \"default\",\n            }],\n        }],\n    }))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exportedServices = new Consul.ConfigEntry(\"exported_services\", new()\n    {\n        Name = \"test\",\n        Kind = \"exported-services\",\n        ConfigJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"Services\"] = new[]\n            {\n                new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"Name\"] = \"test\",\n                    [\"Namespace\"] = \"default\",\n                    [\"Consumers\"] = new[]\n                    {\n                        new Dictionary\u003cstring, object?\u003e\n                        {\n                            [\"Partition\"] = \"default\",\n                        },\n                    },\n                },\n            },\n        }),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"Services\": []map[string]interface{}{\n\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\"Name\":      \"test\",\n\t\t\t\t\t\"Namespace\": \"default\",\n\t\t\t\t\t\"Consumers\": []map[string]interface{}{\n\t\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\t\"Partition\": \"default\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\t_, err = consul.NewConfigEntry(ctx, \"exported_services\", \u0026consul.ConfigEntryArgs{\n\t\t\tName:       pulumi.String(\"test\"),\n\t\t\tKind:       pulumi.String(\"exported-services\"),\n\t\t\tConfigJson: pulumi.String(json0),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConfigEntry;\nimport com.pulumi.consul.ConfigEntryArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exportedServices = new ConfigEntry(\"exportedServices\", ConfigEntryArgs.builder()\n            .name(\"test\")\n            .kind(\"exported-services\")\n            .configJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"Services\", jsonArray(jsonObject(\n                        jsonProperty(\"Name\", \"test\"),\n                        jsonProperty(\"Namespace\", \"default\"),\n                        jsonProperty(\"Consumers\", jsonArray(jsonObject(\n                            jsonProperty(\"Partition\", \"default\")\n                        )))\n                    )))\n                )))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exportedServices:\n    type: consul:ConfigEntry\n    name: exported_services\n    properties:\n      name: test\n      kind: exported-services\n      configJson:\n        fn::toJSON:\n          Services:\n            - Name: test\n              Namespace: default\n              Consumers:\n                - Partition: default\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### `mesh` config entry\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst mesh = new consul.ConfigEntry(\"mesh\", {\n    name: \"mesh\",\n    kind: \"mesh\",\n    partition: \"default\",\n    configJson: JSON.stringify({\n        TransparentProxy: {\n            MeshDestinationsOnly: true,\n        },\n    }),\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_consul as consul\n\nmesh = consul.ConfigEntry(\"mesh\",\n    name=\"mesh\",\n    kind=\"mesh\",\n    partition=\"default\",\n    config_json=json.dumps({\n        \"TransparentProxy\": {\n            \"MeshDestinationsOnly\": True,\n        },\n    }))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var mesh = new Consul.ConfigEntry(\"mesh\", new()\n    {\n        Name = \"mesh\",\n        Kind = \"mesh\",\n        Partition = \"default\",\n        ConfigJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"TransparentProxy\"] = new Dictionary\u003cstring, object?\u003e\n            {\n                [\"MeshDestinationsOnly\"] = true,\n            },\n        }),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"TransparentProxy\": map[string]interface{}{\n\t\t\t\t\"MeshDestinationsOnly\": true,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\t_, err = consul.NewConfigEntry(ctx, \"mesh\", \u0026consul.ConfigEntryArgs{\n\t\t\tName:       pulumi.String(\"mesh\"),\n\t\t\tKind:       pulumi.String(\"mesh\"),\n\t\t\tPartition:  pulumi.String(\"default\"),\n\t\t\tConfigJson: pulumi.String(json0),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConfigEntry;\nimport com.pulumi.consul.ConfigEntryArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var mesh = new ConfigEntry(\"mesh\", ConfigEntryArgs.builder()\n            .name(\"mesh\")\n            .kind(\"mesh\")\n            .partition(\"default\")\n            .configJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"TransparentProxy\", jsonObject(\n                        jsonProperty(\"MeshDestinationsOnly\", true)\n                    ))\n                )))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  mesh:\n    type: consul:ConfigEntry\n    properties:\n      name: mesh\n      kind: mesh\n      partition: default\n      configJson:\n        fn::toJSON:\n          TransparentProxy:\n            MeshDestinationsOnly: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n### `jwt-provider` config entry\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst jwtProvider = new consul.ConfigEntry(\"jwt_provider\", {\n    name: \"provider-name\",\n    kind: \"jwt-provider\",\n    configJson: JSON.stringify({\n        Issuer: \"https://your.issuer.com\",\n        JSONWebKeySet: {\n            Remote: {\n                URI: \"https://your-remote.jwks.com\",\n                FetchAsynchronously: true,\n                CacheDuration: \"10s\",\n            },\n        },\n        Forwarding: {\n            HeaderName: \"test-token\",\n        },\n    }),\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_consul as consul\n\njwt_provider = consul.ConfigEntry(\"jwt_provider\",\n    name=\"provider-name\",\n    kind=\"jwt-provider\",\n    config_json=json.dumps({\n        \"Issuer\": \"https://your.issuer.com\",\n        \"JSONWebKeySet\": {\n            \"Remote\": {\n                \"URI\": \"https://your-remote.jwks.com\",\n                \"FetchAsynchronously\": True,\n                \"CacheDuration\": \"10s\",\n            },\n        },\n        \"Forwarding\": {\n            \"HeaderName\": \"test-token\",\n        },\n    }))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var jwtProvider = new Consul.ConfigEntry(\"jwt_provider\", new()\n    {\n        Name = \"provider-name\",\n        Kind = \"jwt-provider\",\n        ConfigJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"Issuer\"] = \"https://your.issuer.com\",\n            [\"JSONWebKeySet\"] = new Dictionary\u003cstring, object?\u003e\n            {\n                [\"Remote\"] = new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"URI\"] = \"https://your-remote.jwks.com\",\n                    [\"FetchAsynchronously\"] = true,\n                    [\"CacheDuration\"] = \"10s\",\n                },\n            },\n            [\"Forwarding\"] = new Dictionary\u003cstring, object?\u003e\n            {\n                [\"HeaderName\"] = \"test-token\",\n            },\n        }),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"Issuer\": \"https://your.issuer.com\",\n\t\t\t\"JSONWebKeySet\": map[string]interface{}{\n\t\t\t\t\"Remote\": map[string]interface{}{\n\t\t\t\t\t\"URI\":                 \"https://your-remote.jwks.com\",\n\t\t\t\t\t\"FetchAsynchronously\": true,\n\t\t\t\t\t\"CacheDuration\":       \"10s\",\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"Forwarding\": map[string]interface{}{\n\t\t\t\t\"HeaderName\": \"test-token\",\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\t_, err = consul.NewConfigEntry(ctx, \"jwt_provider\", \u0026consul.ConfigEntryArgs{\n\t\t\tName:       pulumi.String(\"provider-name\"),\n\t\t\tKind:       pulumi.String(\"jwt-provider\"),\n\t\t\tConfigJson: pulumi.String(json0),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConfigEntry;\nimport com.pulumi.consul.ConfigEntryArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var jwtProvider = new ConfigEntry(\"jwtProvider\", ConfigEntryArgs.builder()\n            .name(\"provider-name\")\n            .kind(\"jwt-provider\")\n            .configJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"Issuer\", \"https://your.issuer.com\"),\n                    jsonProperty(\"JSONWebKeySet\", jsonObject(\n                        jsonProperty(\"Remote\", jsonObject(\n                            jsonProperty(\"URI\", \"https://your-remote.jwks.com\"),\n                            jsonProperty(\"FetchAsynchronously\", true),\n                            jsonProperty(\"CacheDuration\", \"10s\")\n                        ))\n                    )),\n                    jsonProperty(\"Forwarding\", jsonObject(\n                        jsonProperty(\"HeaderName\", \"test-token\")\n                    ))\n                )))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  jwtProvider:\n    type: consul:ConfigEntry\n    name: jwt_provider\n    properties:\n      name: provider-name\n      kind: jwt-provider\n      configJson:\n        fn::toJSON:\n          Issuer: https://your.issuer.com\n          JSONWebKeySet:\n            Remote:\n              URI: https://your-remote.jwks.com\n              FetchAsynchronously: true\n              CacheDuration: 10s\n          Forwarding:\n            HeaderName: test-token\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n`consul_config_entry` can be imported using the syntax `\u003ckind\u003e/\u003cname\u003e` if the\nconfig entry is in the default partition and default namespace, or\n`\u003cpartition\u003e/\u003cnamespace\u003e/\u003ckind\u003e/\u003cname\u003e` for config entries in a non-default\npartition or namespace:\n\n```sh\n$ pulumi import consul:index/configEntry:ConfigEntry service_splitter 816a195f-6cb1-2e8d-92af-3011ae706318\n```\n",
            "properties": {
                "configJson": {
                    "type": "string",
                    "description": "An arbitrary map of configuration values.\n"
                },
                "kind": {
                    "type": "string",
                    "description": "The kind of configuration entry to register.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the configuration entry being registered.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to create the config entry within.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "The partition the config entry is associated with.\n"
                }
            },
            "required": [
                "kind",
                "name"
            ],
            "inputProperties": {
                "configJson": {
                    "type": "string",
                    "description": "An arbitrary map of configuration values.\n"
                },
                "kind": {
                    "type": "string",
                    "description": "The kind of configuration entry to register.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "The name of the configuration entry being registered.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to create the config entry within.\n",
                    "willReplaceOnChanges": true
                },
                "partition": {
                    "type": "string",
                    "description": "The partition the config entry is associated with.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "kind"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ConfigEntry resources.\n",
                "properties": {
                    "configJson": {
                        "type": "string",
                        "description": "An arbitrary map of configuration values.\n"
                    },
                    "kind": {
                        "type": "string",
                        "description": "The kind of configuration entry to register.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the configuration entry being registered.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to create the config entry within.\n",
                        "willReplaceOnChanges": true
                    },
                    "partition": {
                        "type": "string",
                        "description": "The partition the config entry is associated with.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "consul:index/configEntryServiceDefaults:ConfigEntryServiceDefaults": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  dashboard:\n    type: consul:ConfigEntryServiceDefaults\n    properties:\n      name: dashboard\n      upstreamConfigs:\n        - defaults:\n            meshGateways:\n              mode: local\n            limits:\n              maxConnections: 512\n              maxPendingRequests: 512\n              maxConcurrentRequests: 512\n          overrides:\n            - name: counting\n              meshGateways:\n                - mode: remote\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "balanceInboundConnections": {
                    "type": "string",
                    "description": "Specifies the strategy for allocating inbound connections to the service across Envoy proxy threads.\n"
                },
                "destinations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsDestination:ConfigEntryServiceDefaultsDestination"
                    },
                    "description": "Configures the destination for service traffic through terminating gateways.\n"
                },
                "envoyExtensions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsEnvoyExtension:ConfigEntryServiceDefaultsEnvoyExtension"
                    },
                    "description": "List of extensions to modify Envoy proxy configuration.\n"
                },
                "exposes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsExpose:ConfigEntryServiceDefaultsExpose"
                    },
                    "description": "Specifies default configurations for exposing HTTP paths through Envoy.\n"
                },
                "externalSni": {
                    "type": "string",
                    "description": "Specifies the TLS server name indication (SNI) when federating with an external system.\n"
                },
                "localConnectTimeoutMs": {
                    "type": "integer",
                    "description": "Specifies the number of milliseconds allowed for establishing connections to the local application instance before timing out.\n"
                },
                "localRequestTimeoutMs": {
                    "type": "integer",
                    "description": "Specifies the timeout for HTTP requests to the local application instance.\n"
                },
                "maxInboundConnections": {
                    "type": "integer",
                    "description": "Specifies the maximum number of concurrent inbound connections to each service instance.\n"
                },
                "meshGateways": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsMeshGateway:ConfigEntryServiceDefaultsMeshGateway"
                    },
                    "description": "Specifies the default mesh gateway mode field for the service.\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies a set of custom key-value pairs to add to the Consul KV store.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Specifies a mode for how the service directs inbound and outbound traffic.\n"
                },
                "mutualTlsMode": {
                    "type": "string",
                    "description": "Controls whether mutual TLS is required for incoming connections to this service. This setting is only supported for services with transparent proxy enabled.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the service you are setting the defaults for.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Specifies the Consul namespace that the configuration entry applies to.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "Specifies the name of the name of the Consul admin partition that the configuration entry applies to. Refer to Admin Partitions for additional information.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Specifies the default protocol for the service.\n"
                },
                "transparentProxies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsTransparentProxy:ConfigEntryServiceDefaultsTransparentProxy"
                    },
                    "description": "Controls configurations specific to proxies in transparent mode. Refer to Transparent Proxy Mode for additional information.\n"
                },
                "upstreamConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsUpstreamConfig:ConfigEntryServiceDefaultsUpstreamConfig"
                    },
                    "description": "Controls default upstream connection settings and custom overrides for individual upstream services.\n"
                }
            },
            "required": [
                "exposes",
                "name",
                "protocol"
            ],
            "inputProperties": {
                "balanceInboundConnections": {
                    "type": "string",
                    "description": "Specifies the strategy for allocating inbound connections to the service across Envoy proxy threads.\n"
                },
                "destinations": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsDestination:ConfigEntryServiceDefaultsDestination"
                    },
                    "description": "Configures the destination for service traffic through terminating gateways.\n"
                },
                "envoyExtensions": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsEnvoyExtension:ConfigEntryServiceDefaultsEnvoyExtension"
                    },
                    "description": "List of extensions to modify Envoy proxy configuration.\n"
                },
                "exposes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsExpose:ConfigEntryServiceDefaultsExpose"
                    },
                    "description": "Specifies default configurations for exposing HTTP paths through Envoy.\n"
                },
                "externalSni": {
                    "type": "string",
                    "description": "Specifies the TLS server name indication (SNI) when federating with an external system.\n"
                },
                "localConnectTimeoutMs": {
                    "type": "integer",
                    "description": "Specifies the number of milliseconds allowed for establishing connections to the local application instance before timing out.\n"
                },
                "localRequestTimeoutMs": {
                    "type": "integer",
                    "description": "Specifies the timeout for HTTP requests to the local application instance.\n"
                },
                "maxInboundConnections": {
                    "type": "integer",
                    "description": "Specifies the maximum number of concurrent inbound connections to each service instance.\n"
                },
                "meshGateways": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsMeshGateway:ConfigEntryServiceDefaultsMeshGateway"
                    },
                    "description": "Specifies the default mesh gateway mode field for the service.\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies a set of custom key-value pairs to add to the Consul KV store.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Specifies a mode for how the service directs inbound and outbound traffic.\n"
                },
                "mutualTlsMode": {
                    "type": "string",
                    "description": "Controls whether mutual TLS is required for incoming connections to this service. This setting is only supported for services with transparent proxy enabled.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies the name of the service you are setting the defaults for.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "Specifies the Consul namespace that the configuration entry applies to.\n",
                    "willReplaceOnChanges": true
                },
                "partition": {
                    "type": "string",
                    "description": "Specifies the name of the name of the Consul admin partition that the configuration entry applies to. Refer to Admin Partitions for additional information.\n",
                    "willReplaceOnChanges": true
                },
                "protocol": {
                    "type": "string",
                    "description": "Specifies the default protocol for the service.\n"
                },
                "transparentProxies": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsTransparentProxy:ConfigEntryServiceDefaultsTransparentProxy"
                    },
                    "description": "Controls configurations specific to proxies in transparent mode. Refer to Transparent Proxy Mode for additional information.\n"
                },
                "upstreamConfigs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsUpstreamConfig:ConfigEntryServiceDefaultsUpstreamConfig"
                    },
                    "description": "Controls default upstream connection settings and custom overrides for individual upstream services.\n"
                }
            },
            "requiredInputs": [
                "exposes",
                "protocol"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ConfigEntryServiceDefaults resources.\n",
                "properties": {
                    "balanceInboundConnections": {
                        "type": "string",
                        "description": "Specifies the strategy for allocating inbound connections to the service across Envoy proxy threads.\n"
                    },
                    "destinations": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsDestination:ConfigEntryServiceDefaultsDestination"
                        },
                        "description": "Configures the destination for service traffic through terminating gateways.\n"
                    },
                    "envoyExtensions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsEnvoyExtension:ConfigEntryServiceDefaultsEnvoyExtension"
                        },
                        "description": "List of extensions to modify Envoy proxy configuration.\n"
                    },
                    "exposes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsExpose:ConfigEntryServiceDefaultsExpose"
                        },
                        "description": "Specifies default configurations for exposing HTTP paths through Envoy.\n"
                    },
                    "externalSni": {
                        "type": "string",
                        "description": "Specifies the TLS server name indication (SNI) when federating with an external system.\n"
                    },
                    "localConnectTimeoutMs": {
                        "type": "integer",
                        "description": "Specifies the number of milliseconds allowed for establishing connections to the local application instance before timing out.\n"
                    },
                    "localRequestTimeoutMs": {
                        "type": "integer",
                        "description": "Specifies the timeout for HTTP requests to the local application instance.\n"
                    },
                    "maxInboundConnections": {
                        "type": "integer",
                        "description": "Specifies the maximum number of concurrent inbound connections to each service instance.\n"
                    },
                    "meshGateways": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsMeshGateway:ConfigEntryServiceDefaultsMeshGateway"
                        },
                        "description": "Specifies the default mesh gateway mode field for the service.\n"
                    },
                    "meta": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Specifies a set of custom key-value pairs to add to the Consul KV store.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "Specifies a mode for how the service directs inbound and outbound traffic.\n"
                    },
                    "mutualTlsMode": {
                        "type": "string",
                        "description": "Controls whether mutual TLS is required for incoming connections to this service. This setting is only supported for services with transparent proxy enabled.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies the name of the service you are setting the defaults for.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "Specifies the Consul namespace that the configuration entry applies to.\n",
                        "willReplaceOnChanges": true
                    },
                    "partition": {
                        "type": "string",
                        "description": "Specifies the name of the name of the Consul admin partition that the configuration entry applies to. Refer to Admin Partitions for additional information.\n",
                        "willReplaceOnChanges": true
                    },
                    "protocol": {
                        "type": "string",
                        "description": "Specifies the default protocol for the service.\n"
                    },
                    "transparentProxies": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsTransparentProxy:ConfigEntryServiceDefaultsTransparentProxy"
                        },
                        "description": "Controls configurations specific to proxies in transparent mode. Refer to Transparent Proxy Mode for additional information.\n"
                    },
                    "upstreamConfigs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/ConfigEntryServiceDefaultsUpstreamConfig:ConfigEntryServiceDefaultsUpstreamConfig"
                        },
                        "description": "Controls default upstream connection settings and custom overrides for individual upstream services.\n"
                    }
                },
                "type": "object"
            }
        },
        "consul:index/configEntryServiceIntentions:ConfigEntryServiceIntentions": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst jwtProvider = new consul.ConfigEntry(\"jwt_provider\", {\n    name: \"okta\",\n    kind: \"jwt-provider\",\n    configJson: JSON.stringify({\n        ClockSkewSeconds: 30,\n        Issuer: \"test-issuer\",\n        JSONWebKeySet: {\n            Remote: {\n                URI: \"https://127.0.0.1:9091\",\n                FetchAsynchronously: true,\n            },\n        },\n    }),\n});\nconst web = new consul.ConfigEntryServiceIntentions(\"web\", {\n    name: \"web\",\n    jwts: [{\n        providers: [{\n            name: jwtProvider.name,\n            verifyClaims: [{\n                paths: [\n                    \"perms\",\n                    \"role\",\n                ],\n                value: \"admin\",\n            }],\n        }],\n    }],\n    sources: [\n        {\n            name: \"frontend-webapp\",\n            type: \"consul\",\n            action: \"allow\",\n        },\n        {\n            name: \"nightly-cronjob\",\n            type: \"consul\",\n            action: \"deny\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_consul as consul\n\njwt_provider = consul.ConfigEntry(\"jwt_provider\",\n    name=\"okta\",\n    kind=\"jwt-provider\",\n    config_json=json.dumps({\n        \"ClockSkewSeconds\": 30,\n        \"Issuer\": \"test-issuer\",\n        \"JSONWebKeySet\": {\n            \"Remote\": {\n                \"URI\": \"https://127.0.0.1:9091\",\n                \"FetchAsynchronously\": True,\n            },\n        },\n    }))\nweb = consul.ConfigEntryServiceIntentions(\"web\",\n    name=\"web\",\n    jwts=[{\n        \"providers\": [{\n            \"name\": jwt_provider.name,\n            \"verify_claims\": [{\n                \"paths\": [\n                    \"perms\",\n                    \"role\",\n                ],\n                \"value\": \"admin\",\n            }],\n        }],\n    }],\n    sources=[\n        {\n            \"name\": \"frontend-webapp\",\n            \"type\": \"consul\",\n            \"action\": \"allow\",\n        },\n        {\n            \"name\": \"nightly-cronjob\",\n            \"type\": \"consul\",\n            \"action\": \"deny\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var jwtProvider = new Consul.ConfigEntry(\"jwt_provider\", new()\n    {\n        Name = \"okta\",\n        Kind = \"jwt-provider\",\n        ConfigJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"ClockSkewSeconds\"] = 30,\n            [\"Issuer\"] = \"test-issuer\",\n            [\"JSONWebKeySet\"] = new Dictionary\u003cstring, object?\u003e\n            {\n                [\"Remote\"] = new Dictionary\u003cstring, object?\u003e\n                {\n                    [\"URI\"] = \"https://127.0.0.1:9091\",\n                    [\"FetchAsynchronously\"] = true,\n                },\n            },\n        }),\n    });\n\n    var web = new Consul.ConfigEntryServiceIntentions(\"web\", new()\n    {\n        Name = \"web\",\n        Jwts = new[]\n        {\n            new Consul.Inputs.ConfigEntryServiceIntentionsJwtArgs\n            {\n                Providers = new[]\n                {\n                    new Consul.Inputs.ConfigEntryServiceIntentionsJwtProviderArgs\n                    {\n                        Name = jwtProvider.Name,\n                        VerifyClaims = new[]\n                        {\n                            new Consul.Inputs.ConfigEntryServiceIntentionsJwtProviderVerifyClaimArgs\n                            {\n                                Paths = new[]\n                                {\n                                    \"perms\",\n                                    \"role\",\n                                },\n                                Value = \"admin\",\n                            },\n                        },\n                    },\n                },\n            },\n        },\n        Sources = new[]\n        {\n            new Consul.Inputs.ConfigEntryServiceIntentionsSourceArgs\n            {\n                Name = \"frontend-webapp\",\n                Type = \"consul\",\n                Action = \"allow\",\n            },\n            new Consul.Inputs.ConfigEntryServiceIntentionsSourceArgs\n            {\n                Name = \"nightly-cronjob\",\n                Type = \"consul\",\n                Action = \"deny\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"ClockSkewSeconds\": 30,\n\t\t\t\"Issuer\":           \"test-issuer\",\n\t\t\t\"JSONWebKeySet\": map[string]interface{}{\n\t\t\t\t\"Remote\": map[string]interface{}{\n\t\t\t\t\t\"URI\":                 \"https://127.0.0.1:9091\",\n\t\t\t\t\t\"FetchAsynchronously\": true,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\tjwtProvider, err := consul.NewConfigEntry(ctx, \"jwt_provider\", \u0026consul.ConfigEntryArgs{\n\t\t\tName:       pulumi.String(\"okta\"),\n\t\t\tKind:       pulumi.String(\"jwt-provider\"),\n\t\t\tConfigJson: pulumi.String(json0),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = consul.NewConfigEntryServiceIntentions(ctx, \"web\", \u0026consul.ConfigEntryServiceIntentionsArgs{\n\t\t\tName: pulumi.String(\"web\"),\n\t\t\tJwts: consul.ConfigEntryServiceIntentionsJwtArray{\n\t\t\t\t\u0026consul.ConfigEntryServiceIntentionsJwtArgs{\n\t\t\t\t\tProviders: consul.ConfigEntryServiceIntentionsJwtProviderArray{\n\t\t\t\t\t\t\u0026consul.ConfigEntryServiceIntentionsJwtProviderArgs{\n\t\t\t\t\t\t\tName: jwtProvider.Name,\n\t\t\t\t\t\t\tVerifyClaims: consul.ConfigEntryServiceIntentionsJwtProviderVerifyClaimArray{\n\t\t\t\t\t\t\t\t\u0026consul.ConfigEntryServiceIntentionsJwtProviderVerifyClaimArgs{\n\t\t\t\t\t\t\t\t\tPaths: pulumi.StringArray{\n\t\t\t\t\t\t\t\t\t\tpulumi.String(\"perms\"),\n\t\t\t\t\t\t\t\t\t\tpulumi.String(\"role\"),\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tValue: pulumi.String(\"admin\"),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tSources: consul.ConfigEntryServiceIntentionsSourceArray{\n\t\t\t\t\u0026consul.ConfigEntryServiceIntentionsSourceArgs{\n\t\t\t\t\tName:   pulumi.String(\"frontend-webapp\"),\n\t\t\t\t\tType:   pulumi.String(\"consul\"),\n\t\t\t\t\tAction: pulumi.String(\"allow\"),\n\t\t\t\t},\n\t\t\t\t\u0026consul.ConfigEntryServiceIntentionsSourceArgs{\n\t\t\t\t\tName:   pulumi.String(\"nightly-cronjob\"),\n\t\t\t\t\tType:   pulumi.String(\"consul\"),\n\t\t\t\t\tAction: pulumi.String(\"deny\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConfigEntry;\nimport com.pulumi.consul.ConfigEntryArgs;\nimport com.pulumi.consul.ConfigEntryServiceIntentions;\nimport com.pulumi.consul.ConfigEntryServiceIntentionsArgs;\nimport com.pulumi.consul.inputs.ConfigEntryServiceIntentionsJwtArgs;\nimport com.pulumi.consul.inputs.ConfigEntryServiceIntentionsSourceArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var jwtProvider = new ConfigEntry(\"jwtProvider\", ConfigEntryArgs.builder()\n            .name(\"okta\")\n            .kind(\"jwt-provider\")\n            .configJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"ClockSkewSeconds\", 30),\n                    jsonProperty(\"Issuer\", \"test-issuer\"),\n                    jsonProperty(\"JSONWebKeySet\", jsonObject(\n                        jsonProperty(\"Remote\", jsonObject(\n                            jsonProperty(\"URI\", \"https://127.0.0.1:9091\"),\n                            jsonProperty(\"FetchAsynchronously\", true)\n                        ))\n                    ))\n                )))\n            .build());\n\n        var web = new ConfigEntryServiceIntentions(\"web\", ConfigEntryServiceIntentionsArgs.builder()\n            .name(\"web\")\n            .jwts(ConfigEntryServiceIntentionsJwtArgs.builder()\n                .providers(ConfigEntryServiceIntentionsJwtProviderArgs.builder()\n                    .name(jwtProvider.name())\n                    .verifyClaims(ConfigEntryServiceIntentionsJwtProviderVerifyClaimArgs.builder()\n                        .paths(                        \n                            \"perms\",\n                            \"role\")\n                        .value(\"admin\")\n                        .build())\n                    .build())\n                .build())\n            .sources(            \n                ConfigEntryServiceIntentionsSourceArgs.builder()\n                    .name(\"frontend-webapp\")\n                    .type(\"consul\")\n                    .action(\"allow\")\n                    .build(),\n                ConfigEntryServiceIntentionsSourceArgs.builder()\n                    .name(\"nightly-cronjob\")\n                    .type(\"consul\")\n                    .action(\"deny\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  jwtProvider:\n    type: consul:ConfigEntry\n    name: jwt_provider\n    properties:\n      name: okta\n      kind: jwt-provider\n      configJson:\n        fn::toJSON:\n          ClockSkewSeconds: 30\n          Issuer: test-issuer\n          JSONWebKeySet:\n            Remote:\n              URI: https://127.0.0.1:9091\n              FetchAsynchronously: true\n  web:\n    type: consul:ConfigEntryServiceIntentions\n    properties:\n      name: web\n      jwts:\n        - providers:\n            - name: ${jwtProvider.name}\n              verifyClaims:\n                - paths:\n                    - perms\n                    - role\n                  value: admin\n      sources:\n        - name: frontend-webapp\n          type: consul\n          action: allow\n        - name: nightly-cronjob\n          type: consul\n          action: deny\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "jwts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceIntentionsJwt:ConfigEntryServiceIntentionsJwt"
                    },
                    "description": "Specifies a JSON Web Token provider configured in a JWT provider configuration entry, as well as additional configurations for verifying a service's JWT before authorizing communication between services\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies key-value pairs to add to the KV store.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies a name of the destination service for all intentions defined in the configuration entry.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Specifies the namespace to apply the configuration entry.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "Specifies the admin partition to apply the configuration entry.\n"
                },
                "sources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceIntentionsSource:ConfigEntryServiceIntentionsSource"
                    },
                    "description": "List of configurations that define intention sources and the authorization granted to the sources.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "jwts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceIntentionsJwt:ConfigEntryServiceIntentionsJwt"
                    },
                    "description": "Specifies a JSON Web Token provider configured in a JWT provider configuration entry, as well as additional configurations for verifying a service's JWT before authorizing communication between services\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies key-value pairs to add to the KV store.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies a name of the destination service for all intentions defined in the configuration entry.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "Specifies the namespace to apply the configuration entry.\n",
                    "willReplaceOnChanges": true
                },
                "partition": {
                    "type": "string",
                    "description": "Specifies the admin partition to apply the configuration entry.\n",
                    "willReplaceOnChanges": true
                },
                "sources": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceIntentionsSource:ConfigEntryServiceIntentionsSource"
                    },
                    "description": "List of configurations that define intention sources and the authorization granted to the sources.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ConfigEntryServiceIntentions resources.\n",
                "properties": {
                    "jwts": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/ConfigEntryServiceIntentionsJwt:ConfigEntryServiceIntentionsJwt"
                        },
                        "description": "Specifies a JSON Web Token provider configured in a JWT provider configuration entry, as well as additional configurations for verifying a service's JWT before authorizing communication between services\n"
                    },
                    "meta": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Specifies key-value pairs to add to the KV store.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies a name of the destination service for all intentions defined in the configuration entry.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "Specifies the namespace to apply the configuration entry.\n",
                        "willReplaceOnChanges": true
                    },
                    "partition": {
                        "type": "string",
                        "description": "Specifies the admin partition to apply the configuration entry.\n",
                        "willReplaceOnChanges": true
                    },
                    "sources": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/ConfigEntryServiceIntentionsSource:ConfigEntryServiceIntentionsSource"
                        },
                        "description": "List of configurations that define intention sources and the authorization granted to the sources.\n"
                    }
                },
                "type": "object"
            }
        },
        "consul:index/configEntryServiceResolver:ConfigEntryServiceResolver": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst web = new consul.ConfigEntryServiceResolver(\"web\", {\n    name: \"web\",\n    defaultSubset: \"v1\",\n    connectTimeout: \"15s\",\n    subsets: [\n        {\n            name: \"v1\",\n            filter: \"Service.Meta.version == v1\",\n        },\n        {\n            name: \"v2\",\n            filter: \"Service.Meta.version == v2\",\n        },\n    ],\n    redirects: [{\n        service: \"web\",\n        datacenter: \"dc2\",\n    }],\n    failovers: [\n        {\n            subsetName: \"v2\",\n            datacenters: [\"dc2\"],\n        },\n        {\n            subsetName: \"*\",\n            datacenters: [\n                \"dc3\",\n                \"dc4\",\n            ],\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\nweb = consul.ConfigEntryServiceResolver(\"web\",\n    name=\"web\",\n    default_subset=\"v1\",\n    connect_timeout=\"15s\",\n    subsets=[\n        {\n            \"name\": \"v1\",\n            \"filter\": \"Service.Meta.version == v1\",\n        },\n        {\n            \"name\": \"v2\",\n            \"filter\": \"Service.Meta.version == v2\",\n        },\n    ],\n    redirects=[{\n        \"service\": \"web\",\n        \"datacenter\": \"dc2\",\n    }],\n    failovers=[\n        {\n            \"subset_name\": \"v2\",\n            \"datacenters\": [\"dc2\"],\n        },\n        {\n            \"subset_name\": \"*\",\n            \"datacenters\": [\n                \"dc3\",\n                \"dc4\",\n            ],\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var web = new Consul.ConfigEntryServiceResolver(\"web\", new()\n    {\n        Name = \"web\",\n        DefaultSubset = \"v1\",\n        ConnectTimeout = \"15s\",\n        Subsets = new[]\n        {\n            new Consul.Inputs.ConfigEntryServiceResolverSubsetArgs\n            {\n                Name = \"v1\",\n                Filter = \"Service.Meta.version == v1\",\n            },\n            new Consul.Inputs.ConfigEntryServiceResolverSubsetArgs\n            {\n                Name = \"v2\",\n                Filter = \"Service.Meta.version == v2\",\n            },\n        },\n        Redirects = new[]\n        {\n            new Consul.Inputs.ConfigEntryServiceResolverRedirectArgs\n            {\n                Service = \"web\",\n                Datacenter = \"dc2\",\n            },\n        },\n        Failovers = new[]\n        {\n            new Consul.Inputs.ConfigEntryServiceResolverFailoverArgs\n            {\n                SubsetName = \"v2\",\n                Datacenters = new[]\n                {\n                    \"dc2\",\n                },\n            },\n            new Consul.Inputs.ConfigEntryServiceResolverFailoverArgs\n            {\n                SubsetName = \"*\",\n                Datacenters = new[]\n                {\n                    \"dc3\",\n                    \"dc4\",\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.NewConfigEntryServiceResolver(ctx, \"web\", \u0026consul.ConfigEntryServiceResolverArgs{\n\t\t\tName:           pulumi.String(\"web\"),\n\t\t\tDefaultSubset:  pulumi.String(\"v1\"),\n\t\t\tConnectTimeout: pulumi.String(\"15s\"),\n\t\t\tSubsets: consul.ConfigEntryServiceResolverSubsetArray{\n\t\t\t\t\u0026consul.ConfigEntryServiceResolverSubsetArgs{\n\t\t\t\t\tName:   pulumi.String(\"v1\"),\n\t\t\t\t\tFilter: pulumi.String(\"Service.Meta.version == v1\"),\n\t\t\t\t},\n\t\t\t\t\u0026consul.ConfigEntryServiceResolverSubsetArgs{\n\t\t\t\t\tName:   pulumi.String(\"v2\"),\n\t\t\t\t\tFilter: pulumi.String(\"Service.Meta.version == v2\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tRedirects: consul.ConfigEntryServiceResolverRedirectArray{\n\t\t\t\t\u0026consul.ConfigEntryServiceResolverRedirectArgs{\n\t\t\t\t\tService:    pulumi.String(\"web\"),\n\t\t\t\t\tDatacenter: pulumi.String(\"dc2\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tFailovers: consul.ConfigEntryServiceResolverFailoverArray{\n\t\t\t\t\u0026consul.ConfigEntryServiceResolverFailoverArgs{\n\t\t\t\t\tSubsetName: pulumi.String(\"v2\"),\n\t\t\t\t\tDatacenters: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"dc2\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026consul.ConfigEntryServiceResolverFailoverArgs{\n\t\t\t\t\tSubsetName: pulumi.String(\"*\"),\n\t\t\t\t\tDatacenters: pulumi.StringArray{\n\t\t\t\t\t\tpulumi.String(\"dc3\"),\n\t\t\t\t\t\tpulumi.String(\"dc4\"),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConfigEntryServiceResolver;\nimport com.pulumi.consul.ConfigEntryServiceResolverArgs;\nimport com.pulumi.consul.inputs.ConfigEntryServiceResolverSubsetArgs;\nimport com.pulumi.consul.inputs.ConfigEntryServiceResolverRedirectArgs;\nimport com.pulumi.consul.inputs.ConfigEntryServiceResolverFailoverArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var web = new ConfigEntryServiceResolver(\"web\", ConfigEntryServiceResolverArgs.builder()\n            .name(\"web\")\n            .defaultSubset(\"v1\")\n            .connectTimeout(\"15s\")\n            .subsets(            \n                ConfigEntryServiceResolverSubsetArgs.builder()\n                    .name(\"v1\")\n                    .filter(\"Service.Meta.version == v1\")\n                    .build(),\n                ConfigEntryServiceResolverSubsetArgs.builder()\n                    .name(\"v2\")\n                    .filter(\"Service.Meta.version == v2\")\n                    .build())\n            .redirects(ConfigEntryServiceResolverRedirectArgs.builder()\n                .service(\"web\")\n                .datacenter(\"dc2\")\n                .build())\n            .failovers(            \n                ConfigEntryServiceResolverFailoverArgs.builder()\n                    .subsetName(\"v2\")\n                    .datacenters(\"dc2\")\n                    .build(),\n                ConfigEntryServiceResolverFailoverArgs.builder()\n                    .subsetName(\"*\")\n                    .datacenters(                    \n                        \"dc3\",\n                        \"dc4\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  web:\n    type: consul:ConfigEntryServiceResolver\n    properties:\n      name: web\n      defaultSubset: v1\n      connectTimeout: 15s\n      subsets:\n        - name: v1\n          filter: Service.Meta.version == v1\n        - name: v2\n          filter: Service.Meta.version == v2\n      redirects:\n        - service: web\n          datacenter: dc2\n      failovers:\n        - subsetName: v2\n          datacenters:\n            - dc2\n        - subsetName: '*'\n          datacenters:\n            - dc3\n            - dc4\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "connectTimeout": {
                    "type": "string",
                    "description": "Specifies the timeout duration for establishing new network connections to this service.\n"
                },
                "defaultSubset": {
                    "type": "string",
                    "description": "Specifies a defined subset of service instances to use when no explicit subset is requested. If this parameter is not specified, Consul uses the unnamed default subset.\n"
                },
                "failovers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceResolverFailover:ConfigEntryServiceResolverFailover"
                    },
                    "description": "Specifies controls for rerouting traffic to an alternate pool of service instances if the target service fails.\n"
                },
                "loadBalancers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceResolverLoadBalancer:ConfigEntryServiceResolverLoadBalancer"
                    },
                    "description": "Specifies the load balancing policy and configuration for services issuing requests to this upstream.\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies key-value pairs to add to the KV store.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies a name for the configuration entry.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Specifies the namespace that the service resolver applies to.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "Specifies the admin partition that the service resolver applies to.\n"
                },
                "redirects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceResolverRedirect:ConfigEntryServiceResolverRedirect"
                    },
                    "description": "Specifies redirect instructions for local service traffic so that services deployed to a different network location resolve the upstream request instead.\n"
                },
                "requestTimeout": {
                    "type": "string",
                    "description": "Specifies the timeout duration for receiving an HTTP response from this service.\n"
                },
                "subsets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceResolverSubset:ConfigEntryServiceResolverSubset"
                    },
                    "description": "Specifies names for custom service subsets and the conditions under which service instances belong to each subset.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "connectTimeout": {
                    "type": "string",
                    "description": "Specifies the timeout duration for establishing new network connections to this service.\n"
                },
                "defaultSubset": {
                    "type": "string",
                    "description": "Specifies a defined subset of service instances to use when no explicit subset is requested. If this parameter is not specified, Consul uses the unnamed default subset.\n"
                },
                "failovers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceResolverFailover:ConfigEntryServiceResolverFailover"
                    },
                    "description": "Specifies controls for rerouting traffic to an alternate pool of service instances if the target service fails.\n"
                },
                "loadBalancers": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceResolverLoadBalancer:ConfigEntryServiceResolverLoadBalancer"
                    },
                    "description": "Specifies the load balancing policy and configuration for services issuing requests to this upstream.\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies key-value pairs to add to the KV store.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies a name for the configuration entry.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "Specifies the namespace that the service resolver applies to.\n",
                    "willReplaceOnChanges": true
                },
                "partition": {
                    "type": "string",
                    "description": "Specifies the admin partition that the service resolver applies to.\n",
                    "willReplaceOnChanges": true
                },
                "redirects": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceResolverRedirect:ConfigEntryServiceResolverRedirect"
                    },
                    "description": "Specifies redirect instructions for local service traffic so that services deployed to a different network location resolve the upstream request instead.\n"
                },
                "requestTimeout": {
                    "type": "string",
                    "description": "Specifies the timeout duration for receiving an HTTP response from this service.\n"
                },
                "subsets": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceResolverSubset:ConfigEntryServiceResolverSubset"
                    },
                    "description": "Specifies names for custom service subsets and the conditions under which service instances belong to each subset.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ConfigEntryServiceResolver resources.\n",
                "properties": {
                    "connectTimeout": {
                        "type": "string",
                        "description": "Specifies the timeout duration for establishing new network connections to this service.\n"
                    },
                    "defaultSubset": {
                        "type": "string",
                        "description": "Specifies a defined subset of service instances to use when no explicit subset is requested. If this parameter is not specified, Consul uses the unnamed default subset.\n"
                    },
                    "failovers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/ConfigEntryServiceResolverFailover:ConfigEntryServiceResolverFailover"
                        },
                        "description": "Specifies controls for rerouting traffic to an alternate pool of service instances if the target service fails.\n"
                    },
                    "loadBalancers": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/ConfigEntryServiceResolverLoadBalancer:ConfigEntryServiceResolverLoadBalancer"
                        },
                        "description": "Specifies the load balancing policy and configuration for services issuing requests to this upstream.\n"
                    },
                    "meta": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Specifies key-value pairs to add to the KV store.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies a name for the configuration entry.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "Specifies the namespace that the service resolver applies to.\n",
                        "willReplaceOnChanges": true
                    },
                    "partition": {
                        "type": "string",
                        "description": "Specifies the admin partition that the service resolver applies to.\n",
                        "willReplaceOnChanges": true
                    },
                    "redirects": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/ConfigEntryServiceResolverRedirect:ConfigEntryServiceResolverRedirect"
                        },
                        "description": "Specifies redirect instructions for local service traffic so that services deployed to a different network location resolve the upstream request instead.\n"
                    },
                    "requestTimeout": {
                        "type": "string",
                        "description": "Specifies the timeout duration for receiving an HTTP response from this service.\n"
                    },
                    "subsets": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/ConfigEntryServiceResolverSubset:ConfigEntryServiceResolverSubset"
                        },
                        "description": "Specifies names for custom service subsets and the conditions under which service instances belong to each subset.\n"
                    }
                },
                "type": "object"
            }
        },
        "consul:index/configEntryServiceRouter:ConfigEntryServiceRouter": {
            "description": "## Example Usage\n\n",
            "properties": {
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies key-value pairs to add to the KV store.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies a name for the configuration entry.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Specifies the namespace to apply the configuration entry.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "Specifies the admin partition to apply the configuration entry.\n"
                },
                "routes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceRouterRoute:ConfigEntryServiceRouterRoute"
                    },
                    "description": "Defines the possible routes for L7 requests.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies key-value pairs to add to the KV store.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies a name for the configuration entry.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "Specifies the namespace to apply the configuration entry.\n",
                    "willReplaceOnChanges": true
                },
                "partition": {
                    "type": "string",
                    "description": "Specifies the admin partition to apply the configuration entry.\n",
                    "willReplaceOnChanges": true
                },
                "routes": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceRouterRoute:ConfigEntryServiceRouterRoute"
                    },
                    "description": "Defines the possible routes for L7 requests.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ConfigEntryServiceRouter resources.\n",
                "properties": {
                    "meta": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Specifies key-value pairs to add to the KV store.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies a name for the configuration entry.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "Specifies the namespace to apply the configuration entry.\n",
                        "willReplaceOnChanges": true
                    },
                    "partition": {
                        "type": "string",
                        "description": "Specifies the admin partition to apply the configuration entry.\n",
                        "willReplaceOnChanges": true
                    },
                    "routes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/ConfigEntryServiceRouterRoute:ConfigEntryServiceRouterRoute"
                        },
                        "description": "Defines the possible routes for L7 requests.\n"
                    }
                },
                "type": "object"
            }
        },
        "consul:index/configEntryServiceSplitter:ConfigEntryServiceSplitter": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst web = new consul.ConfigEntry(\"web\", {\n    name: \"web\",\n    kind: \"service-defaults\",\n    configJson: JSON.stringify({\n        Protocol: \"http\",\n        Expose: {},\n        MeshGateway: {},\n        TransparentProxy: {},\n    }),\n});\nconst serviceResolver = new consul.ConfigEntryServiceResolver(\"service_resolver\", {\n    name: \"service-resolver\",\n    defaultSubset: \"v1\",\n    subsets: [\n        {\n            name: \"v1\",\n            filter: \"Service.Meta.version == v1\",\n        },\n        {\n            name: \"v2\",\n            filter: \"Service.Meta.version == v2\",\n        },\n    ],\n});\nconst foo = new consul.ConfigEntryServiceSplitter(\"foo\", {\n    name: serviceResolver.name,\n    meta: {\n        key: \"value\",\n    },\n    splits: [\n        {\n            weight: 80,\n            service: \"web\",\n            serviceSubset: \"v1\",\n            requestHeaders: {\n                set: {\n                    \"x-web-version\": \"from-v1\",\n                },\n            },\n            responseHeaders: {\n                set: {\n                    \"x-web-version\": \"to-v1\",\n                },\n            },\n        },\n        {\n            weight: 10,\n            service: \"web\",\n            serviceSubset: \"v2\",\n            requestHeaders: {\n                set: {\n                    \"x-web-version\": \"from-v2\",\n                },\n            },\n            responseHeaders: {\n                set: {\n                    \"x-web-version\": \"to-v2\",\n                },\n            },\n        },\n        {\n            weight: 10,\n            service: \"web\",\n            serviceSubset: \"v2\",\n        },\n    ],\n});\n```\n```python\nimport pulumi\nimport json\nimport pulumi_consul as consul\n\nweb = consul.ConfigEntry(\"web\",\n    name=\"web\",\n    kind=\"service-defaults\",\n    config_json=json.dumps({\n        \"Protocol\": \"http\",\n        \"Expose\": {},\n        \"MeshGateway\": {},\n        \"TransparentProxy\": {},\n    }))\nservice_resolver = consul.ConfigEntryServiceResolver(\"service_resolver\",\n    name=\"service-resolver\",\n    default_subset=\"v1\",\n    subsets=[\n        {\n            \"name\": \"v1\",\n            \"filter\": \"Service.Meta.version == v1\",\n        },\n        {\n            \"name\": \"v2\",\n            \"filter\": \"Service.Meta.version == v2\",\n        },\n    ])\nfoo = consul.ConfigEntryServiceSplitter(\"foo\",\n    name=service_resolver.name,\n    meta={\n        \"key\": \"value\",\n    },\n    splits=[\n        {\n            \"weight\": 80,\n            \"service\": \"web\",\n            \"service_subset\": \"v1\",\n            \"request_headers\": {\n                \"set\": {\n                    \"x-web-version\": \"from-v1\",\n                },\n            },\n            \"response_headers\": {\n                \"set\": {\n                    \"x-web-version\": \"to-v1\",\n                },\n            },\n        },\n        {\n            \"weight\": 10,\n            \"service\": \"web\",\n            \"service_subset\": \"v2\",\n            \"request_headers\": {\n                \"set\": {\n                    \"x-web-version\": \"from-v2\",\n                },\n            },\n            \"response_headers\": {\n                \"set\": {\n                    \"x-web-version\": \"to-v2\",\n                },\n            },\n        },\n        {\n            \"weight\": 10,\n            \"service\": \"web\",\n            \"service_subset\": \"v2\",\n        },\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var web = new Consul.ConfigEntry(\"web\", new()\n    {\n        Name = \"web\",\n        Kind = \"service-defaults\",\n        ConfigJson = JsonSerializer.Serialize(new Dictionary\u003cstring, object?\u003e\n        {\n            [\"Protocol\"] = \"http\",\n            [\"Expose\"] = new Dictionary\u003cstring, object?\u003e\n            {\n            },\n            [\"MeshGateway\"] = new Dictionary\u003cstring, object?\u003e\n            {\n            },\n            [\"TransparentProxy\"] = new Dictionary\u003cstring, object?\u003e\n            {\n            },\n        }),\n    });\n\n    var serviceResolver = new Consul.ConfigEntryServiceResolver(\"service_resolver\", new()\n    {\n        Name = \"service-resolver\",\n        DefaultSubset = \"v1\",\n        Subsets = new[]\n        {\n            new Consul.Inputs.ConfigEntryServiceResolverSubsetArgs\n            {\n                Name = \"v1\",\n                Filter = \"Service.Meta.version == v1\",\n            },\n            new Consul.Inputs.ConfigEntryServiceResolverSubsetArgs\n            {\n                Name = \"v2\",\n                Filter = \"Service.Meta.version == v2\",\n            },\n        },\n    });\n\n    var foo = new Consul.ConfigEntryServiceSplitter(\"foo\", new()\n    {\n        Name = serviceResolver.Name,\n        Meta = \n        {\n            { \"key\", \"value\" },\n        },\n        Splits = new[]\n        {\n            new Consul.Inputs.ConfigEntryServiceSplitterSplitArgs\n            {\n                Weight = 80,\n                Service = \"web\",\n                ServiceSubset = \"v1\",\n                RequestHeaders = new Consul.Inputs.ConfigEntryServiceSplitterSplitRequestHeadersArgs\n                {\n                    Set = \n                    {\n                        { \"x-web-version\", \"from-v1\" },\n                    },\n                },\n                ResponseHeaders = new Consul.Inputs.ConfigEntryServiceSplitterSplitResponseHeadersArgs\n                {\n                    Set = \n                    {\n                        { \"x-web-version\", \"to-v1\" },\n                    },\n                },\n            },\n            new Consul.Inputs.ConfigEntryServiceSplitterSplitArgs\n            {\n                Weight = 10,\n                Service = \"web\",\n                ServiceSubset = \"v2\",\n                RequestHeaders = new Consul.Inputs.ConfigEntryServiceSplitterSplitRequestHeadersArgs\n                {\n                    Set = \n                    {\n                        { \"x-web-version\", \"from-v2\" },\n                    },\n                },\n                ResponseHeaders = new Consul.Inputs.ConfigEntryServiceSplitterSplitResponseHeadersArgs\n                {\n                    Set = \n                    {\n                        { \"x-web-version\", \"to-v2\" },\n                    },\n                },\n            },\n            new Consul.Inputs.ConfigEntryServiceSplitterSplitArgs\n            {\n                Weight = 10,\n                Service = \"web\",\n                ServiceSubset = \"v2\",\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttmpJSON0, err := json.Marshal(map[string]interface{}{\n\t\t\t\"Protocol\":         \"http\",\n\t\t\t\"Expose\":           map[string]interface{}{},\n\t\t\t\"MeshGateway\":      map[string]interface{}{},\n\t\t\t\"TransparentProxy\": map[string]interface{}{},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tjson0 := string(tmpJSON0)\n\t\t_, err = consul.NewConfigEntry(ctx, \"web\", \u0026consul.ConfigEntryArgs{\n\t\t\tName:       pulumi.String(\"web\"),\n\t\t\tKind:       pulumi.String(\"service-defaults\"),\n\t\t\tConfigJson: pulumi.String(json0),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tserviceResolver, err := consul.NewConfigEntryServiceResolver(ctx, \"service_resolver\", \u0026consul.ConfigEntryServiceResolverArgs{\n\t\t\tName:          pulumi.String(\"service-resolver\"),\n\t\t\tDefaultSubset: pulumi.String(\"v1\"),\n\t\t\tSubsets: consul.ConfigEntryServiceResolverSubsetArray{\n\t\t\t\t\u0026consul.ConfigEntryServiceResolverSubsetArgs{\n\t\t\t\t\tName:   pulumi.String(\"v1\"),\n\t\t\t\t\tFilter: pulumi.String(\"Service.Meta.version == v1\"),\n\t\t\t\t},\n\t\t\t\t\u0026consul.ConfigEntryServiceResolverSubsetArgs{\n\t\t\t\t\tName:   pulumi.String(\"v2\"),\n\t\t\t\t\tFilter: pulumi.String(\"Service.Meta.version == v2\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = consul.NewConfigEntryServiceSplitter(ctx, \"foo\", \u0026consul.ConfigEntryServiceSplitterArgs{\n\t\t\tName: serviceResolver.Name,\n\t\t\tMeta: pulumi.StringMap{\n\t\t\t\t\"key\": pulumi.String(\"value\"),\n\t\t\t},\n\t\t\tSplits: consul.ConfigEntryServiceSplitterSplitArray{\n\t\t\t\t\u0026consul.ConfigEntryServiceSplitterSplitArgs{\n\t\t\t\t\tWeight:        pulumi.Float64(80),\n\t\t\t\t\tService:       pulumi.String(\"web\"),\n\t\t\t\t\tServiceSubset: pulumi.String(\"v1\"),\n\t\t\t\t\tRequestHeaders: \u0026consul.ConfigEntryServiceSplitterSplitRequestHeadersArgs{\n\t\t\t\t\t\tSet: pulumi.StringMap{\n\t\t\t\t\t\t\t\"x-web-version\": pulumi.String(\"from-v1\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tResponseHeaders: \u0026consul.ConfigEntryServiceSplitterSplitResponseHeadersArgs{\n\t\t\t\t\t\tSet: pulumi.StringMap{\n\t\t\t\t\t\t\t\"x-web-version\": pulumi.String(\"to-v1\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026consul.ConfigEntryServiceSplitterSplitArgs{\n\t\t\t\t\tWeight:        pulumi.Float64(10),\n\t\t\t\t\tService:       pulumi.String(\"web\"),\n\t\t\t\t\tServiceSubset: pulumi.String(\"v2\"),\n\t\t\t\t\tRequestHeaders: \u0026consul.ConfigEntryServiceSplitterSplitRequestHeadersArgs{\n\t\t\t\t\t\tSet: pulumi.StringMap{\n\t\t\t\t\t\t\t\"x-web-version\": pulumi.String(\"from-v2\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tResponseHeaders: \u0026consul.ConfigEntryServiceSplitterSplitResponseHeadersArgs{\n\t\t\t\t\t\tSet: pulumi.StringMap{\n\t\t\t\t\t\t\t\"x-web-version\": pulumi.String(\"to-v2\"),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\u0026consul.ConfigEntryServiceSplitterSplitArgs{\n\t\t\t\t\tWeight:        pulumi.Float64(10),\n\t\t\t\t\tService:       pulumi.String(\"web\"),\n\t\t\t\t\tServiceSubset: pulumi.String(\"v2\"),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConfigEntry;\nimport com.pulumi.consul.ConfigEntryArgs;\nimport com.pulumi.consul.ConfigEntryServiceResolver;\nimport com.pulumi.consul.ConfigEntryServiceResolverArgs;\nimport com.pulumi.consul.inputs.ConfigEntryServiceResolverSubsetArgs;\nimport com.pulumi.consul.ConfigEntryServiceSplitter;\nimport com.pulumi.consul.ConfigEntryServiceSplitterArgs;\nimport com.pulumi.consul.inputs.ConfigEntryServiceSplitterSplitArgs;\nimport com.pulumi.consul.inputs.ConfigEntryServiceSplitterSplitRequestHeadersArgs;\nimport com.pulumi.consul.inputs.ConfigEntryServiceSplitterSplitResponseHeadersArgs;\nimport static com.pulumi.codegen.internal.Serialization.*;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var web = new ConfigEntry(\"web\", ConfigEntryArgs.builder()\n            .name(\"web\")\n            .kind(\"service-defaults\")\n            .configJson(serializeJson(\n                jsonObject(\n                    jsonProperty(\"Protocol\", \"http\"),\n                    jsonProperty(\"Expose\", jsonObject(\n\n                    )),\n                    jsonProperty(\"MeshGateway\", jsonObject(\n\n                    )),\n                    jsonProperty(\"TransparentProxy\", jsonObject(\n\n                    ))\n                )))\n            .build());\n\n        var serviceResolver = new ConfigEntryServiceResolver(\"serviceResolver\", ConfigEntryServiceResolverArgs.builder()\n            .name(\"service-resolver\")\n            .defaultSubset(\"v1\")\n            .subsets(            \n                ConfigEntryServiceResolverSubsetArgs.builder()\n                    .name(\"v1\")\n                    .filter(\"Service.Meta.version == v1\")\n                    .build(),\n                ConfigEntryServiceResolverSubsetArgs.builder()\n                    .name(\"v2\")\n                    .filter(\"Service.Meta.version == v2\")\n                    .build())\n            .build());\n\n        var foo = new ConfigEntryServiceSplitter(\"foo\", ConfigEntryServiceSplitterArgs.builder()\n            .name(serviceResolver.name())\n            .meta(Map.of(\"key\", \"value\"))\n            .splits(            \n                ConfigEntryServiceSplitterSplitArgs.builder()\n                    .weight(80.0)\n                    .service(\"web\")\n                    .serviceSubset(\"v1\")\n                    .requestHeaders(ConfigEntryServiceSplitterSplitRequestHeadersArgs.builder()\n                        .set(Map.of(\"x-web-version\", \"from-v1\"))\n                        .build())\n                    .responseHeaders(ConfigEntryServiceSplitterSplitResponseHeadersArgs.builder()\n                        .set(Map.of(\"x-web-version\", \"to-v1\"))\n                        .build())\n                    .build(),\n                ConfigEntryServiceSplitterSplitArgs.builder()\n                    .weight(10.0)\n                    .service(\"web\")\n                    .serviceSubset(\"v2\")\n                    .requestHeaders(ConfigEntryServiceSplitterSplitRequestHeadersArgs.builder()\n                        .set(Map.of(\"x-web-version\", \"from-v2\"))\n                        .build())\n                    .responseHeaders(ConfigEntryServiceSplitterSplitResponseHeadersArgs.builder()\n                        .set(Map.of(\"x-web-version\", \"to-v2\"))\n                        .build())\n                    .build(),\n                ConfigEntryServiceSplitterSplitArgs.builder()\n                    .weight(10.0)\n                    .service(\"web\")\n                    .serviceSubset(\"v2\")\n                    .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  web:\n    type: consul:ConfigEntry\n    properties:\n      name: web\n      kind: service-defaults\n      configJson:\n        fn::toJSON:\n          Protocol: http\n          Expose: {}\n          MeshGateway: {}\n          TransparentProxy: {}\n  serviceResolver:\n    type: consul:ConfigEntryServiceResolver\n    name: service_resolver\n    properties:\n      name: service-resolver\n      defaultSubset: v1\n      subsets:\n        - name: v1\n          filter: Service.Meta.version == v1\n        - name: v2\n          filter: Service.Meta.version == v2\n  foo:\n    type: consul:ConfigEntryServiceSplitter\n    properties:\n      name: ${serviceResolver.name}\n      meta:\n        key: value\n      splits:\n        - weight: 80\n          service: web\n          serviceSubset: v1\n          requestHeaders:\n            set:\n              x-web-version: from-v1\n          responseHeaders:\n            set:\n              x-web-version: to-v1\n        - weight: 10\n          service: web\n          serviceSubset: v2\n          requestHeaders:\n            set:\n              x-web-version: from-v2\n          responseHeaders:\n            set:\n              x-web-version: to-v2\n        - weight: 10\n          service: web\n          serviceSubset: v2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import consul:index/configEntryServiceSplitter:ConfigEntryServiceSplitter foo web\n```\n\n",
            "properties": {
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies key-value pairs to add to the KV store.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies a name for the configuration entry.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "Specifies the namespace to apply the configuration entry.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "Specifies the admin partition to apply the configuration entry.\n"
                },
                "splits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceSplitterSplit:ConfigEntryServiceSplitterSplit"
                    },
                    "description": "Defines how much traffic to send to sets of service instances during a traffic split.\n"
                }
            },
            "required": [
                "name",
                "splits"
            ],
            "inputProperties": {
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies key-value pairs to add to the KV store.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Specifies a name for the configuration entry.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "Specifies the namespace to apply the configuration entry.\n",
                    "willReplaceOnChanges": true
                },
                "partition": {
                    "type": "string",
                    "description": "Specifies the admin partition to apply the configuration entry.\n",
                    "willReplaceOnChanges": true
                },
                "splits": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ConfigEntryServiceSplitterSplit:ConfigEntryServiceSplitterSplit"
                    },
                    "description": "Defines how much traffic to send to sets of service instances during a traffic split.\n"
                }
            },
            "requiredInputs": [
                "splits"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ConfigEntryServiceSplitter resources.\n",
                "properties": {
                    "meta": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Specifies key-value pairs to add to the KV store.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Specifies a name for the configuration entry.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "Specifies the namespace to apply the configuration entry.\n",
                        "willReplaceOnChanges": true
                    },
                    "partition": {
                        "type": "string",
                        "description": "Specifies the admin partition to apply the configuration entry.\n",
                        "willReplaceOnChanges": true
                    },
                    "splits": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/ConfigEntryServiceSplitterSplit:ConfigEntryServiceSplitterSplit"
                        },
                        "description": "Defines how much traffic to send to sets of service instances during a traffic split.\n"
                    }
                },
                "type": "object"
            }
        },
        "consul:index/configEntryV2ExportedServices:ConfigEntryV2ExportedServices": {
            "properties": {
                "kind": {
                    "type": "string",
                    "description": "The kind of exported services config (ExportedServices, NamespaceExportedServices, PartitionExportedServices).\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the config entry to read.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace the config entry is associated with.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "The partition the config entry is associated with.\n"
                },
                "partitionConsumers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The exported service partition consumers.\n"
                },
                "peerConsumers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The exported service peer consumers.\n"
                },
                "samenessGroupConsumers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The exported service sameness group consumers.\n"
                },
                "services": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The exported services.\n"
                }
            },
            "required": [
                "kind",
                "name",
                "partition"
            ],
            "inputProperties": {
                "kind": {
                    "type": "string",
                    "description": "The kind of exported services config (ExportedServices, NamespaceExportedServices, PartitionExportedServices).\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the config entry to read.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace the config entry is associated with.\n",
                    "willReplaceOnChanges": true
                },
                "partition": {
                    "type": "string",
                    "description": "The partition the config entry is associated with.\n",
                    "willReplaceOnChanges": true
                },
                "partitionConsumers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The exported service partition consumers.\n"
                },
                "peerConsumers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The exported service peer consumers.\n"
                },
                "samenessGroupConsumers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The exported service sameness group consumers.\n"
                },
                "services": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The exported services.\n"
                }
            },
            "requiredInputs": [
                "kind",
                "partition"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ConfigEntryV2ExportedServices resources.\n",
                "properties": {
                    "kind": {
                        "type": "string",
                        "description": "The kind of exported services config (ExportedServices, NamespaceExportedServices, PartitionExportedServices).\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the config entry to read.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace the config entry is associated with.\n",
                        "willReplaceOnChanges": true
                    },
                    "partition": {
                        "type": "string",
                        "description": "The partition the config entry is associated with.\n",
                        "willReplaceOnChanges": true
                    },
                    "partitionConsumers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The exported service partition consumers.\n"
                    },
                    "peerConsumers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The exported service peer consumers.\n"
                    },
                    "samenessGroupConsumers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The exported service sameness group consumers.\n"
                    },
                    "services": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The exported services.\n"
                    }
                },
                "type": "object"
            }
        },
        "consul:index/intention:Intention": {
            "description": "[Intentions](https://www.consul.io/docs/connect/intentions.html) are used to define\nrules for which services may connect to one another when using [Consul Connect](https://www.consul.io/docs/connect/index.html).\n\n\u003e **NOTE:** This resource is appropriate for managing legacy intentions in\nConsul version 1.8 and earlier. As of Consul 1.9, intentions should be managed\nusing the [`service-intentions`](https://www.consul.io/docs/connect/intentions)\nconfiguration entry. It is recommended to migrate from the `consul.Intention`\nresource to `consul.ConfigEntry` when running Consul 1.9 and later.\n\nIt is appropriate to either reference existing services, or specify non-existent services\nthat will be created in the future when creating intentions. This resource can be used\nin conjunction with the `consul.Service` datasource when referencing services\nregistered on nodes that have a running Consul agent.\n\n## Example Usage\n\nCreate a simplest intention with static service names:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst database = new consul.Intention(\"database\", {\n    sourceName: \"api\",\n    destinationName: \"db\",\n    action: \"allow\",\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\ndatabase = consul.Intention(\"database\",\n    source_name=\"api\",\n    destination_name=\"db\",\n    action=\"allow\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var database = new Consul.Intention(\"database\", new()\n    {\n        SourceName = \"api\",\n        DestinationName = \"db\",\n        Action = \"allow\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.NewIntention(ctx, \"database\", \u0026consul.IntentionArgs{\n\t\t\tSourceName:      pulumi.String(\"api\"),\n\t\t\tDestinationName: pulumi.String(\"db\"),\n\t\t\tAction:          pulumi.String(\"allow\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.Intention;\nimport com.pulumi.consul.IntentionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var database = new Intention(\"database\", IntentionArgs.builder()\n            .sourceName(\"api\")\n            .destinationName(\"db\")\n            .action(\"allow\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  database:\n    type: consul:Intention\n    properties:\n      sourceName: api\n      destinationName: db\n      action: allow\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nReferencing a known service via a datasource:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst database = new consul.Intention(\"database\", {\n    sourceName: \"api\",\n    destinationName: pgConsulService.name,\n    action: \"allow\",\n});\nconst pg = consul.getService({\n    name: \"postgresql\",\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\ndatabase = consul.Intention(\"database\",\n    source_name=\"api\",\n    destination_name=pg_consul_service[\"name\"],\n    action=\"allow\")\npg = consul.get_service(name=\"postgresql\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var database = new Consul.Intention(\"database\", new()\n    {\n        SourceName = \"api\",\n        DestinationName = pgConsulService.Name,\n        Action = \"allow\",\n    });\n\n    var pg = Consul.GetService.Invoke(new()\n    {\n        Name = \"postgresql\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.NewIntention(ctx, \"database\", \u0026consul.IntentionArgs{\n\t\t\tSourceName:      pulumi.String(\"api\"),\n\t\t\tDestinationName: pulumi.Any(pgConsulService.Name),\n\t\t\tAction:          pulumi.String(\"allow\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = consul.LookupService(ctx, \u0026consul.LookupServiceArgs{\n\t\t\tName: \"postgresql\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.Intention;\nimport com.pulumi.consul.IntentionArgs;\nimport com.pulumi.consul.ConsulFunctions;\nimport com.pulumi.consul.inputs.GetServiceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var database = new Intention(\"database\", IntentionArgs.builder()\n            .sourceName(\"api\")\n            .destinationName(pgConsulService.name())\n            .action(\"allow\")\n            .build());\n\n        final var pg = ConsulFunctions.getService(GetServiceArgs.builder()\n            .name(\"postgresql\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  database:\n    type: consul:Intention\n    properties:\n      sourceName: api\n      destinationName: ${pgConsulService.name}\n      action: allow\nvariables:\n  pg:\n    fn::invoke:\n      function: consul:getService\n      arguments:\n        name: postgresql\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n`consul_intention` can be imported:\n\n```sh\n$ pulumi import consul:index/intention:Intention database 657a57d6-0d56-57e2-31cb-e9f1ed3c18dd\n```\n",
            "properties": {
                "action": {
                    "type": "string",
                    "description": "The intention action. Must be one of `allow` or `deny`.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n"
                },
                "description": {
                    "type": "string",
                    "description": "Optional description that can be used by Consul\ntooling, but is not used internally.\n"
                },
                "destinationName": {
                    "type": "string",
                    "description": "The name of the destination service for the intention. This\nservice does not have to exist.\n"
                },
                "destinationNamespace": {
                    "type": "string",
                    "description": "The destination\nnamespace of the intention.\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key/value pairs that are opaque to Consul and are associated\nwith the intention.\n"
                },
                "sourceName": {
                    "type": "string",
                    "description": "The name of the source service for the intention. This\nservice does not have to exist.\n"
                },
                "sourceNamespace": {
                    "type": "string",
                    "description": "The source namespace of the\nintention.\n"
                }
            },
            "required": [
                "action",
                "datacenter",
                "destinationName",
                "sourceName"
            ],
            "inputProperties": {
                "action": {
                    "type": "string",
                    "description": "The intention action. Must be one of `allow` or `deny`.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n",
                    "willReplaceOnChanges": true
                },
                "description": {
                    "type": "string",
                    "description": "Optional description that can be used by Consul\ntooling, but is not used internally.\n"
                },
                "destinationName": {
                    "type": "string",
                    "description": "The name of the destination service for the intention. This\nservice does not have to exist.\n",
                    "willReplaceOnChanges": true
                },
                "destinationNamespace": {
                    "type": "string",
                    "description": "The destination\nnamespace of the intention.\n",
                    "willReplaceOnChanges": true
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key/value pairs that are opaque to Consul and are associated\nwith the intention.\n"
                },
                "sourceName": {
                    "type": "string",
                    "description": "The name of the source service for the intention. This\nservice does not have to exist.\n"
                },
                "sourceNamespace": {
                    "type": "string",
                    "description": "The source namespace of the\nintention.\n"
                }
            },
            "requiredInputs": [
                "action",
                "destinationName",
                "sourceName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Intention resources.\n",
                "properties": {
                    "action": {
                        "type": "string",
                        "description": "The intention action. Must be one of `allow` or `deny`.\n"
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n",
                        "willReplaceOnChanges": true
                    },
                    "description": {
                        "type": "string",
                        "description": "Optional description that can be used by Consul\ntooling, but is not used internally.\n"
                    },
                    "destinationName": {
                        "type": "string",
                        "description": "The name of the destination service for the intention. This\nservice does not have to exist.\n",
                        "willReplaceOnChanges": true
                    },
                    "destinationNamespace": {
                        "type": "string",
                        "description": "The destination\nnamespace of the intention.\n",
                        "willReplaceOnChanges": true
                    },
                    "meta": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Key/value pairs that are opaque to Consul and are associated\nwith the intention.\n"
                    },
                    "sourceName": {
                        "type": "string",
                        "description": "The name of the source service for the intention. This\nservice does not have to exist.\n"
                    },
                    "sourceNamespace": {
                        "type": "string",
                        "description": "The source namespace of the\nintention.\n"
                    }
                },
                "type": "object"
            }
        },
        "consul:index/keyPrefix:KeyPrefix": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst myappConfig = new consul.KeyPrefix(\"myapp_config\", {\n    datacenter: \"nyc1\",\n    token: \"abcd\",\n    pathPrefix: \"myapp/config/\",\n    subkeys: {\n        elb_cname: appAwsElb.dnsName,\n        s3_bucket_name: appAwsS3Bucket.bucket,\n        \"database/hostname\": app.address,\n        \"database/port\": app.port,\n        \"database/username\": app.username,\n        \"database/name\": app.name,\n    },\n    subkeyCollection: [{\n        path: \"database/password\",\n        value: app.password,\n        flags: 2,\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\nmyapp_config = consul.KeyPrefix(\"myapp_config\",\n    datacenter=\"nyc1\",\n    token=\"abcd\",\n    path_prefix=\"myapp/config/\",\n    subkeys={\n        \"elb_cname\": app_aws_elb[\"dnsName\"],\n        \"s3_bucket_name\": app_aws_s3_bucket[\"bucket\"],\n        \"database/hostname\": app[\"address\"],\n        \"database/port\": app[\"port\"],\n        \"database/username\": app[\"username\"],\n        \"database/name\": app[\"name\"],\n    },\n    subkey_collection=[{\n        \"path\": \"database/password\",\n        \"value\": app[\"password\"],\n        \"flags\": 2,\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var myappConfig = new Consul.KeyPrefix(\"myapp_config\", new()\n    {\n        Datacenter = \"nyc1\",\n        Token = \"abcd\",\n        PathPrefix = \"myapp/config/\",\n        Subkeys = \n        {\n            { \"elb_cname\", appAwsElb.DnsName },\n            { \"s3_bucket_name\", appAwsS3Bucket.Bucket },\n            { \"database/hostname\", app.Address },\n            { \"database/port\", app.Port },\n            { \"database/username\", app.Username },\n            { \"database/name\", app.Name },\n        },\n        SubkeyCollection = new[]\n        {\n            new Consul.Inputs.KeyPrefixSubkeyCollectionArgs\n            {\n                Path = \"database/password\",\n                Value = app.Password,\n                Flags = 2,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.NewKeyPrefix(ctx, \"myapp_config\", \u0026consul.KeyPrefixArgs{\n\t\t\tDatacenter: pulumi.String(\"nyc1\"),\n\t\t\tToken:      pulumi.String(\"abcd\"),\n\t\t\tPathPrefix: pulumi.String(\"myapp/config/\"),\n\t\t\tSubkeys: pulumi.StringMap{\n\t\t\t\t\"elb_cname\":         pulumi.Any(appAwsElb.DnsName),\n\t\t\t\t\"s3_bucket_name\":    pulumi.Any(appAwsS3Bucket.Bucket),\n\t\t\t\t\"database/hostname\": pulumi.Any(app.Address),\n\t\t\t\t\"database/port\":     pulumi.Any(app.Port),\n\t\t\t\t\"database/username\": pulumi.Any(app.Username),\n\t\t\t\t\"database/name\":     pulumi.Any(app.Name),\n\t\t\t},\n\t\t\tSubkeyCollection: consul.KeyPrefixSubkeyCollectionArray{\n\t\t\t\t\u0026consul.KeyPrefixSubkeyCollectionArgs{\n\t\t\t\t\tPath:  pulumi.String(\"database/password\"),\n\t\t\t\t\tValue: pulumi.Any(app.Password),\n\t\t\t\t\tFlags: pulumi.Int(2),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.KeyPrefix;\nimport com.pulumi.consul.KeyPrefixArgs;\nimport com.pulumi.consul.inputs.KeyPrefixSubkeyCollectionArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var myappConfig = new KeyPrefix(\"myappConfig\", KeyPrefixArgs.builder()\n            .datacenter(\"nyc1\")\n            .token(\"abcd\")\n            .pathPrefix(\"myapp/config/\")\n            .subkeys(Map.ofEntries(\n                Map.entry(\"elb_cname\", appAwsElb.dnsName()),\n                Map.entry(\"s3_bucket_name\", appAwsS3Bucket.bucket()),\n                Map.entry(\"database/hostname\", app.address()),\n                Map.entry(\"database/port\", app.port()),\n                Map.entry(\"database/username\", app.username()),\n                Map.entry(\"database/name\", app.name())\n            ))\n            .subkeyCollection(KeyPrefixSubkeyCollectionArgs.builder()\n                .path(\"database/password\")\n                .value(app.password())\n                .flags(2)\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  myappConfig:\n    type: consul:KeyPrefix\n    name: myapp_config\n    properties:\n      datacenter: nyc1\n      token: abcd\n      pathPrefix: myapp/config/\n      subkeys:\n        elb_cname: ${appAwsElb.dnsName}\n        s3_bucket_name: ${appAwsS3Bucket.bucket}\n        database/hostname: ${app.address}\n        database/port: ${app.port}\n        database/username: ${app.username}\n        database/name: ${app.name}\n      subkeyCollection:\n        - path: database/password\n          value: ${app.password}\n          flags: 2\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n`consul_key_prefix` can be imported. This is useful when the path already exists and\nyou know all keys in path should be managed by Terraform.\n\n```sh\n$ pulumi import consul:index/keyPrefix:KeyPrefix myapp_config myapp/config/\n```\n",
            "properties": {
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to create the keys within.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "The admin partition to create the keys within.\n"
                },
                "pathPrefix": {
                    "type": "string",
                    "description": "Specifies the common prefix shared by all keys\nthat will be managed by this resource instance. In most cases this will\nend with a slash, to manage a \"folder\" of keys.\n"
                },
                "subkeyCollection": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/KeyPrefixSubkeyCollection:KeyPrefixSubkeyCollection"
                    },
                    "description": "A subkey to add. Supported values documented below.\nMultiple blocks supported.\n"
                },
                "subkeys": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A mapping from subkey name (which will be appended\nto the given `path_prefix`) to the value that should be stored at that key.\nUse slashes, as shown in the above example, to create \"sub-folders\" under\nthe given path prefix.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The ACL token to use. This overrides the\ntoken that the agent provides by default.\n",
                    "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                    "secret": true
                }
            },
            "required": [
                "datacenter",
                "pathPrefix"
            ],
            "inputProperties": {
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to create the keys within.\n",
                    "willReplaceOnChanges": true
                },
                "partition": {
                    "type": "string",
                    "description": "The admin partition to create the keys within.\n",
                    "willReplaceOnChanges": true
                },
                "pathPrefix": {
                    "type": "string",
                    "description": "Specifies the common prefix shared by all keys\nthat will be managed by this resource instance. In most cases this will\nend with a slash, to manage a \"folder\" of keys.\n",
                    "willReplaceOnChanges": true
                },
                "subkeyCollection": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/KeyPrefixSubkeyCollection:KeyPrefixSubkeyCollection"
                    },
                    "description": "A subkey to add. Supported values documented below.\nMultiple blocks supported.\n"
                },
                "subkeys": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A mapping from subkey name (which will be appended\nto the given `path_prefix`) to the value that should be stored at that key.\nUse slashes, as shown in the above example, to create \"sub-folders\" under\nthe given path prefix.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The ACL token to use. This overrides the\ntoken that the agent provides by default.\n",
                    "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                    "secret": true
                }
            },
            "requiredInputs": [
                "pathPrefix"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering KeyPrefix resources.\n",
                "properties": {
                    "datacenter": {
                        "type": "string",
                        "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to create the keys within.\n",
                        "willReplaceOnChanges": true
                    },
                    "partition": {
                        "type": "string",
                        "description": "The admin partition to create the keys within.\n",
                        "willReplaceOnChanges": true
                    },
                    "pathPrefix": {
                        "type": "string",
                        "description": "Specifies the common prefix shared by all keys\nthat will be managed by this resource instance. In most cases this will\nend with a slash, to manage a \"folder\" of keys.\n",
                        "willReplaceOnChanges": true
                    },
                    "subkeyCollection": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/KeyPrefixSubkeyCollection:KeyPrefixSubkeyCollection"
                        },
                        "description": "A subkey to add. Supported values documented below.\nMultiple blocks supported.\n"
                    },
                    "subkeys": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A mapping from subkey name (which will be appended\nto the given `path_prefix`) to the value that should be stored at that key.\nUse slashes, as shown in the above example, to create \"sub-folders\" under\nthe given path prefix.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The ACL token to use. This overrides the\ntoken that the agent provides by default.\n",
                        "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "consul:index/keys:Keys": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst app = new consul.Keys(\"app\", {\n    datacenter: \"nyc1\",\n    token: \"abcd\",\n    keys: [{\n        path: \"service/app/elb_address\",\n        value: appAwsElb.dnsName,\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\napp = consul.Keys(\"app\",\n    datacenter=\"nyc1\",\n    token=\"abcd\",\n    keys=[{\n        \"path\": \"service/app/elb_address\",\n        \"value\": app_aws_elb[\"dnsName\"],\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var app = new Consul.Keys(\"app\", new()\n    {\n        Datacenter = \"nyc1\",\n        Token = \"abcd\",\n        KeysCollection = new[]\n        {\n            new Consul.Inputs.KeysKeyArgs\n            {\n                Path = \"service/app/elb_address\",\n                Value = appAwsElb.DnsName,\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.NewKeys(ctx, \"app\", \u0026consul.KeysArgs{\n\t\t\tDatacenter: pulumi.String(\"nyc1\"),\n\t\t\tToken:      pulumi.String(\"abcd\"),\n\t\t\tKeys: consul.KeysKeyArray{\n\t\t\t\t\u0026consul.KeysKeyArgs{\n\t\t\t\t\tPath:  pulumi.String(\"service/app/elb_address\"),\n\t\t\t\t\tValue: pulumi.Any(appAwsElb.DnsName),\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.Keys;\nimport com.pulumi.consul.KeysArgs;\nimport com.pulumi.consul.inputs.KeysKeyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var app = new Keys(\"app\", KeysArgs.builder()\n            .datacenter(\"nyc1\")\n            .token(\"abcd\")\n            .keys(KeysKeyArgs.builder()\n                .path(\"service/app/elb_address\")\n                .value(appAwsElb.dnsName())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  app:\n    type: consul:Keys\n    properties:\n      datacenter: nyc1\n      token: abcd\n      keys:\n        - path: service/app/elb_address\n          value: ${appAwsElb.dnsName}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n"
                },
                "keys": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/KeysKey:KeysKey"
                    },
                    "description": "Specifies a key in Consul to be written.\nSupported values documented below.\n",
                    "language": {
                        "csharp": {
                            "name": "KeysCollection"
                        }
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to create the keys within.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "The partition to create the keys within.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The ACL token to use. This overrides the\ntoken that the agent provides by default.\n",
                    "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                    "secret": true
                },
                "var": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                }
            },
            "required": [
                "datacenter",
                "var"
            ],
            "inputProperties": {
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n",
                    "willReplaceOnChanges": true
                },
                "keys": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/KeysKey:KeysKey"
                    },
                    "description": "Specifies a key in Consul to be written.\nSupported values documented below.\n",
                    "language": {
                        "csharp": {
                            "name": "KeysCollection"
                        }
                    }
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to create the keys within.\n",
                    "willReplaceOnChanges": true
                },
                "partition": {
                    "type": "string",
                    "description": "The partition to create the keys within.\n",
                    "willReplaceOnChanges": true
                },
                "token": {
                    "type": "string",
                    "description": "The ACL token to use. This overrides the\ntoken that the agent provides by default.\n",
                    "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                    "secret": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Keys resources.\n",
                "properties": {
                    "datacenter": {
                        "type": "string",
                        "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n",
                        "willReplaceOnChanges": true
                    },
                    "keys": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/KeysKey:KeysKey"
                        },
                        "description": "Specifies a key in Consul to be written.\nSupported values documented below.\n",
                        "language": {
                            "csharp": {
                                "name": "KeysCollection"
                            }
                        }
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to create the keys within.\n",
                        "willReplaceOnChanges": true
                    },
                    "partition": {
                        "type": "string",
                        "description": "The partition to create the keys within.\n",
                        "willReplaceOnChanges": true
                    },
                    "token": {
                        "type": "string",
                        "description": "The ACL token to use. This overrides the\ntoken that the agent provides by default.\n",
                        "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                        "secret": true
                    },
                    "var": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        }
                    }
                },
                "type": "object"
            }
        },
        "consul:index/license:License": {
            "description": "\u003e **NOTE:** This feature requires [Consul Enterprise](https://www.consul.io/docs/enterprise/index.html).\n\nThe `consul.License` resource provides datacenter-level management of\nthe Consul Enterprise license. If ACLs are enabled then a token with operator\nprivileges may be required in order to use this command.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\nimport * as std from \"@pulumi/std\";\n\nconst license = new consul.License(\"license\", {license: std.file({\n    input: \"license.hclic\",\n}).then(invoke =\u003e invoke.result)});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\nimport pulumi_std as std\n\nlicense = consul.License(\"license\", license=std.file(input=\"license.hclic\").result)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\nusing Std = Pulumi.Std;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var license = new Consul.License(\"license\", new()\n    {\n        ConsulLicense = Std.File.Invoke(new()\n        {\n            Input = \"license.hclic\",\n        }).Apply(invoke =\u003e invoke.Result),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi-std/sdk/go/std\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tinvokeFile, err := std.File(ctx, \u0026std.FileArgs{\n\t\t\tInput: \"license.hclic\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = consul.NewLicense(ctx, \"license\", \u0026consul.LicenseArgs{\n\t\t\tLicense: pulumi.String(invokeFile.Result),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.License;\nimport com.pulumi.consul.LicenseArgs;\nimport com.pulumi.std.StdFunctions;\nimport com.pulumi.std.inputs.FileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var license = new License(\"license\", LicenseArgs.builder()\n            .license(StdFunctions.file(FileArgs.builder()\n                .input(\"license.hclic\")\n                .build()).result())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  license:\n    type: consul:License\n    properties:\n      license:\n        fn::invoke:\n          function: std:file\n          arguments:\n            input: license.hclic\n          return: result\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "customerId": {
                    "type": "string",
                    "description": "The ID of the customer the license is attached to.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n"
                },
                "expirationTime": {
                    "type": "string",
                    "description": "The expiration time of the license.\n"
                },
                "features": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The features for which the license is valid.\n"
                },
                "installationId": {
                    "type": "string",
                    "description": "The ID of the current installation.\n"
                },
                "issueTime": {
                    "type": "string",
                    "description": "The date the license was issued.\n"
                },
                "license": {
                    "type": "string",
                    "description": "The Consul license to use.\n",
                    "language": {
                        "csharp": {
                            "name": "ConsulLicense"
                        }
                    },
                    "secret": true
                },
                "licenseId": {
                    "type": "string",
                    "description": "The ID of the license used.\n"
                },
                "product": {
                    "type": "string",
                    "description": "The product for which the license is valid.\n"
                },
                "startTime": {
                    "type": "string",
                    "description": "The start time of the license.\n"
                },
                "valid": {
                    "type": "boolean",
                    "description": "Whether the license is valid.\n"
                },
                "warnings": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of warning messages regarding the license validity.\n"
                }
            },
            "required": [
                "customerId",
                "expirationTime",
                "features",
                "installationId",
                "issueTime",
                "license",
                "licenseId",
                "product",
                "startTime",
                "valid",
                "warnings"
            ],
            "inputProperties": {
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n",
                    "willReplaceOnChanges": true
                },
                "license": {
                    "type": "string",
                    "description": "The Consul license to use.\n",
                    "language": {
                        "csharp": {
                            "name": "ConsulLicense"
                        }
                    },
                    "secret": true
                }
            },
            "requiredInputs": [
                "license"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering License resources.\n",
                "properties": {
                    "customerId": {
                        "type": "string",
                        "description": "The ID of the customer the license is attached to.\n"
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n",
                        "willReplaceOnChanges": true
                    },
                    "expirationTime": {
                        "type": "string",
                        "description": "The expiration time of the license.\n"
                    },
                    "features": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The features for which the license is valid.\n"
                    },
                    "installationId": {
                        "type": "string",
                        "description": "The ID of the current installation.\n"
                    },
                    "issueTime": {
                        "type": "string",
                        "description": "The date the license was issued.\n"
                    },
                    "license": {
                        "type": "string",
                        "description": "The Consul license to use.\n",
                        "language": {
                            "csharp": {
                                "name": "ConsulLicense"
                            }
                        },
                        "secret": true
                    },
                    "licenseId": {
                        "type": "string",
                        "description": "The ID of the license used.\n"
                    },
                    "product": {
                        "type": "string",
                        "description": "The product for which the license is valid.\n"
                    },
                    "startTime": {
                        "type": "string",
                        "description": "The start time of the license.\n"
                    },
                    "valid": {
                        "type": "boolean",
                        "description": "Whether the license is valid.\n"
                    },
                    "warnings": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of warning messages regarding the license validity.\n"
                    }
                },
                "type": "object"
            }
        },
        "consul:index/namespace:Namespace": {
            "description": "\u003e **NOTE:** This feature requires Consul Enterprise.\n\nThe `consul.Namespace` resource provides isolated [Consul Enterprise Namespaces](https://www.consul.io/docs/enterprise/namespaces/index.html).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst production = new consul.Namespace(\"production\", {\n    name: \"production\",\n    description: \"Production namespace\",\n    meta: {\n        foo: \"bar\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\nproduction = consul.Namespace(\"production\",\n    name=\"production\",\n    description=\"Production namespace\",\n    meta={\n        \"foo\": \"bar\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var production = new Consul.Namespace(\"production\", new()\n    {\n        Name = \"production\",\n        Description = \"Production namespace\",\n        Meta = \n        {\n            { \"foo\", \"bar\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.NewNamespace(ctx, \"production\", \u0026consul.NamespaceArgs{\n\t\t\tName:        pulumi.String(\"production\"),\n\t\t\tDescription: pulumi.String(\"Production namespace\"),\n\t\t\tMeta: pulumi.StringMap{\n\t\t\t\t\"foo\": pulumi.String(\"bar\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.Namespace;\nimport com.pulumi.consul.NamespaceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var production = new Namespace(\"production\", NamespaceArgs.builder()\n            .name(\"production\")\n            .description(\"Production namespace\")\n            .meta(Map.of(\"foo\", \"bar\"))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  production:\n    type: consul:Namespace\n    properties:\n      name: production\n      description: Production namespace\n      meta:\n        foo: bar\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n`consul_namespace` can be imported. This is useful to manage attributes of the\ndefault namespace that is created automatically:\n\n```sh\n$ pulumi import consul:index/namespace:Namespace default default\n```\n",
            "properties": {
                "description": {
                    "type": "string",
                    "description": "Free form namespace description.\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies arbitrary KV metadata to associate with the namespace.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The namespace name.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "The partition to create the namespace within.\n"
                },
                "policyDefaults": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of default policies that should be applied to all tokens created in this namespace.\n"
                },
                "roleDefaults": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of default roles that should be applied to all tokens created in this namespace.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "description": {
                    "type": "string",
                    "description": "Free form namespace description.\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies arbitrary KV metadata to associate with the namespace.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The namespace name.\n",
                    "willReplaceOnChanges": true
                },
                "partition": {
                    "type": "string",
                    "description": "The partition to create the namespace within.\n",
                    "willReplaceOnChanges": true
                },
                "policyDefaults": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of default policies that should be applied to all tokens created in this namespace.\n"
                },
                "roleDefaults": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of default roles that should be applied to all tokens created in this namespace.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Namespace resources.\n",
                "properties": {
                    "description": {
                        "type": "string",
                        "description": "Free form namespace description.\n"
                    },
                    "meta": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Specifies arbitrary KV metadata to associate with the namespace.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The namespace name.\n",
                        "willReplaceOnChanges": true
                    },
                    "partition": {
                        "type": "string",
                        "description": "The partition to create the namespace within.\n",
                        "willReplaceOnChanges": true
                    },
                    "policyDefaults": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of default policies that should be applied to all tokens created in this namespace.\n"
                    },
                    "roleDefaults": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of default roles that should be applied to all tokens created in this namespace.\n"
                    }
                },
                "type": "object"
            }
        },
        "consul:index/namespacePolicyAttachment:NamespacePolicyAttachment": {
            "description": "\n\n## Import\n\n`consul_namespace_policy_attachment` can be imported. This is especially useful\nto manage the policies attached to the `default` namespace:\n\n```sh\n$ pulumi import consul:index/namespacePolicyAttachment:NamespacePolicyAttachment default default:policy_name\n```\n",
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": "The namespace to attach the policy to.\n"
                },
                "policy": {
                    "type": "string",
                    "description": "The name of the policy attached to the namespace.\n"
                }
            },
            "required": [
                "namespace",
                "policy"
            ],
            "inputProperties": {
                "namespace": {
                    "type": "string",
                    "description": "The namespace to attach the policy to.\n",
                    "willReplaceOnChanges": true
                },
                "policy": {
                    "type": "string",
                    "description": "The name of the policy attached to the namespace.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "namespace",
                "policy"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NamespacePolicyAttachment resources.\n",
                "properties": {
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to attach the policy to.\n",
                        "willReplaceOnChanges": true
                    },
                    "policy": {
                        "type": "string",
                        "description": "The name of the policy attached to the namespace.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "consul:index/namespaceRoleAttachment:NamespaceRoleAttachment": {
            "description": "\n\n## Import\n\n`consul_namespace_role_attachment` can be imported. This is especially useful\nto manage the policies attached to the `default` namespace:\n\n```sh\n$ pulumi import consul:index/namespaceRoleAttachment:NamespaceRoleAttachment default default:role_name\n```\n",
            "properties": {
                "namespace": {
                    "type": "string",
                    "description": "The namespace to attach the role to.\n"
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role attached to the namespace.\n"
                }
            },
            "required": [
                "namespace",
                "role"
            ],
            "inputProperties": {
                "namespace": {
                    "type": "string",
                    "description": "The namespace to attach the role to.\n",
                    "willReplaceOnChanges": true
                },
                "role": {
                    "type": "string",
                    "description": "The name of the role attached to the namespace.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "namespace",
                "role"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NamespaceRoleAttachment resources.\n",
                "properties": {
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to attach the role to.\n",
                        "willReplaceOnChanges": true
                    },
                    "role": {
                        "type": "string",
                        "description": "The name of the role attached to the namespace.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "consul:index/networkArea:NetworkArea": {
            "description": "\u003e **NOTE:** This feature requires [Consul Enterprise](https://www.consul.io/docs/enterprise/index.html).\n\nThe `consul.NetworkArea` resource manages a relationship between servers in two\ndifferent Consul datacenters.\n\nUnlike Consul's WAN feature, network areas use just the server RPC port for\ncommunication, and relationships can be made between independent pairs of\ndatacenters, so not all servers need to be fully connected. This allows for\ncomplex topologies among Consul datacenters like hub/spoke and more general trees.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst dc2 = new consul.NetworkArea(\"dc2\", {\n    peerDatacenter: \"dc2\",\n    retryJoins: [\"1.2.3.4\"],\n    useTls: true,\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\ndc2 = consul.NetworkArea(\"dc2\",\n    peer_datacenter=\"dc2\",\n    retry_joins=[\"1.2.3.4\"],\n    use_tls=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dc2 = new Consul.NetworkArea(\"dc2\", new()\n    {\n        PeerDatacenter = \"dc2\",\n        RetryJoins = new[]\n        {\n            \"1.2.3.4\",\n        },\n        UseTls = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.NewNetworkArea(ctx, \"dc2\", \u0026consul.NetworkAreaArgs{\n\t\t\tPeerDatacenter: pulumi.String(\"dc2\"),\n\t\t\tRetryJoins: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"1.2.3.4\"),\n\t\t\t},\n\t\t\tUseTls: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.NetworkArea;\nimport com.pulumi.consul.NetworkAreaArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var dc2 = new NetworkArea(\"dc2\", NetworkAreaArgs.builder()\n            .peerDatacenter(\"dc2\")\n            .retryJoins(\"1.2.3.4\")\n            .useTls(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  dc2:\n    type: consul:NetworkArea\n    properties:\n      peerDatacenter: dc2\n      retryJoins:\n        - 1.2.3.4\n      useTls: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n"
                },
                "peerDatacenter": {
                    "type": "string",
                    "description": "The name of the Consul datacenter that will be\njoined to form the area.\n"
                },
                "retryJoins": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies a list of Consul servers to attempt to\njoin. Servers can be given as `IP`, `IP:port`, `hostname`, or `hostname:port`.\n"
                },
                "token": {
                    "type": "string",
                    "description": "The ACL token to use. This overrides the\ntoken that the agent provides by default.\n",
                    "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                    "secret": true
                },
                "useTls": {
                    "type": "boolean",
                    "description": "Specifies whether gossip over this area should be\nencrypted with TLS if possible. Defaults to `false`.\n"
                }
            },
            "required": [
                "datacenter",
                "peerDatacenter"
            ],
            "inputProperties": {
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n",
                    "willReplaceOnChanges": true
                },
                "peerDatacenter": {
                    "type": "string",
                    "description": "The name of the Consul datacenter that will be\njoined to form the area.\n",
                    "willReplaceOnChanges": true
                },
                "retryJoins": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies a list of Consul servers to attempt to\njoin. Servers can be given as `IP`, `IP:port`, `hostname`, or `hostname:port`.\n",
                    "willReplaceOnChanges": true
                },
                "token": {
                    "type": "string",
                    "description": "The ACL token to use. This overrides the\ntoken that the agent provides by default.\n",
                    "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                    "secret": true
                },
                "useTls": {
                    "type": "boolean",
                    "description": "Specifies whether gossip over this area should be\nencrypted with TLS if possible. Defaults to `false`.\n"
                }
            },
            "requiredInputs": [
                "peerDatacenter"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering NetworkArea resources.\n",
                "properties": {
                    "datacenter": {
                        "type": "string",
                        "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n",
                        "willReplaceOnChanges": true
                    },
                    "peerDatacenter": {
                        "type": "string",
                        "description": "The name of the Consul datacenter that will be\njoined to form the area.\n",
                        "willReplaceOnChanges": true
                    },
                    "retryJoins": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies a list of Consul servers to attempt to\njoin. Servers can be given as `IP`, `IP:port`, `hostname`, or `hostname:port`.\n",
                        "willReplaceOnChanges": true
                    },
                    "token": {
                        "type": "string",
                        "description": "The ACL token to use. This overrides the\ntoken that the agent provides by default.\n",
                        "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                        "secret": true
                    },
                    "useTls": {
                        "type": "boolean",
                        "description": "Specifies whether gossip over this area should be\nencrypted with TLS if possible. Defaults to `false`.\n"
                    }
                },
                "type": "object"
            }
        },
        "consul:index/node:Node": {
            "description": "Provides access to Node data in Consul. This can be used to define a\nnode. Currently, defining health checks is not supported.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst foobar = new consul.Node(\"foobar\", {\n    address: \"192.168.10.10\",\n    name: \"foobar\",\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\nfoobar = consul.Node(\"foobar\",\n    address=\"192.168.10.10\",\n    name=\"foobar\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var foobar = new Consul.Node(\"foobar\", new()\n    {\n        Address = \"192.168.10.10\",\n        Name = \"foobar\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.NewNode(ctx, \"foobar\", \u0026consul.NodeArgs{\n\t\t\tAddress: pulumi.String(\"192.168.10.10\"),\n\t\t\tName:    pulumi.String(\"foobar\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.Node;\nimport com.pulumi.consul.NodeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var foobar = new Node(\"foobar\", NodeArgs.builder()\n            .address(\"192.168.10.10\")\n            .name(\"foobar\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  foobar:\n    type: consul:Node\n    properties:\n      address: 192.168.10.10\n      name: foobar\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\nThe `consul_node` resource can be imported:\n\n```sh\n$ pulumi import consul:index/node:Node example node-name\n```\n",
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The address of the node being added to, or referenced in the catalog.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the agent's default datacenter and the datacenter in the provider setup.\n"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key/value pairs that are associated with the node.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the node being added to, or referenced in the catalog.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "The partition the node is associated with.\n"
                },
                "token": {
                    "type": "string",
                    "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                    "secret": true
                }
            },
            "required": [
                "address",
                "datacenter",
                "name"
            ],
            "inputProperties": {
                "address": {
                    "type": "string",
                    "description": "The address of the node being added to, or referenced in the catalog.\n",
                    "willReplaceOnChanges": true
                },
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the agent's default datacenter and the datacenter in the provider setup.\n",
                    "willReplaceOnChanges": true
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Key/value pairs that are associated with the node.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the node being added to, or referenced in the catalog.\n",
                    "willReplaceOnChanges": true
                },
                "partition": {
                    "type": "string",
                    "description": "The partition the node is associated with.\n",
                    "willReplaceOnChanges": true
                },
                "token": {
                    "type": "string",
                    "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                    "secret": true
                }
            },
            "requiredInputs": [
                "address"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Node resources.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The address of the node being added to, or referenced in the catalog.\n",
                        "willReplaceOnChanges": true
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The datacenter to use. This overrides the agent's default datacenter and the datacenter in the provider setup.\n",
                        "willReplaceOnChanges": true
                    },
                    "meta": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Key/value pairs that are associated with the node.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the node being added to, or referenced in the catalog.\n",
                        "willReplaceOnChanges": true
                    },
                    "partition": {
                        "type": "string",
                        "description": "The partition the node is associated with.\n",
                        "willReplaceOnChanges": true
                    },
                    "token": {
                        "type": "string",
                        "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "consul:index/peering:Peering": {
            "description": "[Cluster Peering](https://www.consul.io/docs/connect/cluster-peering) can be used to create connections between two or more independent clusters so that services deployed to different partitions or datacenters can communicate.\n\nThe `cluster_peering` resource can be used to establish the peering after a peering token has been generated.\n\n\u003e **Cluster peering is currently in technical preview:** Functionality associated with cluster peering is subject to change. You should never use the technical preview release in secure environments or production scenarios. Features in technical preview may have performance issues, scaling issues, and limited support.\n\nThe functionality described here is available only in Consul version 1.13.0 and later.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst eu_us = new consul.PeeringToken(\"eu-us\", {peerName: \"eu-cluster\"});\nconst eu_usPeering = new consul.Peering(\"eu-us\", {\n    peerName: \"eu-cluster\",\n    peeringToken: token.peeringToken,\n    meta: {\n        hello: \"world\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\neu_us = consul.PeeringToken(\"eu-us\", peer_name=\"eu-cluster\")\neu_us_peering = consul.Peering(\"eu-us\",\n    peer_name=\"eu-cluster\",\n    peering_token=token[\"peeringToken\"],\n    meta={\n        \"hello\": \"world\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var eu_us = new Consul.PeeringToken(\"eu-us\", new()\n    {\n        PeerName = \"eu-cluster\",\n    });\n\n    var eu_usPeering = new Consul.Peering(\"eu-us\", new()\n    {\n        PeerName = \"eu-cluster\",\n        PeeringToken = token.PeeringToken,\n        Meta = \n        {\n            { \"hello\", \"world\" },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.NewPeeringToken(ctx, \"eu-us\", \u0026consul.PeeringTokenArgs{\n\t\t\tPeerName: pulumi.String(\"eu-cluster\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = consul.NewPeering(ctx, \"eu-us\", \u0026consul.PeeringArgs{\n\t\t\tPeerName:     pulumi.String(\"eu-cluster\"),\n\t\t\tPeeringToken: pulumi.Any(token.PeeringToken),\n\t\t\tMeta: pulumi.StringMap{\n\t\t\t\t\"hello\": pulumi.String(\"world\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.PeeringToken;\nimport com.pulumi.consul.PeeringTokenArgs;\nimport com.pulumi.consul.Peering;\nimport com.pulumi.consul.PeeringArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var eu_us = new PeeringToken(\"eu-us\", PeeringTokenArgs.builder()\n            .peerName(\"eu-cluster\")\n            .build());\n\n        var eu_usPeering = new Peering(\"eu-usPeering\", PeeringArgs.builder()\n            .peerName(\"eu-cluster\")\n            .peeringToken(token.peeringToken())\n            .meta(Map.of(\"hello\", \"world\"))\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  eu-us:\n    type: consul:PeeringToken\n    properties:\n      peerName: eu-cluster\n  eu-usPeering:\n    type: consul:Peering\n    name: eu-us\n    properties:\n      peerName: eu-cluster\n      peeringToken: ${token.peeringToken}\n      meta:\n        hello: world\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "deletedAt": {
                    "type": "string"
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies KV metadata to associate with the peering. This parameter is not required and does not directly impact the cluster peering process.\n"
                },
                "partition": {
                    "type": "string"
                },
                "peerCaPems": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "peerId": {
                    "type": "string"
                },
                "peerName": {
                    "type": "string",
                    "description": "The name assigned to the peer cluster. The `peer_name` is used to reference the peer cluster in service discovery queries and configuration entries such as `service-intentions`. This field must be a valid DNS hostname label.\n"
                },
                "peerServerAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "peerServerName": {
                    "type": "string"
                },
                "peeringToken": {
                    "type": "string",
                    "description": "The peering token fetched from the peer cluster.\n",
                    "secret": true
                },
                "state": {
                    "type": "string"
                }
            },
            "required": [
                "deletedAt",
                "peerCaPems",
                "peerId",
                "peerName",
                "peerServerAddresses",
                "peerServerName",
                "peeringToken",
                "state"
            ],
            "inputProperties": {
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies KV metadata to associate with the peering. This parameter is not required and does not directly impact the cluster peering process.\n",
                    "willReplaceOnChanges": true
                },
                "partition": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "peerName": {
                    "type": "string",
                    "description": "The name assigned to the peer cluster. The `peer_name` is used to reference the peer cluster in service discovery queries and configuration entries such as `service-intentions`. This field must be a valid DNS hostname label.\n",
                    "willReplaceOnChanges": true
                },
                "peeringToken": {
                    "type": "string",
                    "description": "The peering token fetched from the peer cluster.\n",
                    "secret": true,
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "peerName",
                "peeringToken"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Peering resources.\n",
                "properties": {
                    "deletedAt": {
                        "type": "string"
                    },
                    "meta": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Specifies KV metadata to associate with the peering. This parameter is not required and does not directly impact the cluster peering process.\n",
                        "willReplaceOnChanges": true
                    },
                    "partition": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "peerCaPems": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "peerId": {
                        "type": "string"
                    },
                    "peerName": {
                        "type": "string",
                        "description": "The name assigned to the peer cluster. The `peer_name` is used to reference the peer cluster in service discovery queries and configuration entries such as `service-intentions`. This field must be a valid DNS hostname label.\n",
                        "willReplaceOnChanges": true
                    },
                    "peerServerAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "peerServerName": {
                        "type": "string"
                    },
                    "peeringToken": {
                        "type": "string",
                        "description": "The peering token fetched from the peer cluster.\n",
                        "secret": true,
                        "willReplaceOnChanges": true
                    },
                    "state": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "consul:index/peeringToken:PeeringToken": {
            "description": "[Cluster Peering](https://www.consul.io/docs/connect/cluster-peering) can be used to create connections between two or more independent clusters so that services deployed to different partitions or datacenters can communicate.\n\nThe `cluster_peering_token` resource can be used to generate a peering token that can later be used to establish a peering connection.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst token = new consul.PeeringToken(\"token\", {peerName: \"eu-cluster\"});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\ntoken = consul.PeeringToken(\"token\", peer_name=\"eu-cluster\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var token = new Consul.PeeringToken(\"token\", new()\n    {\n        PeerName = \"eu-cluster\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.NewPeeringToken(ctx, \"token\", \u0026consul.PeeringTokenArgs{\n\t\t\tPeerName: pulumi.String(\"eu-cluster\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.PeeringToken;\nimport com.pulumi.consul.PeeringTokenArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var token = new PeeringToken(\"token\", PeeringTokenArgs.builder()\n            .peerName(\"eu-cluster\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  token:\n    type: consul:PeeringToken\n    properties:\n      peerName: eu-cluster\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies KV metadata to associate with the peering. This parameter is not required and does not directly impact the cluster peering process.\n"
                },
                "partition": {
                    "type": "string"
                },
                "peerName": {
                    "type": "string",
                    "description": "The name assigned to the peer cluster. The `peer_name` is used to reference the peer cluster in service discovery queries and configuration entries such as `service-intentions`. This field must be a valid DNS hostname label.\n"
                },
                "peeringToken": {
                    "type": "string",
                    "description": "The generated peering token\n",
                    "language": {
                        "csharp": {
                            "name": "Token"
                        }
                    },
                    "secret": true
                },
                "serverExternalAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The addresses for the cluster that generates the peering token. Addresses take the form {host or IP}:port. You can specify one or more load balancers or external IPs that route external traffic to this cluster's Consul servers.\n"
                }
            },
            "required": [
                "peerName",
                "peeringToken"
            ],
            "inputProperties": {
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies KV metadata to associate with the peering. This parameter is not required and does not directly impact the cluster peering process.\n",
                    "willReplaceOnChanges": true
                },
                "partition": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "peerName": {
                    "type": "string",
                    "description": "The name assigned to the peer cluster. The `peer_name` is used to reference the peer cluster in service discovery queries and configuration entries such as `service-intentions`. This field must be a valid DNS hostname label.\n",
                    "willReplaceOnChanges": true
                },
                "serverExternalAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The addresses for the cluster that generates the peering token. Addresses take the form {host or IP}:port. You can specify one or more load balancers or external IPs that route external traffic to this cluster's Consul servers.\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "peerName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PeeringToken resources.\n",
                "properties": {
                    "meta": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Specifies KV metadata to associate with the peering. This parameter is not required and does not directly impact the cluster peering process.\n",
                        "willReplaceOnChanges": true
                    },
                    "partition": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "peerName": {
                        "type": "string",
                        "description": "The name assigned to the peer cluster. The `peer_name` is used to reference the peer cluster in service discovery queries and configuration entries such as `service-intentions`. This field must be a valid DNS hostname label.\n",
                        "willReplaceOnChanges": true
                    },
                    "peeringToken": {
                        "type": "string",
                        "description": "The generated peering token\n",
                        "language": {
                            "csharp": {
                                "name": "Token"
                            }
                        },
                        "secret": true
                    },
                    "serverExternalAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The addresses for the cluster that generates the peering token. Addresses take the form {host or IP}:port. You can specify one or more load balancers or external IPs that route external traffic to this cluster's Consul servers.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "consul:index/preparedQuery:PreparedQuery": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\n// Creates a prepared query myquery.query.consul that finds the nearest\n// healthy myapp.service.consul instance that has the active tag and not\n// the standby tag.\nconst myapp_query = new consul.PreparedQuery(\"myapp-query\", {\n    name: \"myquery\",\n    datacenter: \"us-central1\",\n    token: \"abcd\",\n    storedToken: \"wxyz\",\n    onlyPassing: true,\n    near: \"_agent\",\n    service: \"myapp\",\n    tags: [\n        \"active\",\n        \"!standby\",\n    ],\n    failover: {\n        nearestN: 3,\n        datacenters: [\n            \"us-west1\",\n            \"us-east-2\",\n            \"asia-east1\",\n        ],\n    },\n    dns: {\n        ttl: \"30s\",\n    },\n});\n// Creates a Prepared Query Template that matches *-near-self.query.consul\n// and finds the nearest service that matches the glob character (e.g.\n// foo-near-self.query.consul will find the nearest healthy foo.service.consul).\nconst service_near_self = new consul.PreparedQuery(\"service-near-self\", {\n    datacenter: \"nyc1\",\n    token: \"abcd\",\n    storedToken: \"wxyz\",\n    name: \"\",\n    onlyPassing: true,\n    connect: true,\n    near: \"_agent\",\n    template: {\n        type: \"name_prefix_match\",\n        regexp: \"^(.*)-near-self$\",\n    },\n    service: \"${match(1)}\",\n    failover: {\n        nearestN: 3,\n        datacenters: [\n            \"dc2\",\n            \"dc3\",\n            \"dc4\",\n        ],\n    },\n    dns: {\n        ttl: \"5m\",\n    },\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\n# Creates a prepared query myquery.query.consul that finds the nearest\n# healthy myapp.service.consul instance that has the active tag and not\n# the standby tag.\nmyapp_query = consul.PreparedQuery(\"myapp-query\",\n    name=\"myquery\",\n    datacenter=\"us-central1\",\n    token=\"abcd\",\n    stored_token=\"wxyz\",\n    only_passing=True,\n    near=\"_agent\",\n    service=\"myapp\",\n    tags=[\n        \"active\",\n        \"!standby\",\n    ],\n    failover={\n        \"nearest_n\": 3,\n        \"datacenters\": [\n            \"us-west1\",\n            \"us-east-2\",\n            \"asia-east1\",\n        ],\n    },\n    dns={\n        \"ttl\": \"30s\",\n    })\n# Creates a Prepared Query Template that matches *-near-self.query.consul\n# and finds the nearest service that matches the glob character (e.g.\n# foo-near-self.query.consul will find the nearest healthy foo.service.consul).\nservice_near_self = consul.PreparedQuery(\"service-near-self\",\n    datacenter=\"nyc1\",\n    token=\"abcd\",\n    stored_token=\"wxyz\",\n    name=\"\",\n    only_passing=True,\n    connect=True,\n    near=\"_agent\",\n    template={\n        \"type\": \"name_prefix_match\",\n        \"regexp\": \"^(.*)-near-self$\",\n    },\n    service=\"${match(1)}\",\n    failover={\n        \"nearest_n\": 3,\n        \"datacenters\": [\n            \"dc2\",\n            \"dc3\",\n            \"dc4\",\n        ],\n    },\n    dns={\n        \"ttl\": \"5m\",\n    })\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    // Creates a prepared query myquery.query.consul that finds the nearest\n    // healthy myapp.service.consul instance that has the active tag and not\n    // the standby tag.\n    var myapp_query = new Consul.PreparedQuery(\"myapp-query\", new()\n    {\n        Name = \"myquery\",\n        Datacenter = \"us-central1\",\n        Token = \"abcd\",\n        StoredToken = \"wxyz\",\n        OnlyPassing = true,\n        Near = \"_agent\",\n        Service = \"myapp\",\n        Tags = new[]\n        {\n            \"active\",\n            \"!standby\",\n        },\n        Failover = new Consul.Inputs.PreparedQueryFailoverArgs\n        {\n            NearestN = 3,\n            Datacenters = new[]\n            {\n                \"us-west1\",\n                \"us-east-2\",\n                \"asia-east1\",\n            },\n        },\n        Dns = new Consul.Inputs.PreparedQueryDnsArgs\n        {\n            Ttl = \"30s\",\n        },\n    });\n\n    // Creates a Prepared Query Template that matches *-near-self.query.consul\n    // and finds the nearest service that matches the glob character (e.g.\n    // foo-near-self.query.consul will find the nearest healthy foo.service.consul).\n    var service_near_self = new Consul.PreparedQuery(\"service-near-self\", new()\n    {\n        Datacenter = \"nyc1\",\n        Token = \"abcd\",\n        StoredToken = \"wxyz\",\n        Name = \"\",\n        OnlyPassing = true,\n        Connect = true,\n        Near = \"_agent\",\n        Template = new Consul.Inputs.PreparedQueryTemplateArgs\n        {\n            Type = \"name_prefix_match\",\n            Regexp = \"^(.*)-near-self$\",\n        },\n        Service = \"${match(1)}\",\n        Failover = new Consul.Inputs.PreparedQueryFailoverArgs\n        {\n            NearestN = 3,\n            Datacenters = new[]\n            {\n                \"dc2\",\n                \"dc3\",\n                \"dc4\",\n            },\n        },\n        Dns = new Consul.Inputs.PreparedQueryDnsArgs\n        {\n            Ttl = \"5m\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t// Creates a prepared query myquery.query.consul that finds the nearest\n\t\t// healthy myapp.service.consul instance that has the active tag and not\n\t\t// the standby tag.\n\t\t_, err := consul.NewPreparedQuery(ctx, \"myapp-query\", \u0026consul.PreparedQueryArgs{\n\t\t\tName:        pulumi.String(\"myquery\"),\n\t\t\tDatacenter:  pulumi.String(\"us-central1\"),\n\t\t\tToken:       pulumi.String(\"abcd\"),\n\t\t\tStoredToken: pulumi.String(\"wxyz\"),\n\t\t\tOnlyPassing: pulumi.Bool(true),\n\t\t\tNear:        pulumi.String(\"_agent\"),\n\t\t\tService:     pulumi.String(\"myapp\"),\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"active\"),\n\t\t\t\tpulumi.String(\"!standby\"),\n\t\t\t},\n\t\t\tFailover: \u0026consul.PreparedQueryFailoverArgs{\n\t\t\t\tNearestN: pulumi.Int(3),\n\t\t\t\tDatacenters: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"us-west1\"),\n\t\t\t\t\tpulumi.String(\"us-east-2\"),\n\t\t\t\t\tpulumi.String(\"asia-east1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDns: \u0026consul.PreparedQueryDnsArgs{\n\t\t\t\tTtl: pulumi.String(\"30s\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Creates a Prepared Query Template that matches *-near-self.query.consul\n\t\t// and finds the nearest service that matches the glob character (e.g.\n\t\t// foo-near-self.query.consul will find the nearest healthy foo.service.consul).\n\t\t_, err = consul.NewPreparedQuery(ctx, \"service-near-self\", \u0026consul.PreparedQueryArgs{\n\t\t\tDatacenter:  pulumi.String(\"nyc1\"),\n\t\t\tToken:       pulumi.String(\"abcd\"),\n\t\t\tStoredToken: pulumi.String(\"wxyz\"),\n\t\t\tName:        pulumi.String(\"\"),\n\t\t\tOnlyPassing: pulumi.Bool(true),\n\t\t\tConnect:     pulumi.Bool(true),\n\t\t\tNear:        pulumi.String(\"_agent\"),\n\t\t\tTemplate: \u0026consul.PreparedQueryTemplateArgs{\n\t\t\t\tType:   pulumi.String(\"name_prefix_match\"),\n\t\t\t\tRegexp: pulumi.String(\"^(.*)-near-self$\"),\n\t\t\t},\n\t\t\tService: pulumi.String(\"${match(1)}\"),\n\t\t\tFailover: \u0026consul.PreparedQueryFailoverArgs{\n\t\t\t\tNearestN: pulumi.Int(3),\n\t\t\t\tDatacenters: pulumi.StringArray{\n\t\t\t\t\tpulumi.String(\"dc2\"),\n\t\t\t\t\tpulumi.String(\"dc3\"),\n\t\t\t\t\tpulumi.String(\"dc4\"),\n\t\t\t\t},\n\t\t\t},\n\t\t\tDns: \u0026consul.PreparedQueryDnsArgs{\n\t\t\t\tTtl: pulumi.String(\"5m\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.PreparedQuery;\nimport com.pulumi.consul.PreparedQueryArgs;\nimport com.pulumi.consul.inputs.PreparedQueryFailoverArgs;\nimport com.pulumi.consul.inputs.PreparedQueryDnsArgs;\nimport com.pulumi.consul.inputs.PreparedQueryTemplateArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        // Creates a prepared query myquery.query.consul that finds the nearest\n        // healthy myapp.service.consul instance that has the active tag and not\n        // the standby tag.\n        var myapp_query = new PreparedQuery(\"myapp-query\", PreparedQueryArgs.builder()\n            .name(\"myquery\")\n            .datacenter(\"us-central1\")\n            .token(\"abcd\")\n            .storedToken(\"wxyz\")\n            .onlyPassing(true)\n            .near(\"_agent\")\n            .service(\"myapp\")\n            .tags(            \n                \"active\",\n                \"!standby\")\n            .failover(PreparedQueryFailoverArgs.builder()\n                .nearestN(3)\n                .datacenters(                \n                    \"us-west1\",\n                    \"us-east-2\",\n                    \"asia-east1\")\n                .build())\n            .dns(PreparedQueryDnsArgs.builder()\n                .ttl(\"30s\")\n                .build())\n            .build());\n\n        // Creates a Prepared Query Template that matches *-near-self.query.consul\n        // and finds the nearest service that matches the glob character (e.g.\n        // foo-near-self.query.consul will find the nearest healthy foo.service.consul).\n        var service_near_self = new PreparedQuery(\"service-near-self\", PreparedQueryArgs.builder()\n            .datacenter(\"nyc1\")\n            .token(\"abcd\")\n            .storedToken(\"wxyz\")\n            .name(\"\")\n            .onlyPassing(true)\n            .connect(true)\n            .near(\"_agent\")\n            .template(PreparedQueryTemplateArgs.builder()\n                .type(\"name_prefix_match\")\n                .regexp(\"^(.*)-near-self$\")\n                .build())\n            .service(\"${match(1)}\")\n            .failover(PreparedQueryFailoverArgs.builder()\n                .nearestN(3)\n                .datacenters(                \n                    \"dc2\",\n                    \"dc3\",\n                    \"dc4\")\n                .build())\n            .dns(PreparedQueryDnsArgs.builder()\n                .ttl(\"5m\")\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Creates a prepared query myquery.query.consul that finds the nearest\n  # healthy myapp.service.consul instance that has the active tag and not\n  # the standby tag.\n  myapp-query:\n    type: consul:PreparedQuery\n    properties:\n      name: myquery\n      datacenter: us-central1\n      token: abcd\n      storedToken: wxyz\n      onlyPassing: true\n      near: _agent\n      service: myapp\n      tags:\n        - active\n        - '!standby'\n      failover:\n        nearestN: 3\n        datacenters:\n          - us-west1\n          - us-east-2\n          - asia-east1\n      dns:\n        ttl: 30s\n  # Creates a Prepared Query Template that matches *-near-self.query.consul\n  # and finds the nearest service that matches the glob character (e.g.\n  # foo-near-self.query.consul will find the nearest healthy foo.service.consul).\n  service-near-self:\n    type: consul:PreparedQuery\n    properties:\n      datacenter: nyc1\n      token: abcd\n      storedToken: wxyz\n      name: \"\"\n      onlyPassing: true\n      connect: true\n      near: _agent\n      template:\n        type: name_prefix_match\n        regexp: ^(.*)-near-self$\n      service: $${match(1)}\n      failover:\n        nearestN: 3\n        datacenters:\n          - dc2\n          - dc3\n          - dc4\n      dns:\n        ttl: 5m\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n## Import\n\n```sh\n$ pulumi import consul:index/preparedQuery:PreparedQuery my_service 71ecfb82-717a-4258-b4b6-2fb75144d856\n```\n\n",
            "properties": {
                "connect": {
                    "type": "boolean",
                    "description": "When `true` the prepared query will return connect proxy services for a queried service.  Conditions such as `tags` in the prepared query will be matched against the proxy service. Defaults to false.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the agent's default datacenter and the datacenter in the provider setup.\n"
                },
                "dns": {
                    "$ref": "#/types/consul:index/PreparedQueryDns:PreparedQueryDns",
                    "description": "Settings for controlling the DNS response details.\n"
                },
                "failover": {
                    "$ref": "#/types/consul:index/PreparedQueryFailover:PreparedQueryFailover",
                    "description": "Options for controlling behavior when no healthy nodes are available in the local DC.\n"
                },
                "ignoreCheckIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies a list of check IDs that should be ignored when filtering unhealthy instances. This is mostly useful in an emergency or as a temporary measure when a health check is found to be unreliable. Being able to ignore it in centrally-defined queries can be simpler than de-registering the check as an interim solution until the check can be fixed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the prepared query. Used to identify the prepared query during requests. Can be specified as an empty string to configure the query as a catch-all.\n"
                },
                "near": {
                    "type": "string",
                    "description": "Allows specifying the name of a node to sort results near using Consul's distance sorting and network coordinates. The magic `_agent` value can be used to always sort nearest the node servicing the request.\n"
                },
                "nodeMeta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies a list of user-defined key/value pairs that will be used for filtering the query results to nodes with the given metadata values present.\n"
                },
                "onlyPassing": {
                    "type": "boolean",
                    "description": "When `true`, the prepared query will only return nodes with passing health checks in the result.\n"
                },
                "service": {
                    "type": "string",
                    "description": "The name of the service to query\n"
                },
                "serviceMeta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies a list of user-defined key/value pairs that will be used for filtering the query results to services with the given metadata values present.\n"
                },
                "session": {
                    "type": "string",
                    "description": "The name of the Consul session to tie this query's lifetime to.  This is an advanced parameter that should not be used without a complete understanding of Consul sessions and the implications of their use (it is recommended to leave this blank in nearly all cases).  If this parameter is omitted the query will not expire.\n"
                },
                "storedToken": {
                    "type": "string",
                    "description": "The ACL token to store with the prepared query. This token will be used by default whenever the query is executed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of required and/or disallowed tags.  If a tag is in this list it must be present.  If the tag is preceded with a \"!\" then it is disallowed.\n"
                },
                "template": {
                    "$ref": "#/types/consul:index/PreparedQueryTemplate:PreparedQueryTemplate",
                    "description": "Query templating options. This is used to make a single prepared query respond to many different requests\n"
                },
                "token": {
                    "type": "string",
                    "description": "The ACL token to use when saving the prepared query. This overrides the token that the agent provides by default.\n",
                    "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                    "secret": true
                }
            },
            "required": [
                "name",
                "service"
            ],
            "inputProperties": {
                "connect": {
                    "type": "boolean",
                    "description": "When `true` the prepared query will return connect proxy services for a queried service.  Conditions such as `tags` in the prepared query will be matched against the proxy service. Defaults to false.\n"
                },
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the agent's default datacenter and the datacenter in the provider setup.\n",
                    "willReplaceOnChanges": true
                },
                "dns": {
                    "$ref": "#/types/consul:index/PreparedQueryDns:PreparedQueryDns",
                    "description": "Settings for controlling the DNS response details.\n"
                },
                "failover": {
                    "$ref": "#/types/consul:index/PreparedQueryFailover:PreparedQueryFailover",
                    "description": "Options for controlling behavior when no healthy nodes are available in the local DC.\n"
                },
                "ignoreCheckIds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specifies a list of check IDs that should be ignored when filtering unhealthy instances. This is mostly useful in an emergency or as a temporary measure when a health check is found to be unreliable. Being able to ignore it in centrally-defined queries can be simpler than de-registering the check as an interim solution until the check can be fixed.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the prepared query. Used to identify the prepared query during requests. Can be specified as an empty string to configure the query as a catch-all.\n"
                },
                "near": {
                    "type": "string",
                    "description": "Allows specifying the name of a node to sort results near using Consul's distance sorting and network coordinates. The magic `_agent` value can be used to always sort nearest the node servicing the request.\n"
                },
                "nodeMeta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies a list of user-defined key/value pairs that will be used for filtering the query results to nodes with the given metadata values present.\n"
                },
                "onlyPassing": {
                    "type": "boolean",
                    "description": "When `true`, the prepared query will only return nodes with passing health checks in the result.\n"
                },
                "service": {
                    "type": "string",
                    "description": "The name of the service to query\n"
                },
                "serviceMeta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Specifies a list of user-defined key/value pairs that will be used for filtering the query results to services with the given metadata values present.\n"
                },
                "session": {
                    "type": "string",
                    "description": "The name of the Consul session to tie this query's lifetime to.  This is an advanced parameter that should not be used without a complete understanding of Consul sessions and the implications of their use (it is recommended to leave this blank in nearly all cases).  If this parameter is omitted the query will not expire.\n"
                },
                "storedToken": {
                    "type": "string",
                    "description": "The ACL token to store with the prepared query. This token will be used by default whenever the query is executed.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "The list of required and/or disallowed tags.  If a tag is in this list it must be present.  If the tag is preceded with a \"!\" then it is disallowed.\n"
                },
                "template": {
                    "$ref": "#/types/consul:index/PreparedQueryTemplate:PreparedQueryTemplate",
                    "description": "Query templating options. This is used to make a single prepared query respond to many different requests\n"
                },
                "token": {
                    "type": "string",
                    "description": "The ACL token to use when saving the prepared query. This overrides the token that the agent provides by default.\n",
                    "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                    "secret": true
                }
            },
            "requiredInputs": [
                "service"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering PreparedQuery resources.\n",
                "properties": {
                    "connect": {
                        "type": "boolean",
                        "description": "When `true` the prepared query will return connect proxy services for a queried service.  Conditions such as `tags` in the prepared query will be matched against the proxy service. Defaults to false.\n"
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The datacenter to use. This overrides the agent's default datacenter and the datacenter in the provider setup.\n",
                        "willReplaceOnChanges": true
                    },
                    "dns": {
                        "$ref": "#/types/consul:index/PreparedQueryDns:PreparedQueryDns",
                        "description": "Settings for controlling the DNS response details.\n"
                    },
                    "failover": {
                        "$ref": "#/types/consul:index/PreparedQueryFailover:PreparedQueryFailover",
                        "description": "Options for controlling behavior when no healthy nodes are available in the local DC.\n"
                    },
                    "ignoreCheckIds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specifies a list of check IDs that should be ignored when filtering unhealthy instances. This is mostly useful in an emergency or as a temporary measure when a health check is found to be unreliable. Being able to ignore it in centrally-defined queries can be simpler than de-registering the check as an interim solution until the check can be fixed.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the prepared query. Used to identify the prepared query during requests. Can be specified as an empty string to configure the query as a catch-all.\n"
                    },
                    "near": {
                        "type": "string",
                        "description": "Allows specifying the name of a node to sort results near using Consul's distance sorting and network coordinates. The magic `_agent` value can be used to always sort nearest the node servicing the request.\n"
                    },
                    "nodeMeta": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Specifies a list of user-defined key/value pairs that will be used for filtering the query results to nodes with the given metadata values present.\n"
                    },
                    "onlyPassing": {
                        "type": "boolean",
                        "description": "When `true`, the prepared query will only return nodes with passing health checks in the result.\n"
                    },
                    "service": {
                        "type": "string",
                        "description": "The name of the service to query\n"
                    },
                    "serviceMeta": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Specifies a list of user-defined key/value pairs that will be used for filtering the query results to services with the given metadata values present.\n"
                    },
                    "session": {
                        "type": "string",
                        "description": "The name of the Consul session to tie this query's lifetime to.  This is an advanced parameter that should not be used without a complete understanding of Consul sessions and the implications of their use (it is recommended to leave this blank in nearly all cases).  If this parameter is omitted the query will not expire.\n"
                    },
                    "storedToken": {
                        "type": "string",
                        "description": "The ACL token to store with the prepared query. This token will be used by default whenever the query is executed.\n"
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The list of required and/or disallowed tags.  If a tag is in this list it must be present.  If the tag is preceded with a \"!\" then it is disallowed.\n"
                    },
                    "template": {
                        "$ref": "#/types/consul:index/PreparedQueryTemplate:PreparedQueryTemplate",
                        "description": "Query templating options. This is used to make a single prepared query respond to many different requests\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The ACL token to use when saving the prepared query. This overrides the token that the agent provides by default.\n",
                        "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                        "secret": true
                    }
                },
                "type": "object"
            }
        },
        "consul:index/service:Service": {
            "description": "A high-level resource for creating a Service in Consul in the Consul catalog. This\nis appropriate for registering [external services](https://www.consul.io/docs/guides/external.html) and\ncan be used to create services addressable by Consul that cannot be registered\nwith a [local agent](https://www.consul.io/docs/agent/basics.html).\n\n\u003e **NOTE:** If a Consul agent is running on the node where this service is\nregistered, it is not recommended to use this resource as the service will be\nremoved during the next [anti-entropy synchronization](https://www.consul.io/docs/architecture/anti-entropy).\n\n\n## Example Usage\n\nCreating a new node with the service:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst compute = new consul.Node(\"compute\", {\n    name: \"compute-google\",\n    address: \"www.google.com\",\n});\nconst google = new consul.Service(\"google\", {\n    name: \"google\",\n    node: compute.name,\n    port: 80,\n    tags: [\"tag0\"],\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\ncompute = consul.Node(\"compute\",\n    name=\"compute-google\",\n    address=\"www.google.com\")\ngoogle = consul.Service(\"google\",\n    name=\"google\",\n    node=compute.name,\n    port=80,\n    tags=[\"tag0\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var compute = new Consul.Node(\"compute\", new()\n    {\n        Name = \"compute-google\",\n        Address = \"www.google.com\",\n    });\n\n    var google = new Consul.Service(\"google\", new()\n    {\n        Name = \"google\",\n        Node = compute.Name,\n        Port = 80,\n        Tags = new[]\n        {\n            \"tag0\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tcompute, err := consul.NewNode(ctx, \"compute\", \u0026consul.NodeArgs{\n\t\t\tName:    pulumi.String(\"compute-google\"),\n\t\t\tAddress: pulumi.String(\"www.google.com\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = consul.NewService(ctx, \"google\", \u0026consul.ServiceArgs{\n\t\t\tName: pulumi.String(\"google\"),\n\t\t\tNode: compute.Name,\n\t\t\tPort: pulumi.Int(80),\n\t\t\tTags: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"tag0\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.Node;\nimport com.pulumi.consul.NodeArgs;\nimport com.pulumi.consul.Service;\nimport com.pulumi.consul.ServiceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var compute = new Node(\"compute\", NodeArgs.builder()\n            .name(\"compute-google\")\n            .address(\"www.google.com\")\n            .build());\n\n        var google = new Service(\"google\", ServiceArgs.builder()\n            .name(\"google\")\n            .node(compute.name())\n            .port(80)\n            .tags(\"tag0\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  google:\n    type: consul:Service\n    properties:\n      name: google\n      node: ${compute.name}\n      port: 80\n      tags:\n        - tag0\n  compute:\n    type: consul:Node\n    properties:\n      name: compute-google\n      address: www.google.com\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nUtilizing an existing known node:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst google = new consul.Service(\"google\", {\n    name: \"google\",\n    node: \"google\",\n    port: 443,\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\ngoogle = consul.Service(\"google\",\n    name=\"google\",\n    node=\"google\",\n    port=443)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var google = new Consul.Service(\"google\", new()\n    {\n        Name = \"google\",\n        Node = \"google\",\n        Port = 443,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.NewService(ctx, \"google\", \u0026consul.ServiceArgs{\n\t\t\tName: pulumi.String(\"google\"),\n\t\t\tNode: pulumi.String(\"google\"),\n\t\t\tPort: pulumi.Int(443),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.Service;\nimport com.pulumi.consul.ServiceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var google = new Service(\"google\", ServiceArgs.builder()\n            .name(\"google\")\n            .node(\"google\")\n            .port(443)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  google:\n    type: consul:Service\n    properties:\n      name: google\n      node: google\n      port: 443\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\nRegister a health-check:\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst redis = new consul.Service(\"redis\", {\n    name: \"redis\",\n    node: \"redis\",\n    port: 6379,\n    checks: [{\n        checkId: \"service:redis1\",\n        name: \"Redis health check\",\n        status: \"passing\",\n        http: \"https://www.hashicorptest.com\",\n        tlsSkipVerify: false,\n        method: \"PUT\",\n        interval: \"5s\",\n        timeout: \"1s\",\n        deregisterCriticalServiceAfter: \"30s\",\n        headers: [\n            {\n                name: \"foo\",\n                values: [\"test\"],\n            },\n            {\n                name: \"bar\",\n                values: [\"test\"],\n            },\n        ],\n    }],\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\nredis = consul.Service(\"redis\",\n    name=\"redis\",\n    node=\"redis\",\n    port=6379,\n    checks=[{\n        \"check_id\": \"service:redis1\",\n        \"name\": \"Redis health check\",\n        \"status\": \"passing\",\n        \"http\": \"https://www.hashicorptest.com\",\n        \"tls_skip_verify\": False,\n        \"method\": \"PUT\",\n        \"interval\": \"5s\",\n        \"timeout\": \"1s\",\n        \"deregister_critical_service_after\": \"30s\",\n        \"headers\": [\n            {\n                \"name\": \"foo\",\n                \"values\": [\"test\"],\n            },\n            {\n                \"name\": \"bar\",\n                \"values\": [\"test\"],\n            },\n        ],\n    }])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var redis = new Consul.Service(\"redis\", new()\n    {\n        Name = \"redis\",\n        Node = \"redis\",\n        Port = 6379,\n        Checks = new[]\n        {\n            new Consul.Inputs.ServiceCheckArgs\n            {\n                CheckId = \"service:redis1\",\n                Name = \"Redis health check\",\n                Status = \"passing\",\n                Http = \"https://www.hashicorptest.com\",\n                TlsSkipVerify = false,\n                Method = \"PUT\",\n                Interval = \"5s\",\n                Timeout = \"1s\",\n                DeregisterCriticalServiceAfter = \"30s\",\n                Headers = new[]\n                {\n                    new Consul.Inputs.ServiceCheckHeaderArgs\n                    {\n                        Name = \"foo\",\n                        Values = new[]\n                        {\n                            \"test\",\n                        },\n                    },\n                    new Consul.Inputs.ServiceCheckHeaderArgs\n                    {\n                        Name = \"bar\",\n                        Values = new[]\n                        {\n                            \"test\",\n                        },\n                    },\n                },\n            },\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.NewService(ctx, \"redis\", \u0026consul.ServiceArgs{\n\t\t\tName: pulumi.String(\"redis\"),\n\t\t\tNode: pulumi.String(\"redis\"),\n\t\t\tPort: pulumi.Int(6379),\n\t\t\tChecks: consul.ServiceCheckArray{\n\t\t\t\t\u0026consul.ServiceCheckArgs{\n\t\t\t\t\tCheckId:                        pulumi.String(\"service:redis1\"),\n\t\t\t\t\tName:                           pulumi.String(\"Redis health check\"),\n\t\t\t\t\tStatus:                         pulumi.String(\"passing\"),\n\t\t\t\t\tHttp:                           pulumi.String(\"https://www.hashicorptest.com\"),\n\t\t\t\t\tTlsSkipVerify:                  pulumi.Bool(false),\n\t\t\t\t\tMethod:                         pulumi.String(\"PUT\"),\n\t\t\t\t\tInterval:                       pulumi.String(\"5s\"),\n\t\t\t\t\tTimeout:                        pulumi.String(\"1s\"),\n\t\t\t\t\tDeregisterCriticalServiceAfter: pulumi.String(\"30s\"),\n\t\t\t\t\tHeaders: consul.ServiceCheckHeaderArray{\n\t\t\t\t\t\t\u0026consul.ServiceCheckHeaderArgs{\n\t\t\t\t\t\t\tName: pulumi.String(\"foo\"),\n\t\t\t\t\t\t\tValues: pulumi.StringArray{\n\t\t\t\t\t\t\t\tpulumi.String(\"test\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\u0026consul.ServiceCheckHeaderArgs{\n\t\t\t\t\t\t\tName: pulumi.String(\"bar\"),\n\t\t\t\t\t\t\tValues: pulumi.StringArray{\n\t\t\t\t\t\t\t\tpulumi.String(\"test\"),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.Service;\nimport com.pulumi.consul.ServiceArgs;\nimport com.pulumi.consul.inputs.ServiceCheckArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var redis = new Service(\"redis\", ServiceArgs.builder()\n            .name(\"redis\")\n            .node(\"redis\")\n            .port(6379)\n            .checks(ServiceCheckArgs.builder()\n                .checkId(\"service:redis1\")\n                .name(\"Redis health check\")\n                .status(\"passing\")\n                .http(\"https://www.hashicorptest.com\")\n                .tlsSkipVerify(false)\n                .method(\"PUT\")\n                .interval(\"5s\")\n                .timeout(\"1s\")\n                .deregisterCriticalServiceAfter(\"30s\")\n                .headers(                \n                    ServiceCheckHeaderArgs.builder()\n                        .name(\"foo\")\n                        .values(\"test\")\n                        .build(),\n                    ServiceCheckHeaderArgs.builder()\n                        .name(\"bar\")\n                        .values(\"test\")\n                        .build())\n                .build())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  redis:\n    type: consul:Service\n    properties:\n      name: redis\n      node: redis\n      port: 6379\n      checks:\n        - checkId: service:redis1\n          name: Redis health check\n          status: passing\n          http: https://www.hashicorptest.com\n          tlsSkipVerify: false\n          method: PUT\n          interval: 5s\n          timeout: 1s\n          deregisterCriticalServiceAfter: 30s\n          headers:\n            - name: foo\n              values:\n                - test\n            - name: bar\n              values:\n                - test\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "properties": {
                "address": {
                    "type": "string",
                    "description": "The address of the service. Defaults to the address of the node.\n"
                },
                "checks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ServiceCheck:ServiceCheck"
                    }
                },
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the agent's default datacenter and the datacenter in the provider setup.\n"
                },
                "enableTagOverride": {
                    "type": "boolean",
                    "description": "Specifies to disable the anti-entropy feature for this service's tags. Defaults to `false`.\n"
                },
                "external": {
                    "type": "boolean",
                    "deprecationMessage": "The external field has been deprecated and does nothing."
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of arbitrary KV metadata linked to the service instance.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the service.\n"
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to create the service within.\n"
                },
                "node": {
                    "type": "string",
                    "description": "The name of the node the to register the service on.\n"
                },
                "partition": {
                    "type": "string",
                    "description": "The partition the service is associated with.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port of the service.\n"
                },
                "serviceId": {
                    "type": "string",
                    "description": "If the service ID is not provided, it will be defaulted to the value of the `name` attribute.\n"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of values that are opaque to Consul, but can be used to distinguish between services or nodes.\n"
                },
                "weights": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer"
                    },
                    "description": "Object that configures how the service responds to DNS SRV requests based on the service's health status. You can specify one or more of the following states and configure an integer value indicating its weight: `passing`, `warning`.\n"
                }
            },
            "required": [
                "address",
                "datacenter",
                "name",
                "node",
                "serviceId"
            ],
            "inputProperties": {
                "address": {
                    "type": "string",
                    "description": "The address of the service. Defaults to the address of the node.\n"
                },
                "checks": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/consul:index/ServiceCheck:ServiceCheck"
                    }
                },
                "datacenter": {
                    "type": "string",
                    "description": "The datacenter to use. This overrides the agent's default datacenter and the datacenter in the provider setup.\n",
                    "willReplaceOnChanges": true
                },
                "enableTagOverride": {
                    "type": "boolean",
                    "description": "Specifies to disable the anti-entropy feature for this service's tags. Defaults to `false`.\n"
                },
                "external": {
                    "type": "boolean",
                    "deprecationMessage": "The external field has been deprecated and does nothing."
                },
                "meta": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "A map of arbitrary KV metadata linked to the service instance.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the service.\n",
                    "willReplaceOnChanges": true
                },
                "namespace": {
                    "type": "string",
                    "description": "The namespace to create the service within.\n",
                    "willReplaceOnChanges": true
                },
                "node": {
                    "type": "string",
                    "description": "The name of the node the to register the service on.\n",
                    "willReplaceOnChanges": true
                },
                "partition": {
                    "type": "string",
                    "description": "The partition the service is associated with.\n",
                    "willReplaceOnChanges": true
                },
                "port": {
                    "type": "integer",
                    "description": "The port of the service.\n"
                },
                "serviceId": {
                    "type": "string",
                    "description": "If the service ID is not provided, it will be defaulted to the value of the `name` attribute.\n",
                    "willReplaceOnChanges": true
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "A list of values that are opaque to Consul, but can be used to distinguish between services or nodes.\n"
                },
                "weights": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "integer"
                    },
                    "description": "Object that configures how the service responds to DNS SRV requests based on the service's health status. You can specify one or more of the following states and configure an integer value indicating its weight: `passing`, `warning`.\n"
                }
            },
            "requiredInputs": [
                "node"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Service resources.\n",
                "properties": {
                    "address": {
                        "type": "string",
                        "description": "The address of the service. Defaults to the address of the node.\n"
                    },
                    "checks": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/ServiceCheck:ServiceCheck"
                        }
                    },
                    "datacenter": {
                        "type": "string",
                        "description": "The datacenter to use. This overrides the agent's default datacenter and the datacenter in the provider setup.\n",
                        "willReplaceOnChanges": true
                    },
                    "enableTagOverride": {
                        "type": "boolean",
                        "description": "Specifies to disable the anti-entropy feature for this service's tags. Defaults to `false`.\n"
                    },
                    "external": {
                        "type": "boolean",
                        "deprecationMessage": "The external field has been deprecated and does nothing."
                    },
                    "meta": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of arbitrary KV metadata linked to the service instance.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the service.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to create the service within.\n",
                        "willReplaceOnChanges": true
                    },
                    "node": {
                        "type": "string",
                        "description": "The name of the node the to register the service on.\n",
                        "willReplaceOnChanges": true
                    },
                    "partition": {
                        "type": "string",
                        "description": "The partition the service is associated with.\n",
                        "willReplaceOnChanges": true
                    },
                    "port": {
                        "type": "integer",
                        "description": "The port of the service.\n"
                    },
                    "serviceId": {
                        "type": "string",
                        "description": "If the service ID is not provided, it will be defaulted to the value of the `name` attribute.\n",
                        "willReplaceOnChanges": true
                    },
                    "tags": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "A list of values that are opaque to Consul, but can be used to distinguish between services or nodes.\n"
                    },
                    "weights": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "integer"
                        },
                        "description": "Object that configures how the service responds to DNS SRV requests based on the service's health status. You can specify one or more of the following states and configure an integer value indicating its weight: `passing`, `warning`.\n"
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "consul:index/getAclAuthMethod:getAclAuthMethod": {
            "description": "The `consul.AclAuthMethod` data source returns the information related to a\n[Consul Auth Method](https://www.consul.io/docs/acl/acl-auth-methods.html).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst test = consul.getAclAuthMethod({\n    name: \"minikube\",\n});\nexport const consulAclAuthMethod = test.then(test =\u003e test.config);\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\ntest = consul.get_acl_auth_method(name=\"minikube\")\npulumi.export(\"consulAclAuthMethod\", test.config)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Consul.GetAclAuthMethod.Invoke(new()\n    {\n        Name = \"minikube\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"consulAclAuthMethod\"] = test.Apply(getAclAuthMethodResult =\u003e getAclAuthMethodResult.Config),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := consul.LookupAclAuthMethod(ctx, \u0026consul.LookupAclAuthMethodArgs{\n\t\t\tName: \"minikube\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"consulAclAuthMethod\", test.Config)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConsulFunctions;\nimport com.pulumi.consul.inputs.GetAclAuthMethodArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = ConsulFunctions.getAclAuthMethod(GetAclAuthMethodArgs.builder()\n            .name(\"minikube\")\n            .build());\n\n        ctx.export(\"consulAclAuthMethod\", test.config());\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      function: consul:getAclAuthMethod\n      arguments:\n        name: minikube\noutputs:\n  consulAclAuthMethod: ${test.config}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAclAuthMethod.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the ACL Auth Method.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to lookup the auth method.\n"
                    },
                    "partition": {
                        "type": "string",
                        "description": "The partition to lookup the auth method.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAclAuthMethod.\n",
                "properties": {
                    "config": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "deprecationMessage": "The config attribute is deprecated, please use config_json instead.",
                        "description": "The configuration options of the ACL Auth Method. This attribute is\ndeprecated and will be removed in a future version. If the configuration is\ntoo complex to be represented as a map of strings, it will be blank.\n`config_json` should be used instead.\n",
                        "type": "object"
                    },
                    "configJson": {
                        "description": "The configuration options of the ACL Auth Method.\n",
                        "type": "string"
                    },
                    "description": {
                        "description": "The description of the ACL Auth Method.\n",
                        "type": "string"
                    },
                    "displayName": {
                        "description": "An optional name to use instead of the name attribute when\ndisplaying information about this auth method.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "maxTokenTtl": {
                        "description": "The maximum life of any token created by this auth method.\n",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "namespaceRules": {
                        "description": "(Enterprise Only) A set of rules that control which\nnamespace tokens created via this auth method will be created within\n",
                        "items": {
                            "$ref": "#/types/consul:index/getAclAuthMethodNamespaceRule:getAclAuthMethodNamespaceRule"
                        },
                        "type": "array"
                    },
                    "partition": {
                        "type": "string"
                    },
                    "tokenLocality": {
                        "description": "The kind of token that this auth method produces. This can\nbe either 'local' or 'global'.\n",
                        "type": "string"
                    },
                    "type": {
                        "description": "The type of the ACL Auth Method.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "config",
                    "configJson",
                    "description",
                    "displayName",
                    "maxTokenTtl",
                    "name",
                    "namespaceRules",
                    "tokenLocality",
                    "type",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getAclPolicy:getAclPolicy": {
            "description": "The `consul.AclPolicy` data source returns the information related to a\n[Consul ACL Policy](https://www.consul.io/docs/acl/acl-system.html#acl-policies).\n\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst agent = consul.getAclPolicy({\n    name: \"agent\",\n});\nexport const consulAclPolicy = agent.then(agent =\u003e agent.rules);\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\nagent = consul.get_acl_policy(name=\"agent\")\npulumi.export(\"consulAclPolicy\", agent.rules)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var agent = Consul.GetAclPolicy.Invoke(new()\n    {\n        Name = \"agent\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"consulAclPolicy\"] = agent.Apply(getAclPolicyResult =\u003e getAclPolicyResult.Rules),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tagent, err := consul.LookupAclPolicy(ctx, \u0026consul.LookupAclPolicyArgs{\n\t\t\tName: \"agent\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"consulAclPolicy\", agent.Rules)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConsulFunctions;\nimport com.pulumi.consul.inputs.GetAclPolicyArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var agent = ConsulFunctions.getAclPolicy(GetAclPolicyArgs.builder()\n            .name(\"agent\")\n            .build());\n\n        ctx.export(\"consulAclPolicy\", agent.rules());\n    }\n}\n```\n```yaml\nvariables:\n  agent:\n    fn::invoke:\n      function: consul:getAclPolicy\n      arguments:\n        name: agent\noutputs:\n  consulAclPolicy: ${agent.rules}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAclPolicy.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the ACL Policy.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to lookup the policy.\n"
                    },
                    "partition": {
                        "type": "string",
                        "description": "The partition to lookup the policy.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAclPolicy.\n",
                "properties": {
                    "datacenters": {
                        "description": "The datacenters associated with the ACL Policy.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "description": {
                        "description": "The description of the ACL Policy.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "partition": {
                        "type": "string"
                    },
                    "rules": {
                        "description": "The rules associated with the ACL Policy.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "datacenters",
                    "description",
                    "name",
                    "rules",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getAclRole:getAclRole": {
            "description": "The `consul.AclRole` data source returns the information related to a [Consul ACL Role](https://www.consul.io/api/acl/roles.html).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst test = consul.getAclRole({\n    name: \"example-role\",\n});\nexport const consulAclRole = test.then(test =\u003e test.id);\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\ntest = consul.get_acl_role(name=\"example-role\")\npulumi.export(\"consulAclRole\", test.id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Consul.GetAclRole.Invoke(new()\n    {\n        Name = \"example-role\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"consulAclRole\"] = test.Apply(getAclRoleResult =\u003e getAclRoleResult.Id),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := consul.LookupAclRole(ctx, \u0026consul.LookupAclRoleArgs{\n\t\t\tName: \"example-role\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"consulAclRole\", test.Id)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConsulFunctions;\nimport com.pulumi.consul.inputs.GetAclRoleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = ConsulFunctions.getAclRole(GetAclRoleArgs.builder()\n            .name(\"example-role\")\n            .build());\n\n        ctx.export(\"consulAclRole\", test.id());\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      function: consul:getAclRole\n      arguments:\n        name: example-role\noutputs:\n  consulAclRole: ${test.id}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAclRole.\n",
                "properties": {
                    "name": {
                        "type": "string",
                        "description": "The name of the ACL Role.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to lookup the role.\n"
                    },
                    "partition": {
                        "type": "string",
                        "description": "The partition to lookup the role.\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAclRole.\n",
                "properties": {
                    "description": {
                        "description": "The description of the ACL Role.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the ACL Role.\n",
                        "type": "string"
                    },
                    "namespace": {
                        "description": "The namespace to lookup the role.\n",
                        "type": "string"
                    },
                    "nodeIdentities": {
                        "description": "The list of node identities associated with the ACL Role.\n",
                        "items": {
                            "$ref": "#/types/consul:index/getAclRoleNodeIdentity:getAclRoleNodeIdentity"
                        },
                        "type": "array"
                    },
                    "partition": {
                        "description": "The partition to lookup the role.\n",
                        "type": "string"
                    },
                    "policies": {
                        "description": "The list of policies associated with the ACL Role.\n",
                        "items": {
                            "$ref": "#/types/consul:index/getAclRolePolicy:getAclRolePolicy"
                        },
                        "type": "array"
                    },
                    "serviceIdentities": {
                        "description": "The list of service identities associated with the ACL Role.\n",
                        "items": {
                            "$ref": "#/types/consul:index/getAclRoleServiceIdentity:getAclRoleServiceIdentity"
                        },
                        "type": "array"
                    },
                    "templatedPolicies": {
                        "description": "The list of templated policies that should be applied to the token.\n",
                        "items": {
                            "$ref": "#/types/consul:index/getAclRoleTemplatedPolicy:getAclRoleTemplatedPolicy"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "description",
                    "name",
                    "nodeIdentities",
                    "policies",
                    "serviceIdentities",
                    "templatedPolicies",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getAclToken:getAclToken": {
            "description": "The `consul.AclToken` data source returns the information related to the `consul.AclToken` resource with the exception of its secret ID.\n\nIf you want to get the secret ID associated with a token, use the [`consul.getAclTokenSecretId` data source](https://www.terraform.io/docs/providers/consul/d/acl_token_secret_id.html).\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst test = consul.getAclToken({\n    accessorId: \"00000000-0000-0000-0000-000000000002\",\n});\nexport const consulAclPolicies = test.then(test =\u003e test.policies);\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\ntest = consul.get_acl_token(accessor_id=\"00000000-0000-0000-0000-000000000002\")\npulumi.export(\"consulAclPolicies\", test.policies)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = Consul.GetAclToken.Invoke(new()\n    {\n        AccessorId = \"00000000-0000-0000-0000-000000000002\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"consulAclPolicies\"] = test.Apply(getAclTokenResult =\u003e getAclTokenResult.Policies),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := consul.LookupAclToken(ctx, \u0026consul.LookupAclTokenArgs{\n\t\t\tAccessorId: \"00000000-0000-0000-0000-000000000002\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"consulAclPolicies\", test.Policies)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConsulFunctions;\nimport com.pulumi.consul.inputs.GetAclTokenArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var test = ConsulFunctions.getAclToken(GetAclTokenArgs.builder()\n            .accessorId(\"00000000-0000-0000-0000-000000000002\")\n            .build());\n\n        ctx.export(\"consulAclPolicies\", test.policies());\n    }\n}\n```\n```yaml\nvariables:\n  test:\n    fn::invoke:\n      function: consul:getAclToken\n      arguments:\n        accessorId: 00000000-0000-0000-0000-000000000002\noutputs:\n  consulAclPolicies: ${test.policies}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAclToken.\n",
                "properties": {
                    "accessorId": {
                        "type": "string",
                        "description": "The accessor ID of the ACL token.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to lookup the ACL token.\n"
                    },
                    "partition": {
                        "type": "string",
                        "description": "The partition to lookup the ACL token.\n"
                    }
                },
                "type": "object",
                "required": [
                    "accessorId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAclToken.\n",
                "properties": {
                    "accessorId": {
                        "description": "The accessor ID of the ACL token.\n",
                        "type": "string"
                    },
                    "description": {
                        "description": "The description of the ACL token.\n",
                        "type": "string"
                    },
                    "expirationTime": {
                        "description": "If set this represents the point after which a token should be considered revoked and is eligible for destruction.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "local": {
                        "description": "Whether the ACL token is local to the datacenter it was created within.\n",
                        "type": "boolean"
                    },
                    "namespace": {
                        "description": "The namespace to lookup the ACL token.\n",
                        "type": "string"
                    },
                    "nodeIdentities": {
                        "description": "The list of node identities attached to the token.\n",
                        "items": {
                            "$ref": "#/types/consul:index/getAclTokenNodeIdentity:getAclTokenNodeIdentity"
                        },
                        "type": "array"
                    },
                    "partition": {
                        "description": "The partition to lookup the ACL token.\n",
                        "type": "string"
                    },
                    "policies": {
                        "description": "A list of policies associated with the ACL token.\n",
                        "items": {
                            "$ref": "#/types/consul:index/getAclTokenPolicy:getAclTokenPolicy"
                        },
                        "type": "array"
                    },
                    "roles": {
                        "description": "List of roles linked to the token\n",
                        "items": {
                            "$ref": "#/types/consul:index/getAclTokenRole:getAclTokenRole"
                        },
                        "type": "array"
                    },
                    "serviceIdentities": {
                        "description": "The list of service identities attached to the token.\n",
                        "items": {
                            "$ref": "#/types/consul:index/getAclTokenServiceIdentity:getAclTokenServiceIdentity"
                        },
                        "type": "array"
                    },
                    "templatedPolicies": {
                        "description": "The list of templated policies that should be applied to the token.\n",
                        "items": {
                            "$ref": "#/types/consul:index/getAclTokenTemplatedPolicy:getAclTokenTemplatedPolicy"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "accessorId",
                    "description",
                    "expirationTime",
                    "local",
                    "nodeIdentities",
                    "policies",
                    "roles",
                    "serviceIdentities",
                    "templatedPolicies",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getAclTokenSecretId:getAclTokenSecretId": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst test = new consul.AclPolicy(\"test\", {\n    name: \"test\",\n    rules: \"node \\\"\\\" { policy = \\\"read\\\" }\",\n    datacenters: [\"dc1\"],\n});\nconst testAclToken = new consul.AclToken(\"test\", {\n    description: \"test\",\n    policies: [test.name],\n    local: true,\n});\nconst read = consul.getAclTokenSecretIdOutput({\n    accessorId: testAclToken.id,\n    pgpKey: \"keybase:my_username\",\n});\nexport const consulAclTokenSecretId = read.apply(read =\u003e read.encryptedSecretId);\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\ntest = consul.AclPolicy(\"test\",\n    name=\"test\",\n    rules=\"node \\\"\\\" { policy = \\\"read\\\" }\",\n    datacenters=[\"dc1\"])\ntest_acl_token = consul.AclToken(\"test\",\n    description=\"test\",\n    policies=[test.name],\n    local=True)\nread = consul.get_acl_token_secret_id_output(accessor_id=test_acl_token.id,\n    pgp_key=\"keybase:my_username\")\npulumi.export(\"consulAclTokenSecretId\", read.encrypted_secret_id)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Consul.AclPolicy(\"test\", new()\n    {\n        Name = \"test\",\n        Rules = \"node \\\"\\\" { policy = \\\"read\\\" }\",\n        Datacenters = new[]\n        {\n            \"dc1\",\n        },\n    });\n\n    var testAclToken = new Consul.AclToken(\"test\", new()\n    {\n        Description = \"test\",\n        Policies = new[]\n        {\n            test.Name,\n        },\n        Local = true,\n    });\n\n    var read = Consul.GetAclTokenSecretId.Invoke(new()\n    {\n        AccessorId = testAclToken.Id,\n        PgpKey = \"keybase:my_username\",\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"consulAclTokenSecretId\"] = read.Apply(getAclTokenSecretIdResult =\u003e getAclTokenSecretIdResult.EncryptedSecretId),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttest, err := consul.NewAclPolicy(ctx, \"test\", \u0026consul.AclPolicyArgs{\n\t\t\tName:  pulumi.String(\"test\"),\n\t\t\tRules: pulumi.String(\"node \\\"\\\" { policy = \\\"read\\\" }\"),\n\t\t\tDatacenters: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"dc1\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestAclToken, err := consul.NewAclToken(ctx, \"test\", \u0026consul.AclTokenArgs{\n\t\t\tDescription: pulumi.String(\"test\"),\n\t\t\tPolicies: pulumi.StringArray{\n\t\t\t\ttest.Name,\n\t\t\t},\n\t\t\tLocal: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tread := consul.GetAclTokenSecretIdOutput(ctx, consul.GetAclTokenSecretIdOutputArgs{\n\t\t\tAccessorId: testAclToken.ID(),\n\t\t\tPgpKey:     pulumi.String(\"keybase:my_username\"),\n\t\t}, nil)\n\t\tctx.Export(\"consulAclTokenSecretId\", read.ApplyT(func(read consul.GetAclTokenSecretIdResult) (*string, error) {\n\t\t\treturn \u0026read.EncryptedSecretId, nil\n\t\t}).(pulumi.StringPtrOutput))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.AclPolicy;\nimport com.pulumi.consul.AclPolicyArgs;\nimport com.pulumi.consul.AclToken;\nimport com.pulumi.consul.AclTokenArgs;\nimport com.pulumi.consul.ConsulFunctions;\nimport com.pulumi.consul.inputs.GetAclTokenSecretIdArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new AclPolicy(\"test\", AclPolicyArgs.builder()\n            .name(\"test\")\n            .rules(\"node \\\"\\\" { policy = \\\"read\\\" }\")\n            .datacenters(\"dc1\")\n            .build());\n\n        var testAclToken = new AclToken(\"testAclToken\", AclTokenArgs.builder()\n            .description(\"test\")\n            .policies(test.name())\n            .local(true)\n            .build());\n\n        final var read = ConsulFunctions.getAclTokenSecretId(GetAclTokenSecretIdArgs.builder()\n            .accessorId(testAclToken.id())\n            .pgpKey(\"keybase:my_username\")\n            .build());\n\n        ctx.export(\"consulAclTokenSecretId\", read.applyValue(_read -\u003e _read.encryptedSecretId()));\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: consul:AclPolicy\n    properties:\n      name: test\n      rules: node \"\" { policy = \"read\" }\n      datacenters:\n        - dc1\n  testAclToken:\n    type: consul:AclToken\n    name: test\n    properties:\n      description: test\n      policies:\n        - ${test.name}\n      local: true\nvariables:\n  read:\n    fn::invoke:\n      function: consul:getAclTokenSecretId\n      arguments:\n        accessorId: ${testAclToken.id}\n        pgpKey: keybase:my_username\noutputs:\n  consulAclTokenSecretId: ${read.encryptedSecretId}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAclTokenSecretId.\n",
                "properties": {
                    "accessorId": {
                        "type": "string",
                        "description": "The accessor ID of the ACL token.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to lookup the token.\n"
                    },
                    "partition": {
                        "type": "string",
                        "description": "The partition to lookup the token.\n"
                    },
                    "pgpKey": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "accessorId"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getAclTokenSecretId.\n",
                "properties": {
                    "accessorId": {
                        "type": "string"
                    },
                    "encryptedSecretId": {
                        "secret": true,
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "partition": {
                        "type": "string"
                    },
                    "pgpKey": {
                        "type": "string"
                    },
                    "secretId": {
                        "description": "The secret ID of the ACL token if `pgp_key` has not been set.\n",
                        "secret": true,
                        "type": "string"
                    }
                },
                "required": [
                    "accessorId",
                    "encryptedSecretId",
                    "secretId",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getAgentConfig:getAgentConfig": {
            "description": "\u003e **Note:** The `consul.getAgentConfig` resource differs from [`consul.getAgentSelf`](https://www.terraform.io/docs/providers/consul/d/agent_self.html),\nproviding less information but utilizing stable APIs. `consul.getAgentSelf` will be\ndeprecated in a future release.\n\nThe `consul.getAgentConfig` data source returns\n[configuration data](https://www.consul.io/api/agent.html#read-configuration)\nfrom the agent specified in the `provider`.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst remoteAgent = consul.getAgentConfig({});\nexport const consulVersion = remoteAgent.then(remoteAgent =\u003e remoteAgent.version);\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\nremote_agent = consul.get_agent_config()\npulumi.export(\"consulVersion\", remote_agent.version)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var remoteAgent = Consul.GetAgentConfig.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"consulVersion\"] = remoteAgent.Apply(getAgentConfigResult =\u003e getAgentConfigResult.Version),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tremoteAgent, err := consul.GetAgentConfig(ctx, map[string]interface{}{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"consulVersion\", remoteAgent.Version)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConsulFunctions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var remoteAgent = ConsulFunctions.getAgentConfig(%!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);\n\n        ctx.export(\"consulVersion\", remoteAgent.version());\n    }\n}\n```\n```yaml\nvariables:\n  remoteAgent:\n    fn::invoke:\n      function: consul:getAgentConfig\n      arguments: {}\noutputs:\n  consulVersion: ${remoteAgent.version}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getAgentConfig.\n",
                "properties": {
                    "datacenter": {
                        "description": "The datacenter the agent is running in\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "nodeId": {
                        "description": "The ID of the node the agent is running on\n",
                        "type": "string"
                    },
                    "nodeName": {
                        "description": "The name of the node the agent is running on\n",
                        "type": "string"
                    },
                    "revision": {
                        "description": "The first 9 characters of the VCS revision of the build of Consul that is running\n",
                        "type": "string"
                    },
                    "server": {
                        "description": "Boolean if the agent is a server or not\n",
                        "type": "boolean"
                    },
                    "version": {
                        "description": "The version of the build of Consul that is running\n",
                        "type": "string"
                    }
                },
                "required": [
                    "datacenter",
                    "nodeId",
                    "nodeName",
                    "revision",
                    "server",
                    "version",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getAgentSelf:getAgentSelf": {
            "description": "\u003e **Warning:** The `consul.getAgentSelf` resource has been deprecated and will be removed\nfrom a future release of the provider. Read the [upgrade instructions](https://www.terraform.io/docs/providers/consul/guides/upgrading.html#deprecation-of-consul_agent_self) for more information.\n\n\nThe `consul.getAgentSelf` data source returns\n[configuration and status data](https://www.consul.io/docs/agent/http/agent.html#agent_self)\nfrom the agent specified in the `provider`.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nresources:\n  # Set the description to a whitespace delimited list of the services\n  app:\n    type: example:resource\n    properties:\n      description: Consul datacenter ${[\"read-dc1-agent\"].datacenter}\nvariables:\n  read-dc1-agent:\n    fn::invoke:\n      function: consul:getAgentSelf\n      arguments:\n        queryOptions:\n          - datacenter: dc1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "outputs": {
                "description": "A collection of values returned by getAgentSelf.\n",
                "properties": {
                    "aclDatacenter": {
                        "type": "string"
                    },
                    "aclDefaultPolicy": {
                        "type": "string"
                    },
                    "aclDisabledTtl": {
                        "description": "* [`acl_down_policy`](https://www.consul.io/docs/agent/options.html#acl_down_policy)\n* [`acl_enforce_0_8_semantics`](https://www.consul.io/docs/agent/options.html#acl_enforce_version_8)\n* [`acl_ttl`](https://www.consul.io/docs/agent/options.html#acl_ttl)\n* [`addresses`](https://www.consul.io/docs/agent/options.html#addresses)\n* [`advertise_addr`](https://www.consul.io/docs/agent/options.html#_advertise)\n* [`advertise_addr_wan`](https://www.consul.io/docs/agent/options.html#_advertise-wan)\n* [`advertise_addrs`](https://www.consul.io/docs/agent/options.html#advertise_addrs)\n* [`atlas_join`](https://www.consul.io/docs/agent/options.html#_atlas_join)\n* [`bind_addr`](https://www.consul.io/docs/agent/options.html#_bind)\n* [`bootstrap_expect`](https://www.consul.io/docs/agent/options.html#_bootstrap_expect)\n* [`bootstrap_mode`](https://www.consul.io/docs/agent/options.html#_bootstrap)\n",
                        "type": "string"
                    },
                    "aclDownPolicy": {
                        "type": "string"
                    },
                    "aclEnforce08Semantics": {
                        "type": "boolean"
                    },
                    "aclTtl": {
                        "type": "string"
                    },
                    "addresses": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "advertiseAddr": {
                        "type": "string"
                    },
                    "advertiseAddrWan": {
                        "type": "string"
                    },
                    "advertiseAddrs": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "atlasJoin": {
                        "type": "boolean"
                    },
                    "bindAddr": {
                        "type": "string"
                    },
                    "bootstrapExpect": {
                        "type": "integer"
                    },
                    "bootstrapMode": {
                        "type": "boolean"
                    },
                    "checkDeregisterIntervalMin": {
                        "type": "string"
                    },
                    "checkReapInterval": {
                        "description": "* [`check_update_interval`](https://www.consul.io/docs/agent/options.html#check_update_interval)\n* [`client_addr`](https://www.consul.io/docs/agent/options.html#_client)\n",
                        "type": "string"
                    },
                    "checkUpdateInterval": {
                        "type": "string"
                    },
                    "clientAddr": {
                        "type": "string"
                    },
                    "dataDir": {
                        "type": "string"
                    },
                    "datacenter": {
                        "type": "string"
                    },
                    "devMode": {
                        "type": "boolean"
                    },
                    "dns": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of DNS configuration attributes.  See below for details on the\ncontents of the `dns` attribute.\n* [`dns_recursors`](https://www.consul.io/docs/agent/options.html#recursors) - A\nlist of all DNS recursors.\n* [`data_dir`](https://www.consul.io/docs/agent/options.html#_data_dir)\n* [`datacenter`](https://www.consul.io/docs/agent/options.html#_datacenter)\n* [`dev_mode`](https://www.consul.io/docs/agent/options.html#_dev)\n* [`domain`](https://www.consul.io/docs/agent/options.html#_domain)\n* [`enable_anonymous_signature`](https://www.consul.io/docs/agent/options.html#disable_anonymous_signature)\n",
                        "type": "object"
                    },
                    "dnsRecursors": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "domain": {
                        "type": "string"
                    },
                    "enableAnonymousSignature": {
                        "type": "boolean"
                    },
                    "enableCoordinates": {
                        "description": "* [`enable_debug`](https://www.consul.io/docs/agent/options.html#enable_debug)\n* [`enable_remote_exec`](https://www.consul.io/docs/agent/options.html#disable_remote_exec)\n* [`enable_syslog`](https://www.consul.io/docs/agent/options.html#_syslog)\n* [`enable_ui`](https://www.consul.io/docs/agent/options.html#_ui)\n* [`enable_update_check`](https://www.consul.io/docs/agent/options.html#disable_update_check)\n* [`id`](https://www.consul.io/docs/agent/options.html#_node_id)\n* [`leave_on_int`](https://www.consul.io/docs/agent/options.html#skip_leave_on_interrupt)\n* [`leave_on_term`](https://www.consul.io/docs/agent/options.html#leave_on_terminate)\n* [`log_level`](https://www.consul.io/docs/agent/options.html#_log_level)\n* [`name`](https://www.consul.io/docs/agent/options.html#_node)\n* [`performance`](https://www.consul.io/docs/agent/options.html#performance)\n* [`pid_file`](https://www.consul.io/docs/agent/options.html#_pid_file)\n* [`ports`](https://www.consul.io/docs/agent/options.html#ports)\n* [`protocol_version`](https://www.consul.io/docs/agent/options.html#_protocol)\n* [`reconnect_timeout_lan`](https://www.consul.io/docs/agent/options.html#reconnect_timeout)\n* [`reconnect_timeout_wan`](https://www.consul.io/docs/agent/options.html#reconnect_timeout_wan)\n* [`rejoin_after_leave`](https://www.consul.io/docs/agent/options.html#_rejoin)\n* [`retry_join`](https://www.consul.io/docs/agent/options.html#retry_join)\n* [`retry_join_ec2`](https://www.consul.io/docs/agent/options.html#retry_join_ec2) -\nA map of EC2 retry attributes.  See below for details on the available\ninformation.\n* [`retry_join_gce`](https://www.consul.io/docs/agent/options.html#retry_join_gce) -\nA map of GCE retry attributes.  See below for details on the available\ninformation.\n* [`retry_join_wan`](https://www.consul.io/docs/agent/options.html#_retry_join_wan)\n* [`retry_max_attempts`](https://www.consul.io/docs/agent/options.html#_retry_max)\n* [`retry_max_attempts_wan`](https://www.consul.io/docs/agent/options.html#_retry_max_wan)\n* [`serf_lan_bind_addr`](https://www.consul.io/docs/agent/options.html#_serf_lan_bind)\n* [`serf_wan_bind_addr`](https://www.consul.io/docs/agent/options.html#_serf_wan_bind)\n* [`server_mode`](https://www.consul.io/docs/agent/options.html#_server)\n* [`server_name`](https://www.consul.io/docs/agent/options.html#server_name)\n* [`session_ttl_min`](https://www.consul.io/docs/agent/options.html#session_ttl_min)\n* [`start_join`](https://www.consul.io/docs/agent/options.html#start_join)\n* [`start_join_wan`](https://www.consul.io/docs/agent/options.html#start_join_wan)\n* [`syslog_facility`](https://www.consul.io/docs/agent/options.html#syslog_facility)\n* [`tls_ca_file`](https://www.consul.io/docs/agent/options.html#ca_file)\n* [`tls_cert_file`](https://www.consul.io/docs/agent/options.html#cert_file)\n* [`tls_key_file`](https://www.consul.io/docs/agent/options.html#key_file)\n* [`tls_min_version`](https://www.consul.io/docs/agent/options.html#tls_min_version)\n* [`tls_verify_incoming`](https://www.consul.io/docs/agent/options.html#verify_incoming)\n* [`tls_verify_outgoing`](https://www.consul.io/docs/agent/options.html#verify_outgoing)\n* [`tls_verify_server_hostname`](https://www.consul.io/docs/agent/options.html#verify_server_hostname)\n* [`tagged_addresses`](https://www.consul.io/docs/agent/options.html#translate_wan_addrs)\n* [`telemetry`](https://www.consul.io/docs/agent/options.html#telemetry) - A map\nof telemetry configuration.\n* [`translate_wan_addrs`](https://www.consul.io/docs/agent/options.html#translate_wan_addrs)\n* [`ui_dir`](https://www.consul.io/docs/agent/options.html#ui_dir)\n* [`unix_sockets`](https://www.consul.io/docs/agent/options.html#unix_sockets)\n",
                        "type": "boolean"
                    },
                    "enableDebug": {
                        "type": "boolean"
                    },
                    "enableRemoteExec": {
                        "type": "boolean"
                    },
                    "enableSyslog": {
                        "type": "boolean"
                    },
                    "enableUi": {
                        "type": "boolean"
                    },
                    "enableUpdateCheck": {
                        "type": "boolean"
                    },
                    "id": {
                        "type": "string"
                    },
                    "leaveOnInt": {
                        "type": "boolean"
                    },
                    "leaveOnTerm": {
                        "type": "boolean"
                    },
                    "logLevel": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string"
                    },
                    "performance": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "pidFile": {
                        "type": "string"
                    },
                    "ports": {
                        "additionalProperties": {
                            "type": "integer"
                        },
                        "type": "object"
                    },
                    "protocolVersion": {
                        "type": "integer"
                    },
                    "reconnectTimeoutLan": {
                        "type": "string"
                    },
                    "reconnectTimeoutWan": {
                        "type": "string"
                    },
                    "rejoinAfterLeave": {
                        "type": "boolean"
                    },
                    "retryJoinEc2": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "retryJoinGce": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "retryJoinWans": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "retryJoins": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "retryMaxAttempts": {
                        "type": "integer"
                    },
                    "retryMaxAttemptsWan": {
                        "type": "integer"
                    },
                    "serfLanBindAddr": {
                        "type": "string"
                    },
                    "serfWanBindAddr": {
                        "type": "string"
                    },
                    "serverMode": {
                        "type": "boolean"
                    },
                    "serverName": {
                        "type": "string"
                    },
                    "sessionTtlMin": {
                        "type": "string"
                    },
                    "startJoinWans": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "startJoins": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "syslogFacility": {
                        "type": "string"
                    },
                    "taggedAddresses": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "telemetry": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "tlsCaFile": {
                        "type": "string"
                    },
                    "tlsCertFile": {
                        "type": "string"
                    },
                    "tlsKeyFile": {
                        "type": "string"
                    },
                    "tlsMinVersion": {
                        "type": "string"
                    },
                    "tlsVerifyIncoming": {
                        "type": "boolean"
                    },
                    "tlsVerifyOutgoing": {
                        "type": "boolean"
                    },
                    "tlsVerifyServerHostname": {
                        "type": "boolean"
                    },
                    "translateWanAddrs": {
                        "type": "boolean"
                    },
                    "uiDir": {
                        "type": "string"
                    },
                    "unixSockets": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "version": {
                        "description": "The version of the Consul agent.\n",
                        "type": "string"
                    },
                    "versionPrerelease": {
                        "type": "string"
                    },
                    "versionRevision": {
                        "type": "string"
                    }
                },
                "required": [
                    "aclDatacenter",
                    "aclDefaultPolicy",
                    "aclDisabledTtl",
                    "aclDownPolicy",
                    "aclEnforce08Semantics",
                    "aclTtl",
                    "addresses",
                    "advertiseAddr",
                    "advertiseAddrWan",
                    "advertiseAddrs",
                    "atlasJoin",
                    "bindAddr",
                    "bootstrapExpect",
                    "bootstrapMode",
                    "checkDeregisterIntervalMin",
                    "checkReapInterval",
                    "checkUpdateInterval",
                    "clientAddr",
                    "dataDir",
                    "datacenter",
                    "devMode",
                    "dns",
                    "dnsRecursors",
                    "domain",
                    "enableAnonymousSignature",
                    "enableCoordinates",
                    "enableDebug",
                    "enableRemoteExec",
                    "enableSyslog",
                    "enableUi",
                    "enableUpdateCheck",
                    "id",
                    "leaveOnInt",
                    "leaveOnTerm",
                    "logLevel",
                    "name",
                    "performance",
                    "pidFile",
                    "ports",
                    "protocolVersion",
                    "reconnectTimeoutLan",
                    "reconnectTimeoutWan",
                    "rejoinAfterLeave",
                    "retryJoins",
                    "retryJoinEc2",
                    "retryJoinGce",
                    "retryJoinWans",
                    "retryMaxAttempts",
                    "retryMaxAttemptsWan",
                    "serfLanBindAddr",
                    "serfWanBindAddr",
                    "serverMode",
                    "serverName",
                    "sessionTtlMin",
                    "startJoins",
                    "startJoinWans",
                    "syslogFacility",
                    "taggedAddresses",
                    "telemetry",
                    "tlsCaFile",
                    "tlsCertFile",
                    "tlsKeyFile",
                    "tlsMinVersion",
                    "tlsVerifyIncoming",
                    "tlsVerifyOutgoing",
                    "tlsVerifyServerHostname",
                    "translateWanAddrs",
                    "uiDir",
                    "unixSockets",
                    "version",
                    "versionPrerelease",
                    "versionRevision"
                ],
                "type": "object"
            }
        },
        "consul:index/getAutopilotHealth:getAutopilotHealth": {
            "description": "The `consul.getAutopilotHealth` data source returns\n[autopilot health information](https://www.consul.io/api/operator/autopilot.html#read-health)\nabout the current Consul cluster.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst read = consul.getAutopilotHealth({});\nexport const health = read.then(read =\u003e read.healthy);\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\nread = consul.get_autopilot_health()\npulumi.export(\"health\", read.healthy)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var read = Consul.GetAutopilotHealth.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"health\"] = read.Apply(getAutopilotHealthResult =\u003e getAutopilotHealthResult.Healthy),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tread, err := consul.GetAutopilotHealth(ctx, \u0026consul.GetAutopilotHealthArgs{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"health\", read.Healthy)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConsulFunctions;\nimport com.pulumi.consul.inputs.GetAutopilotHealthArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var read = ConsulFunctions.getAutopilotHealth(GetAutopilotHealthArgs.builder()\n            .build());\n\n        ctx.export(\"health\", read.healthy());\n    }\n}\n```\n```yaml\nvariables:\n  read:\n    fn::invoke:\n      function: consul:getAutopilotHealth\n      arguments: {}\noutputs:\n  health: ${read.healthy}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getAutopilotHealth.\n",
                "properties": {
                    "datacenter": {
                        "type": "string",
                        "description": "The datacenter to use. This overrides the agent's\ndefault datacenter and the datacenter in the provider setup.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAutopilotHealth.\n",
                "properties": {
                    "datacenter": {
                        "type": "string"
                    },
                    "failureTolerance": {
                        "description": "The number of redundant healthy servers that could fail\nwithout causing an outage\n",
                        "type": "integer"
                    },
                    "healthy": {
                        "description": "Whether the server is healthy according to the current Autopilot\nconfiguration\n",
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "servers": {
                        "description": "A list of server health information. See below for details on the\navailable information.\n",
                        "items": {
                            "$ref": "#/types/consul:index/getAutopilotHealthServer:getAutopilotHealthServer"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "failureTolerance",
                    "healthy",
                    "servers",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getCatalogNodes:getCatalogNodes": {
            "deprecationMessage": "getCatalogNodes has been deprecated in favor of getNodes",
            "description": "The `consul.getNodes` data source returns a list of Consul nodes that have\nbeen registered with the Consul cluster in a given datacenter.  By specifying a\ndifferent datacenter in the `query_options` it is possible to retrieve a list of\nnodes from a different WAN-attached Consul datacenter.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCatalogNodes.\n",
                "properties": {
                    "queryOptions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/getCatalogNodesQueryOption:getCatalogNodesQueryOption"
                        },
                        "description": "See below.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCatalogNodes.\n",
                "properties": {
                    "datacenter": {
                        "description": "The datacenter the keys are being read from to.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "nodeIds": {
                        "description": "A list of the Consul node IDs.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "nodeNames": {
                        "description": "A list of the Consul node names.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "nodes": {
                        "description": "A list of nodes and details about each Consul agent.  The list of\nper-node attributes is detailed below.\n",
                        "items": {
                            "$ref": "#/types/consul:index/getCatalogNodesNode:getCatalogNodesNode"
                        },
                        "type": "array"
                    },
                    "queryOptions": {
                        "items": {
                            "$ref": "#/types/consul:index/getCatalogNodesQueryOption:getCatalogNodesQueryOption"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "datacenter",
                    "nodeIds",
                    "nodeNames",
                    "nodes",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getCatalogService:getCatalogService": {
            "deprecationMessage": "getCatalogService has been deprecated in favor of getService",
            "description": "`consul.Service` provides details about a specific Consul service in a\ngiven datacenter.  The results include a list of nodes advertising the specified\nservice, the node's IP address, port number, node ID, etc.  By specifying a\ndifferent datacenter in the `query_options` it is possible to retrieve a list of\nservices from a different WAN-attached Consul datacenter.\n\nThis data source is different from the `consul.getServices` (plural) data\nsource, which provides a summary of the current Consul services.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\nimport * as example from \"@pulumi/example\";\nimport * as std from \"@pulumi/std\";\n\nconst read_consul_dc1 = consul.getService({\n    name: \"consul\",\n    datacenter: \"dc1\",\n});\n// Set the description to a whitespace delimited list of the node names\nconst app = new example.index.Resource(\"app\", {description: std.join({\n    separator: \" \",\n    input: nodes,\n}).result});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\nimport pulumi_example as example\nimport pulumi_std as std\n\nread_consul_dc1 = consul.get_service(name=\"consul\",\n    datacenter=\"dc1\")\n# Set the description to a whitespace delimited list of the node names\napp = example.index.Resource(\"app\", description=std.join(separator= ,\n    input=nodes).result)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\nusing Example = Pulumi.Example;\nusing Std = Pulumi.Std;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var read_consul_dc1 = Consul.GetService.Invoke(new()\n    {\n        Name = \"consul\",\n        Datacenter = \"dc1\",\n    });\n\n    // Set the description to a whitespace delimited list of the node names\n    var app = new Example.Index.Resource(\"app\", new()\n    {\n        Description = Std.Join.Invoke(new()\n        {\n            Separator = \" \",\n            Input = nodes,\n        }).Result,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi-example/sdk/go/example\"\n\t\"github.com/pulumi/pulumi-std/sdk/go/std\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.LookupService(ctx, \u0026consul.LookupServiceArgs{\n\t\t\tName:       \"consul\",\n\t\t\tDatacenter: pulumi.StringRef(\"dc1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Set the description to a whitespace delimited list of the node names\n\t\t_, err = example.NewResource(ctx, \"app\", \u0026example.ResourceArgs{\n\t\t\tDescription: std.Join(ctx, \u0026std.JoinArgs{\n\t\t\t\tSeparator: \" \",\n\t\t\t\tInput:     nodes,\n\t\t\t}, nil).Result,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConsulFunctions;\nimport com.pulumi.consul.inputs.GetServiceArgs;\nimport com.pulumi.example.resource;\nimport com.pulumi.example.resourceArgs;\nimport com.pulumi.std.StdFunctions;\nimport com.pulumi.std.inputs.JoinArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var read-consul-dc1 = ConsulFunctions.getService(GetServiceArgs.builder()\n            .name(\"consul\")\n            .datacenter(\"dc1\")\n            .build());\n\n        // Set the description to a whitespace delimited list of the node names\n        var app = new Resource(\"app\", ResourceArgs.builder()\n            .description(StdFunctions.join(JoinArgs.builder()\n                .separator(\" \")\n                .input(nodes)\n                .build()).result())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Set the description to a whitespace delimited list of the node names\n  app:\n    type: example:resource\n    properties:\n      description:\n        fn::invoke:\n          function: std:join\n          arguments:\n            separator: ' '\n            input: ${nodes}\n          return: result\nvariables:\n  read-consul-dc1:\n    fn::invoke:\n      function: consul:getService\n      arguments:\n        name: consul\n        datacenter: dc1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCatalogService.\n",
                "properties": {
                    "datacenter": {
                        "type": "string",
                        "description": "The Consul datacenter to query.  Defaults to the\nsame value found in `query_options` parameter specified below, or if that is\nempty, the `datacenter` value found in the Consul agent that this provider is\nconfigured to talk to.\n"
                    },
                    "filter": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "The service name to select.\n"
                    },
                    "queryOptions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/getCatalogServiceQueryOption:getCatalogServiceQueryOption"
                        },
                        "description": "See below.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "A single tag that can be used to filter the list of nodes\nto return based on a single matching tag..\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getCatalogService.\n",
                "properties": {
                    "datacenter": {
                        "description": "The datacenter the keys are being read from to.\n",
                        "type": "string"
                    },
                    "filter": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the service\n",
                        "type": "string"
                    },
                    "queryOptions": {
                        "items": {
                            "$ref": "#/types/consul:index/getCatalogServiceQueryOption:getCatalogServiceQueryOption"
                        },
                        "type": "array"
                    },
                    "services": {
                        "description": "A list of nodes and details about each endpoint advertising a\nservice.  Each element in the list is a map of attributes that correspond to\neach individual node.  The list of per-node attributes is detailed below.\n",
                        "items": {
                            "$ref": "#/types/consul:index/getCatalogServiceService:getCatalogServiceService"
                        },
                        "type": "array"
                    },
                    "tag": {
                        "description": "The name of the tag used to filter the list of nodes in `service`.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "name",
                    "services",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getCatalogServices:getCatalogServices": {
            "deprecationMessage": "getCatalogServices has been deprecated in favor of getServices",
            "description": "The `consul.getServices` data source returns a list of Consul services that\nhave been registered with the Consul cluster in a given datacenter.  By\nspecifying a different datacenter in the `query_options` it is possible to\nretrieve a list of services from a different WAN-attached Consul datacenter.\n\nThis data source is different from the `consul.Service` (singular) data\nsource, which provides a detailed response about a specific Consul service.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\nimport * as example from \"@pulumi/example\";\nimport * as std from \"@pulumi/std\";\n\nconst read_dc1 = consul.getServices({\n    queryOptions: [{\n        datacenter: \"dc1\",\n    }],\n});\n// Set the description to a whitespace delimited list of the services\nconst app = new example.index.Resource(\"app\", {description: std.join({\n    separator: \" \",\n    input: names,\n}).result});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\nimport pulumi_example as example\nimport pulumi_std as std\n\nread_dc1 = consul.get_services(query_options=[{\n    \"datacenter\": \"dc1\",\n}])\n# Set the description to a whitespace delimited list of the services\napp = example.index.Resource(\"app\", description=std.join(separator= ,\n    input=names).result)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\nusing Example = Pulumi.Example;\nusing Std = Pulumi.Std;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var read_dc1 = Consul.GetServices.Invoke(new()\n    {\n        QueryOptions = new[]\n        {\n            new Consul.Inputs.GetServicesQueryOptionInputArgs\n            {\n                Datacenter = \"dc1\",\n            },\n        },\n    });\n\n    // Set the description to a whitespace delimited list of the services\n    var app = new Example.Index.Resource(\"app\", new()\n    {\n        Description = Std.Join.Invoke(new()\n        {\n            Separator = \" \",\n            Input = names,\n        }).Result,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi-example/sdk/go/example\"\n\t\"github.com/pulumi/pulumi-std/sdk/go/std\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.GetServices(ctx, \u0026consul.GetServicesArgs{\n\t\t\tQueryOptions: []consul.GetServicesQueryOption{\n\t\t\t\t{\n\t\t\t\t\tDatacenter: pulumi.StringRef(\"dc1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Set the description to a whitespace delimited list of the services\n\t\t_, err = example.NewResource(ctx, \"app\", \u0026example.ResourceArgs{\n\t\t\tDescription: std.Join(ctx, \u0026std.JoinArgs{\n\t\t\t\tSeparator: \" \",\n\t\t\t\tInput:     names,\n\t\t\t}, nil).Result,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConsulFunctions;\nimport com.pulumi.consul.inputs.GetServicesArgs;\nimport com.pulumi.example.resource;\nimport com.pulumi.example.resourceArgs;\nimport com.pulumi.std.StdFunctions;\nimport com.pulumi.std.inputs.JoinArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var read-dc1 = ConsulFunctions.getServices(GetServicesArgs.builder()\n            .queryOptions(GetServicesQueryOptionArgs.builder()\n                .datacenter(\"dc1\")\n                .build())\n            .build());\n\n        // Set the description to a whitespace delimited list of the services\n        var app = new Resource(\"app\", ResourceArgs.builder()\n            .description(StdFunctions.join(JoinArgs.builder()\n                .separator(\" \")\n                .input(names)\n                .build()).result())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Set the description to a whitespace delimited list of the services\n  app:\n    type: example:resource\n    properties:\n      description:\n        fn::invoke:\n          function: std:join\n          arguments:\n            separator: ' '\n            input: ${names}\n          return: result\nvariables:\n  read-dc1:\n    fn::invoke:\n      function: consul:getServices\n      arguments:\n        queryOptions:\n          - datacenter: dc1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getCatalogServices.\n",
                "properties": {
                    "queryOptions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/getCatalogServicesQueryOption:getCatalogServicesQueryOption"
                        },
                        "description": "See below.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getCatalogServices.\n",
                "properties": {
                    "datacenter": {
                        "description": "The datacenter the keys are being read from to.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "names": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "queryOptions": {
                        "items": {
                            "$ref": "#/types/consul:index/getCatalogServicesQueryOption:getCatalogServicesQueryOption"
                        },
                        "type": "array"
                    },
                    "services": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "tags": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of the tags found for each service.  If more than one service\nshares the same tag, unique service names will be joined by whitespace (this\nis the inverse of `services` and can be used to lookup the services that match\na single tag).\n",
                        "type": "object"
                    }
                },
                "required": [
                    "datacenter",
                    "names",
                    "services",
                    "tags",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getConfigEntry:getConfigEntry": {
            "inputs": {
                "description": "A collection of arguments for invoking getConfigEntry.\n",
                "properties": {
                    "kind": {
                        "type": "string",
                        "description": "The kind of config entry to read.\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the config entry to read.\n",
                        "willReplaceOnChanges": true
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace the config entry is associated with.\n",
                        "willReplaceOnChanges": true
                    },
                    "partition": {
                        "type": "string",
                        "description": "The partition the config entry is associated with.\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object",
                "required": [
                    "kind",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getConfigEntry.\n",
                "properties": {
                    "configJson": {
                        "description": "The configuration of the config entry.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "kind": {
                        "description": "The kind of config entry to read.\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the config entry to read.\n",
                        "type": "string"
                    },
                    "namespace": {
                        "description": "The namespace the config entry is associated with.\n",
                        "type": "string"
                    },
                    "partition": {
                        "description": "The partition the config entry is associated with.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "configJson",
                    "kind",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getConfigEntryV2ExportedServices:getConfigEntryV2ExportedServices": {
            "inputs": {
                "description": "A collection of arguments for invoking getConfigEntryV2ExportedServices.\n",
                "properties": {
                    "kind": {
                        "type": "string",
                        "description": "The kind of exported services config (ExportedServices, NamespaceExportedServices, PartitionExportedServices).\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the config entry to read.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace the config entry is associated with.\n"
                    },
                    "partition": {
                        "type": "string",
                        "description": "The partition the config entry is associated with.\n"
                    },
                    "partitionConsumers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The exported service partition consumers.\n"
                    },
                    "peerConsumers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The exported service peer consumers.\n"
                    },
                    "samenessGroupConsumers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The exported service sameness group consumers.\n"
                    },
                    "services": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "The exported services.\n"
                    }
                },
                "type": "object",
                "required": [
                    "kind",
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getConfigEntryV2ExportedServices.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "kind": {
                        "description": "The kind of exported services config (ExportedServices, NamespaceExportedServices, PartitionExportedServices).\n",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the config entry to read.\n",
                        "type": "string"
                    },
                    "namespace": {
                        "description": "The namespace the config entry is associated with.\n",
                        "type": "string"
                    },
                    "partition": {
                        "description": "The partition the config entry is associated with.\n",
                        "type": "string"
                    },
                    "partitionConsumers": {
                        "description": "The exported service partition consumers.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "peerConsumers": {
                        "description": "The exported service peer consumers.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "samenessGroupConsumers": {
                        "description": "The exported service sameness group consumers.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "services": {
                        "description": "The exported services.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "kind",
                    "name",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getDatacenters:getDatacenters": {
            "description": "The `consul.getDatacenters` data source returns the list of all knwown Consul\ndatacenters.\n\n",
            "outputs": {
                "description": "A collection of values returned by getDatacenters.\n",
                "properties": {
                    "datacenters": {
                        "description": "The list of datacenters known. The datacenters will be sorted\nin ascending order based on the estimated median round trip time from the server\nto the servers in that datacenter.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    }
                },
                "required": [
                    "datacenters",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getKeyPrefix:getKeyPrefix": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\nimport * as consul from \"@pulumi/consul\";\n\nconst app = consul.getKeyPrefix({\n    datacenter: \"nyc1\",\n    token: \"abcd\",\n    pathPrefix: \"myapp/config/\",\n    subkeyCollection: [{\n        name: \"ami\",\n        path: \"app/launch_ami\",\n        \"default\": \"ami-1234\",\n    }],\n});\n// Start our instance with the dynamic ami value\nconst appInstance = new aws.index.Instance(\"app\", {ami: app[\"var\"]?.ami});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\nimport pulumi_consul as consul\n\napp = consul.get_key_prefix(datacenter=\"nyc1\",\n    token=\"abcd\",\n    path_prefix=\"myapp/config/\",\n    subkey_collection=[{\n        \"name\": \"ami\",\n        \"path\": \"app/launch_ami\",\n        \"default\": \"ami-1234\",\n    }])\n# Start our instance with the dynamic ami value\napp_instance = aws.index.Instance(\"app\", ami=app.var.ami)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var app = Consul.GetKeyPrefix.Invoke(new()\n    {\n        Datacenter = \"nyc1\",\n        Token = \"abcd\",\n        PathPrefix = \"myapp/config/\",\n        SubkeyCollection = new[]\n        {\n            new Consul.Inputs.GetKeyPrefixSubkeyCollectionInputArgs\n            {\n                Name = \"ami\",\n                Path = \"app/launch_ami\",\n                Default = \"ami-1234\",\n            },\n        },\n    });\n\n    // Start our instance with the dynamic ami value\n    var appInstance = new Aws.Index.Instance(\"app\", new()\n    {\n        Ami = app.Apply(getKeyPrefixResult =\u003e getKeyPrefixResult.Var?.Ami),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v4/go/aws\"\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tapp, err := consul.LookupKeyPrefix(ctx, \u0026consul.LookupKeyPrefixArgs{\n\t\t\tDatacenter: pulumi.StringRef(\"nyc1\"),\n\t\t\tToken:      pulumi.StringRef(\"abcd\"),\n\t\t\tPathPrefix: \"myapp/config/\",\n\t\t\tSubkeyCollection: []consul.GetKeyPrefixSubkeyCollection{\n\t\t\t\t{\n\t\t\t\t\tName:    \"ami\",\n\t\t\t\t\tPath:    \"app/launch_ami\",\n\t\t\t\t\tDefault: pulumi.StringRef(\"ami-1234\"),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Start our instance with the dynamic ami value\n\t\t_, err = aws.NewInstance(ctx, \"app\", \u0026aws.InstanceArgs{\n\t\t\tAmi: app.Var.Ami,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConsulFunctions;\nimport com.pulumi.consul.inputs.GetKeyPrefixArgs;\nimport com.pulumi.aws.instance;\nimport com.pulumi.aws.instanceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var app = ConsulFunctions.getKeyPrefix(GetKeyPrefixArgs.builder()\n            .datacenter(\"nyc1\")\n            .token(\"abcd\")\n            .pathPrefix(\"myapp/config/\")\n            .subkeyCollection(GetKeyPrefixSubkeyCollectionArgs.builder()\n                .name(\"ami\")\n                .path(\"app/launch_ami\")\n                .default_(\"ami-1234\")\n                .build())\n            .build());\n\n        // Start our instance with the dynamic ami value\n        var appInstance = new Instance(\"appInstance\", InstanceArgs.builder()\n            .ami(app.var().ami())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Start our instance with the dynamic ami value\n  appInstance:\n    type: aws:instance\n    name: app\n    properties:\n      ami: ${app.var.ami}\nvariables:\n  app:\n    fn::invoke:\n      function: consul:getKeyPrefix\n      arguments:\n        datacenter: nyc1\n        token: abcd\n        pathPrefix: myapp/config/\n        subkeyCollection:\n          - name: ami\n            path: app/launch_ami\n            default: ami-1234\n```\n\u003c!--End PulumiCodeChooser --\u003e\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\nimport * as consul from \"@pulumi/consul\";\n\nconst web = consul.getKeyPrefix({\n    datacenter: \"nyc1\",\n    token: \"efgh\",\n    pathPrefix: \"myapp/config/\",\n});\n// Start our instance with the dynamic ami value\nconst webInstance = new aws.index.Instance(\"web\", {ami: web.subkeys?.[\"app/launch_ami\"]});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\nimport pulumi_consul as consul\n\nweb = consul.get_key_prefix(datacenter=\"nyc1\",\n    token=\"efgh\",\n    path_prefix=\"myapp/config/\")\n# Start our instance with the dynamic ami value\nweb_instance = aws.index.Instance(\"web\", ami=web.subkeys.app_launch_ami)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var web = Consul.GetKeyPrefix.Invoke(new()\n    {\n        Datacenter = \"nyc1\",\n        Token = \"efgh\",\n        PathPrefix = \"myapp/config/\",\n    });\n\n    // Start our instance with the dynamic ami value\n    var webInstance = new Aws.Index.Instance(\"web\", new()\n    {\n        Ami = web.Apply(getKeyPrefixResult =\u003e getKeyPrefixResult.Subkeys?.App_launch_ami),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v4/go/aws\"\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tweb, err := consul.LookupKeyPrefix(ctx, \u0026consul.LookupKeyPrefixArgs{\n\t\t\tDatacenter: pulumi.StringRef(\"nyc1\"),\n\t\t\tToken:      pulumi.StringRef(\"efgh\"),\n\t\t\tPathPrefix: \"myapp/config/\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Start our instance with the dynamic ami value\n\t\t_, err = aws.NewInstance(ctx, \"web\", \u0026aws.InstanceArgs{\n\t\t\tAmi: web.Subkeys.App / launch_ami,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConsulFunctions;\nimport com.pulumi.consul.inputs.GetKeyPrefixArgs;\nimport com.pulumi.aws.instance;\nimport com.pulumi.aws.instanceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var web = ConsulFunctions.getKeyPrefix(GetKeyPrefixArgs.builder()\n            .datacenter(\"nyc1\")\n            .token(\"efgh\")\n            .pathPrefix(\"myapp/config/\")\n            .build());\n\n        // Start our instance with the dynamic ami value\n        var webInstance = new Instance(\"webInstance\", InstanceArgs.builder()\n            .ami(web.subkeys().app/launch_ami())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Start our instance with the dynamic ami value\n  webInstance:\n    type: aws:instance\n    name: web\n    properties:\n      ami: ${web.subkeys\"app/launch_ami\"[%!s(MISSING)]}\nvariables:\n  web:\n    fn::invoke:\n      function: consul:getKeyPrefix\n      arguments:\n        datacenter: nyc1\n        token: efgh\n        pathPrefix: myapp/config/\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getKeyPrefix.\n",
                "properties": {
                    "datacenter": {
                        "type": "string",
                        "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to lookup the keys within.\n"
                    },
                    "partition": {
                        "type": "string",
                        "description": "The namespace to lookup the keys within.\n"
                    },
                    "pathPrefix": {
                        "type": "string",
                        "description": "Specifies the common prefix shared by all keys\nthat will be read by this data source instance. In most cases, this will\nend with a slash to read a \"folder\" of subkeys.\n"
                    },
                    "subkeyCollection": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/getKeyPrefixSubkeyCollection:getKeyPrefixSubkeyCollection"
                        },
                        "description": "Specifies a subkey in Consul to be read. Supported\nvalues documented below. Multiple blocks supported.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The ACL token to use. This overrides the\ntoken that the agent provides by default.\n",
                        "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                        "secret": true
                    }
                },
                "type": "object",
                "required": [
                    "pathPrefix"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getKeyPrefix.\n",
                "properties": {
                    "datacenter": {
                        "description": "The datacenter the keys are being read from.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "namespace": {
                        "type": "string"
                    },
                    "partition": {
                        "type": "string"
                    },
                    "pathPrefix": {
                        "description": "the common prefix shared by all keys being read.\n* `var.\u003cname\u003e` - For each name given, the corresponding attribute\nhas the value of the key.\n",
                        "type": "string"
                    },
                    "subkeyCollection": {
                        "items": {
                            "$ref": "#/types/consul:index/getKeyPrefixSubkeyCollection:getKeyPrefixSubkeyCollection"
                        },
                        "type": "array"
                    },
                    "subkeys": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of the subkeys and values is set if no `subkey`\nblock is provided.\n",
                        "type": "object"
                    },
                    "token": {
                        "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                        "secret": true,
                        "type": "string"
                    },
                    "var": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    }
                },
                "required": [
                    "datacenter",
                    "pathPrefix",
                    "subkeys",
                    "var",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getKeys:getKeys": {
            "description": "The `consul.Keys` datasource reads values from the Consul key/value store. This is a powerful way to dynamically set values in templates.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as aws from \"@pulumi/aws\";\nimport * as consul from \"@pulumi/consul\";\n\nconst app = consul.getKeys({\n    datacenter: \"nyc1\",\n    keys: [{\n        name: \"ami\",\n        path: \"service/app/launch_ami\",\n        \"default\": \"ami-1234\",\n    }],\n});\n// Start our instance with the dynamic ami value\nconst appInstance = new aws.index.Instance(\"app\", {ami: app[\"var\"]?.ami});\n```\n```python\nimport pulumi\nimport pulumi_aws as aws\nimport pulumi_consul as consul\n\napp = consul.get_keys(datacenter=\"nyc1\",\n    keys=[{\n        \"name\": \"ami\",\n        \"path\": \"service/app/launch_ami\",\n        \"default\": \"ami-1234\",\n    }])\n# Start our instance with the dynamic ami value\napp_instance = aws.index.Instance(\"app\", ami=app.var.ami)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Aws = Pulumi.Aws;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var app = Consul.GetKeys.Invoke(new()\n    {\n        Datacenter = \"nyc1\",\n        Keys = new[]\n        {\n            new Consul.Inputs.GetKeysKeyInputArgs\n            {\n                Name = \"ami\",\n                Path = \"service/app/launch_ami\",\n                Default = \"ami-1234\",\n            },\n        },\n    });\n\n    // Start our instance with the dynamic ami value\n    var appInstance = new Aws.Index.Instance(\"app\", new()\n    {\n        Ami = app.Apply(getKeysResult =\u003e getKeysResult.Var?.Ami),\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-aws/sdk/v4/go/aws\"\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tapp, err := consul.LookupKeys(ctx, \u0026consul.LookupKeysArgs{\n\t\t\tDatacenter: pulumi.StringRef(\"nyc1\"),\n\t\t\tKeys: []consul.GetKeysKey{\n\t\t\t\t{\n\t\t\t\t\tName:    \"ami\",\n\t\t\t\t\tPath:    \"service/app/launch_ami\",\n\t\t\t\t\tDefault: pulumi.StringRef(\"ami-1234\"),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Start our instance with the dynamic ami value\n\t\t_, err = aws.NewInstance(ctx, \"app\", \u0026aws.InstanceArgs{\n\t\t\tAmi: app.Var.Ami,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConsulFunctions;\nimport com.pulumi.consul.inputs.GetKeysArgs;\nimport com.pulumi.aws.instance;\nimport com.pulumi.aws.instanceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var app = ConsulFunctions.getKeys(GetKeysArgs.builder()\n            .datacenter(\"nyc1\")\n            .keys(GetKeysKeyArgs.builder()\n                .name(\"ami\")\n                .path(\"service/app/launch_ami\")\n                .default_(\"ami-1234\")\n                .build())\n            .build());\n\n        // Start our instance with the dynamic ami value\n        var appInstance = new Instance(\"appInstance\", InstanceArgs.builder()\n            .ami(app.var().ami())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Start our instance with the dynamic ami value\n  appInstance:\n    type: aws:instance\n    name: app\n    properties:\n      ami: ${app.var.ami}\nvariables:\n  app:\n    fn::invoke:\n      function: consul:getKeys\n      arguments:\n        datacenter: nyc1\n        keys:\n          - name: ami\n            path: service/app/launch_ami\n            default: ami-1234\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getKeys.\n",
                "properties": {
                    "datacenter": {
                        "type": "string",
                        "description": "The datacenter to use. This overrides the agent's default datacenter and the datacenter in the provider setup.\n"
                    },
                    "errorOnMissingKeys": {
                        "type": "boolean",
                        "description": "Whether to return an error when a key is absent from the KV store and no default is configured. This defaults to `false`.\n"
                    },
                    "keys": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/getKeysKey:getKeysKey"
                        },
                        "description": "Specifies a key in Consul to be read. Supported values documented below. Multiple blocks supported.\n"
                    },
                    "namespace": {
                        "type": "string",
                        "description": "The namespace to lookup the keys.\n"
                    },
                    "partition": {
                        "type": "string",
                        "description": "The partition to lookup the keys.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The ACL token to use. This overrides the token that the agent provides by default.\n",
                        "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                        "secret": true
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getKeys.\n",
                "properties": {
                    "datacenter": {
                        "description": "The datacenter to use. This overrides the agent's default datacenter and the datacenter in the provider setup.\n",
                        "type": "string"
                    },
                    "errorOnMissingKeys": {
                        "description": "Whether to return an error when a key is absent from the KV store and no default is configured. This defaults to `false`.\n",
                        "type": "boolean"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "keys": {
                        "description": "Specifies a key in Consul to be read. Supported values documented below. Multiple blocks supported.\n",
                        "items": {
                            "$ref": "#/types/consul:index/getKeysKey:getKeysKey"
                        },
                        "type": "array"
                    },
                    "namespace": {
                        "description": "The namespace to lookup the keys.\n",
                        "type": "string"
                    },
                    "partition": {
                        "description": "The partition to lookup the keys.\n",
                        "type": "string"
                    },
                    "token": {
                        "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                        "description": "The ACL token to use. This overrides the token that the agent provides by default.\n",
                        "secret": true,
                        "type": "string"
                    },
                    "var": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "For each name given, the corresponding attribute has the value of the key.\n",
                        "type": "object"
                    }
                },
                "required": [
                    "datacenter",
                    "var",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getNetworkAreaMembers:getNetworkAreaMembers": {
            "description": "\u003e **NOTE:** This feature requires [Consul Enterprise](https://www.consul.io/docs/enterprise/index.html).\n\nThe `consul.getNetworkAreaMembers` data source provides a list of the Consul\nservers present in a specific network area.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst dc2NetworkArea = new consul.NetworkArea(\"dc2\", {\n    peerDatacenter: \"dc2\",\n    retryJoins: [\"1.2.3.4\"],\n    useTls: true,\n});\nconst dc2 = consul.getNetworkAreaMembersOutput({\n    uuid: dc2NetworkArea.id,\n});\nexport const members = dc2.apply(dc2 =\u003e dc2.members);\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\ndc2_network_area = consul.NetworkArea(\"dc2\",\n    peer_datacenter=\"dc2\",\n    retry_joins=[\"1.2.3.4\"],\n    use_tls=True)\ndc2 = consul.get_network_area_members_output(uuid=dc2_network_area.id)\npulumi.export(\"members\", dc2.members)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dc2NetworkArea = new Consul.NetworkArea(\"dc2\", new()\n    {\n        PeerDatacenter = \"dc2\",\n        RetryJoins = new[]\n        {\n            \"1.2.3.4\",\n        },\n        UseTls = true,\n    });\n\n    var dc2 = Consul.GetNetworkAreaMembers.Invoke(new()\n    {\n        Uuid = dc2NetworkArea.Id,\n    });\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"members\"] = dc2.Apply(getNetworkAreaMembersResult =\u003e getNetworkAreaMembersResult.Members),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tdc2NetworkArea, err := consul.NewNetworkArea(ctx, \"dc2\", \u0026consul.NetworkAreaArgs{\n\t\t\tPeerDatacenter: pulumi.String(\"dc2\"),\n\t\t\tRetryJoins: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"1.2.3.4\"),\n\t\t\t},\n\t\t\tUseTls: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdc2 := consul.GetNetworkAreaMembersOutput(ctx, consul.GetNetworkAreaMembersOutputArgs{\n\t\t\tUuid: dc2NetworkArea.ID(),\n\t\t}, nil)\n\t\tctx.Export(\"members\", dc2.ApplyT(func(dc2 consul.GetNetworkAreaMembersResult) ([]consul.GetNetworkAreaMembersMember, error) {\n\t\t\treturn []consul.GetNetworkAreaMembersMember(dc2.Members), nil\n\t\t}).([]consul.GetNetworkAreaMembersMemberOutput))\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.NetworkArea;\nimport com.pulumi.consul.NetworkAreaArgs;\nimport com.pulumi.consul.ConsulFunctions;\nimport com.pulumi.consul.inputs.GetNetworkAreaMembersArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var dc2NetworkArea = new NetworkArea(\"dc2NetworkArea\", NetworkAreaArgs.builder()\n            .peerDatacenter(\"dc2\")\n            .retryJoins(\"1.2.3.4\")\n            .useTls(true)\n            .build());\n\n        final var dc2 = ConsulFunctions.getNetworkAreaMembers(GetNetworkAreaMembersArgs.builder()\n            .uuid(dc2NetworkArea.id())\n            .build());\n\n        ctx.export(\"members\", dc2.applyValue(_dc2 -\u003e _dc2.members()));\n    }\n}\n```\n```yaml\nresources:\n  dc2NetworkArea:\n    type: consul:NetworkArea\n    name: dc2\n    properties:\n      peerDatacenter: dc2\n      retryJoins:\n        - 1.2.3.4\n      useTls: true\nvariables:\n  dc2:\n    fn::invoke:\n      function: consul:getNetworkAreaMembers\n      arguments:\n        uuid: ${dc2NetworkArea.id}\noutputs:\n  members: ${dc2.members}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkAreaMembers.\n",
                "properties": {
                    "datacenter": {
                        "type": "string",
                        "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The ACL token to use. This overrides the\ntoken that the agent provides by default.\n",
                        "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                        "secret": true
                    },
                    "uuid": {
                        "type": "string",
                        "description": "The UUID of the area to list.\n"
                    }
                },
                "type": "object",
                "required": [
                    "uuid"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkAreaMembers.\n",
                "properties": {
                    "datacenter": {
                        "description": "The node's Consul datacenter.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "members": {
                        "description": "The list of Consul servers in this network area\n",
                        "items": {
                            "$ref": "#/types/consul:index/getNetworkAreaMembersMember:getNetworkAreaMembersMember"
                        },
                        "type": "array"
                    },
                    "token": {
                        "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                        "secret": true,
                        "type": "string"
                    },
                    "uuid": {
                        "description": "The UUID of the Network Area being queried.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "datacenter",
                    "members",
                    "uuid",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getNetworkSegments:getNetworkSegments": {
            "description": "\u003e **NOTE:** This feature requires [Consul Enterprise](https://www.consul.io/docs/enterprise/index.html).\n\nThe `consul_network_segment` data source can be used to retrieve the network\nsegments defined in the configuration.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nexport = async () =\u003e {\n    const segments = await consul.getNetworkSegments({});\n    return {\n        segments: segments.segments,\n    };\n}\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\nsegments = consul.get_network_segments()\npulumi.export(\"segments\", segments.segments)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var segments = Consul.GetNetworkSegments.Invoke();\n\n    return new Dictionary\u003cstring, object?\u003e\n    {\n        [\"segments\"] = segments.Apply(getNetworkSegmentsResult =\u003e getNetworkSegmentsResult.Segments),\n    };\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\tsegments, err := consul.GetNetworkSegments(ctx, \u0026consul.GetNetworkSegmentsArgs{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tctx.Export(\"segments\", segments.Segments)\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConsulFunctions;\nimport com.pulumi.consul.inputs.GetNetworkSegmentsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var segments = ConsulFunctions.getNetworkSegments(GetNetworkSegmentsArgs.builder()\n            .build());\n\n        ctx.export(\"segments\", segments.segments());\n    }\n}\n```\n```yaml\nvariables:\n  segments:\n    fn::invoke:\n      function: consul:getNetworkSegments\n      arguments: {}\noutputs:\n  segments: ${segments.segments}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNetworkSegments.\n",
                "properties": {
                    "datacenter": {
                        "type": "string",
                        "description": "The datacenter to use. This overrides the\nagent's default datacenter and the datacenter in the provider setup.\n"
                    },
                    "token": {
                        "type": "string",
                        "description": "The ACL token to use. This overrides the\ntoken that the agent provides by default.\n",
                        "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                        "secret": true
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getNetworkSegments.\n",
                "properties": {
                    "datacenter": {
                        "description": "The datacenter the segments are being read from.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "segments": {
                        "description": "The list of network segments.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "token": {
                        "deprecationMessage": "The token argument has been deprecated and will be removed in a future release.\nPlease use the token argument in the provider configuration",
                        "secret": true,
                        "type": "string"
                    }
                },
                "required": [
                    "datacenter",
                    "segments",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getNodes:getNodes": {
            "description": "The `consul.getNodes` data source returns a list of Consul nodes that have\nbeen registered with the Consul cluster in a given datacenter.  By specifying a\ndifferent datacenter in the `query_options` it is possible to retrieve a list of\nnodes from a different WAN-attached Consul datacenter.\n\n",
            "inputs": {
                "description": "A collection of arguments for invoking getNodes.\n",
                "properties": {
                    "queryOptions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/getNodesQueryOption:getNodesQueryOption"
                        },
                        "description": "See below.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getNodes.\n",
                "properties": {
                    "datacenter": {
                        "description": "The datacenter the keys are being read from to.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "nodeIds": {
                        "description": "A list of the Consul node IDs.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "nodeNames": {
                        "description": "A list of the Consul node names.\n",
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "nodes": {
                        "description": "A list of nodes and details about each Consul agent.  The list of\nper-node attributes is detailed below.\n",
                        "items": {
                            "$ref": "#/types/consul:index/getNodesNode:getNodesNode"
                        },
                        "type": "array"
                    },
                    "queryOptions": {
                        "items": {
                            "$ref": "#/types/consul:index/getNodesQueryOption:getNodesQueryOption"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "datacenter",
                    "nodeIds",
                    "nodeNames",
                    "nodes",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getPeering:getPeering": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst basic = consul.getPeering({\n    peerName: \"peered-cluster\",\n});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\nbasic = consul.get_peering(peer_name=\"peered-cluster\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var basic = Consul.GetPeering.Invoke(new()\n    {\n        PeerName = \"peered-cluster\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.LookupPeering(ctx, \u0026consul.LookupPeeringArgs{\n\t\t\tPeerName: \"peered-cluster\",\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConsulFunctions;\nimport com.pulumi.consul.inputs.GetPeeringArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var basic = ConsulFunctions.getPeering(GetPeeringArgs.builder()\n            .peerName(\"peered-cluster\")\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  basic:\n    fn::invoke:\n      function: consul:getPeering\n      arguments:\n        peerName: peered-cluster\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPeering.\n",
                "properties": {
                    "partition": {
                        "type": "string"
                    },
                    "peerName": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "peerName"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getPeering.\n",
                "properties": {
                    "deletedAt": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "meta": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "partition": {
                        "type": "string"
                    },
                    "peerCaPems": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "peerId": {
                        "type": "string"
                    },
                    "peerName": {
                        "type": "string"
                    },
                    "peerServerAddresses": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "peerServerName": {
                        "type": "string"
                    },
                    "state": {
                        "type": "string"
                    }
                },
                "required": [
                    "deletedAt",
                    "meta",
                    "peerCaPems",
                    "peerId",
                    "peerName",
                    "peerServerAddresses",
                    "peerServerName",
                    "state",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getPeerings:getPeerings": {
            "description": "## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\n\nconst peers = consul.getPeerings({});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\n\npeers = consul.get_peerings()\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var peers = Consul.GetPeerings.Invoke();\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.GetPeerings(ctx, \u0026consul.GetPeeringsArgs{}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConsulFunctions;\nimport com.pulumi.consul.inputs.GetPeeringsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var peers = ConsulFunctions.getPeerings(GetPeeringsArgs.builder()\n            .build());\n\n    }\n}\n```\n```yaml\nvariables:\n  peers:\n    fn::invoke:\n      function: consul:getPeerings\n      arguments: {}\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getPeerings.\n",
                "properties": {
                    "partition": {
                        "type": "string"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getPeerings.\n",
                "properties": {
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "partition": {
                        "type": "string"
                    },
                    "peers": {
                        "items": {
                            "$ref": "#/types/consul:index/getPeeringsPeer:getPeeringsPeer"
                        },
                        "type": "array"
                    }
                },
                "required": [
                    "peers",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getService:getService": {
            "description": "`consul.Service` provides details about a specific Consul service in a\ngiven datacenter.  The results include a list of nodes advertising the specified\nservice, the node's IP address, port number, node ID, etc.  By specifying a\ndifferent datacenter in the `query_options` it is possible to retrieve a list of\nservices from a different WAN-attached Consul datacenter.\n\nThis data source is different from the `consul.getServices` (plural) data\nsource, which provides a summary of the current Consul services.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\nimport * as example from \"@pulumi/example\";\nimport * as std from \"@pulumi/std\";\n\nconst read_consul_dc1 = consul.getService({\n    name: \"consul\",\n    datacenter: \"dc1\",\n});\n// Set the description to a whitespace delimited list of the node names\nconst app = new example.index.Resource(\"app\", {description: std.join({\n    separator: \" \",\n    input: nodes,\n}).result});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\nimport pulumi_example as example\nimport pulumi_std as std\n\nread_consul_dc1 = consul.get_service(name=\"consul\",\n    datacenter=\"dc1\")\n# Set the description to a whitespace delimited list of the node names\napp = example.index.Resource(\"app\", description=std.join(separator= ,\n    input=nodes).result)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\nusing Example = Pulumi.Example;\nusing Std = Pulumi.Std;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var read_consul_dc1 = Consul.GetService.Invoke(new()\n    {\n        Name = \"consul\",\n        Datacenter = \"dc1\",\n    });\n\n    // Set the description to a whitespace delimited list of the node names\n    var app = new Example.Index.Resource(\"app\", new()\n    {\n        Description = Std.Join.Invoke(new()\n        {\n            Separator = \" \",\n            Input = nodes,\n        }).Result,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi-example/sdk/go/example\"\n\t\"github.com/pulumi/pulumi-std/sdk/go/std\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.LookupService(ctx, \u0026consul.LookupServiceArgs{\n\t\t\tName:       \"consul\",\n\t\t\tDatacenter: pulumi.StringRef(\"dc1\"),\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Set the description to a whitespace delimited list of the node names\n\t\t_, err = example.NewResource(ctx, \"app\", \u0026example.ResourceArgs{\n\t\t\tDescription: std.Join(ctx, \u0026std.JoinArgs{\n\t\t\t\tSeparator: \" \",\n\t\t\t\tInput:     nodes,\n\t\t\t}, nil).Result,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConsulFunctions;\nimport com.pulumi.consul.inputs.GetServiceArgs;\nimport com.pulumi.example.resource;\nimport com.pulumi.example.resourceArgs;\nimport com.pulumi.std.StdFunctions;\nimport com.pulumi.std.inputs.JoinArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var read-consul-dc1 = ConsulFunctions.getService(GetServiceArgs.builder()\n            .name(\"consul\")\n            .datacenter(\"dc1\")\n            .build());\n\n        // Set the description to a whitespace delimited list of the node names\n        var app = new Resource(\"app\", ResourceArgs.builder()\n            .description(StdFunctions.join(JoinArgs.builder()\n                .separator(\" \")\n                .input(nodes)\n                .build()).result())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Set the description to a whitespace delimited list of the node names\n  app:\n    type: example:resource\n    properties:\n      description:\n        fn::invoke:\n          function: std:join\n          arguments:\n            separator: ' '\n            input: ${nodes}\n          return: result\nvariables:\n  read-consul-dc1:\n    fn::invoke:\n      function: consul:getService\n      arguments:\n        name: consul\n        datacenter: dc1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getService.\n",
                "properties": {
                    "datacenter": {
                        "type": "string",
                        "description": "The Consul datacenter to query.  Defaults to the\nsame value found in `query_options` parameter specified below, or if that is\nempty, the `datacenter` value found in the Consul agent that this provider is\nconfigured to talk to.\n"
                    },
                    "filter": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "The service name to select.\n"
                    },
                    "queryOptions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/getServiceQueryOption:getServiceQueryOption"
                        },
                        "description": "See below.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "A single tag that can be used to filter the list of nodes\nto return based on a single matching tag..\n"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getService.\n",
                "properties": {
                    "datacenter": {
                        "description": "The datacenter the keys are being read from to.\n",
                        "type": "string"
                    },
                    "filter": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of the service\n",
                        "type": "string"
                    },
                    "queryOptions": {
                        "items": {
                            "$ref": "#/types/consul:index/getServiceQueryOption:getServiceQueryOption"
                        },
                        "type": "array"
                    },
                    "services": {
                        "description": "A list of nodes and details about each endpoint advertising a\nservice.  Each element in the list is a map of attributes that correspond to\neach individual node.  The list of per-node attributes is detailed below.\n",
                        "items": {
                            "$ref": "#/types/consul:index/getServiceService:getServiceService"
                        },
                        "type": "array"
                    },
                    "tag": {
                        "description": "The name of the tag used to filter the list of nodes in `service`.\n",
                        "type": "string"
                    }
                },
                "required": [
                    "name",
                    "services",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getServiceHealth:getServiceHealth": {
            "description": "`consul.getServiceHealth` can be used to get the list of the instances that\nare currently healthy, according to their associated  health-checks.\nThe result includes the list of service instances, the node associated to each\ninstance and its health-checks.\n\nThis resource is likely to change as frequently as the health-checks are being\nupdated, you should expect different results in a frequent basis.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```yaml\nvariables:\n  vault:\n    fn::invoke:\n      function: consul:getServiceHealth\n      arguments:\n        service: vault\n        passing: true\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getServiceHealth.\n",
                "properties": {
                    "datacenter": {
                        "type": "string",
                        "description": "The Consul datacenter to query.\n"
                    },
                    "filter": {
                        "type": "string",
                        "description": "A filter expression to refine the list of results, see\nhttps://www.consul.io/api-docs/features/filtering and https://www.consul.io/api-docs/health#filtering-2.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The service name to select.\n"
                    },
                    "near": {
                        "type": "string",
                        "description": "Specifies a node name to sort the node list in ascending order\nbased on the estimated round trip time from that node.\n"
                    },
                    "nodeMeta": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Filter the results to nodes with the specified key/value\npairs.\n"
                    },
                    "passing": {
                        "type": "boolean",
                        "description": "Whether to return only nodes with all checks in the\npassing state. Defaults to `true`.\n"
                    },
                    "tag": {
                        "type": "string",
                        "description": "A single tag that can be used to filter the list to return\nbased on a single matching tag.\n"
                    },
                    "waitFor": {
                        "type": "string"
                    }
                },
                "type": "object",
                "required": [
                    "name"
                ]
            },
            "outputs": {
                "description": "A collection of values returned by getServiceHealth.\n",
                "properties": {
                    "datacenter": {
                        "description": "The datacenter in which the node is running.\n* [`tagged_addresses`](https://www.consul.io/docs/agent/http/catalog.html#TaggedAddresses) -\nList of explicit LAN and WAN IP addresses for the agent.\n",
                        "type": "string"
                    },
                    "filter": {
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "name": {
                        "description": "The name of this health-check.\n",
                        "type": "string"
                    },
                    "near": {
                        "description": "The node to which the result must be sorted to.\n",
                        "type": "string"
                    },
                    "nodeMeta": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "The list of metadata to filter the nodes.\n",
                        "type": "object"
                    },
                    "passing": {
                        "description": "Whether to return only nodes with all checks in the\npassing state.\n",
                        "type": "boolean"
                    },
                    "results": {
                        "description": "A list of entries and details about each endpoint advertising a\nservice.  Each element in the list has three attributes: `node`, `service` and\n`checks`.  The list of the attributes of each one is detailed below.\n",
                        "items": {
                            "$ref": "#/types/consul:index/getServiceHealthResult:getServiceHealthResult"
                        },
                        "type": "array"
                    },
                    "tag": {
                        "description": "The name of the tag used to filter the list.\n",
                        "type": "string"
                    },
                    "waitFor": {
                        "type": "string"
                    }
                },
                "required": [
                    "name",
                    "results",
                    "id"
                ],
                "type": "object"
            }
        },
        "consul:index/getServices:getServices": {
            "description": "The `consul.getServices` data source returns a list of Consul services that\nhave been registered with the Consul cluster in a given datacenter.  By\nspecifying a different datacenter in the `query_options` it is possible to\nretrieve a list of services from a different WAN-attached Consul datacenter.\n\nThis data source is different from the `consul.Service` (singular) data\nsource, which provides a detailed response about a specific Consul service.\n\n## Example Usage\n\n\u003c!--Start PulumiCodeChooser --\u003e\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as consul from \"@pulumi/consul\";\nimport * as example from \"@pulumi/example\";\nimport * as std from \"@pulumi/std\";\n\nconst read_dc1 = consul.getServices({\n    queryOptions: [{\n        datacenter: \"dc1\",\n    }],\n});\n// Set the description to a whitespace delimited list of the services\nconst app = new example.index.Resource(\"app\", {description: std.join({\n    separator: \" \",\n    input: names,\n}).result});\n```\n```python\nimport pulumi\nimport pulumi_consul as consul\nimport pulumi_example as example\nimport pulumi_std as std\n\nread_dc1 = consul.get_services(query_options=[{\n    \"datacenter\": \"dc1\",\n}])\n# Set the description to a whitespace delimited list of the services\napp = example.index.Resource(\"app\", description=std.join(separator= ,\n    input=names).result)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Consul = Pulumi.Consul;\nusing Example = Pulumi.Example;\nusing Std = Pulumi.Std;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var read_dc1 = Consul.GetServices.Invoke(new()\n    {\n        QueryOptions = new[]\n        {\n            new Consul.Inputs.GetServicesQueryOptionInputArgs\n            {\n                Datacenter = \"dc1\",\n            },\n        },\n    });\n\n    // Set the description to a whitespace delimited list of the services\n    var app = new Example.Index.Resource(\"app\", new()\n    {\n        Description = Std.Join.Invoke(new()\n        {\n            Separator = \" \",\n            Input = names,\n        }).Result,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-consul/sdk/v3/go/consul\"\n\t\"github.com/pulumi/pulumi-example/sdk/go/example\"\n\t\"github.com/pulumi/pulumi-std/sdk/go/std\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := consul.GetServices(ctx, \u0026consul.GetServicesArgs{\n\t\t\tQueryOptions: []consul.GetServicesQueryOption{\n\t\t\t\t{\n\t\t\t\t\tDatacenter: pulumi.StringRef(\"dc1\"),\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Set the description to a whitespace delimited list of the services\n\t\t_, err = example.NewResource(ctx, \"app\", \u0026example.ResourceArgs{\n\t\t\tDescription: std.Join(ctx, \u0026std.JoinArgs{\n\t\t\t\tSeparator: \" \",\n\t\t\t\tInput:     names,\n\t\t\t}, nil).Result,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.consul.ConsulFunctions;\nimport com.pulumi.consul.inputs.GetServicesArgs;\nimport com.pulumi.example.resource;\nimport com.pulumi.example.resourceArgs;\nimport com.pulumi.std.StdFunctions;\nimport com.pulumi.std.inputs.JoinArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var read-dc1 = ConsulFunctions.getServices(GetServicesArgs.builder()\n            .queryOptions(GetServicesQueryOptionArgs.builder()\n                .datacenter(\"dc1\")\n                .build())\n            .build());\n\n        // Set the description to a whitespace delimited list of the services\n        var app = new Resource(\"app\", ResourceArgs.builder()\n            .description(StdFunctions.join(JoinArgs.builder()\n                .separator(\" \")\n                .input(names)\n                .build()).result())\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  # Set the description to a whitespace delimited list of the services\n  app:\n    type: example:resource\n    properties:\n      description:\n        fn::invoke:\n          function: std:join\n          arguments:\n            separator: ' '\n            input: ${names}\n          return: result\nvariables:\n  read-dc1:\n    fn::invoke:\n      function: consul:getServices\n      arguments:\n        queryOptions:\n          - datacenter: dc1\n```\n\u003c!--End PulumiCodeChooser --\u003e\n",
            "inputs": {
                "description": "A collection of arguments for invoking getServices.\n",
                "properties": {
                    "queryOptions": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/consul:index/getServicesQueryOption:getServicesQueryOption"
                        },
                        "description": "See below.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getServices.\n",
                "properties": {
                    "datacenter": {
                        "description": "The datacenter the keys are being read from to.\n",
                        "type": "string"
                    },
                    "id": {
                        "description": "The provider-assigned unique ID for this managed resource.",
                        "type": "string"
                    },
                    "names": {
                        "items": {
                            "type": "string"
                        },
                        "type": "array"
                    },
                    "queryOptions": {
                        "items": {
                            "$ref": "#/types/consul:index/getServicesQueryOption:getServicesQueryOption"
                        },
                        "type": "array"
                    },
                    "services": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "type": "object"
                    },
                    "tags": {
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "A map of the tags found for each service.  If more than one service\nshares the same tag, unique service names will be joined by whitespace (this\nis the inverse of `services` and can be used to lookup the services that match\na single tag).\n",
                        "type": "object"
                    }
                },
                "required": [
                    "datacenter",
                    "names",
                    "services",
                    "tags",
                    "id"
                ],
                "type": "object"
            }
        },
        "pulumi:providers:consul/terraformConfig": {
            "description": "This function returns a Terraform config object with terraform-namecased keys,to be used with the Terraform Module Provider.",
            "inputs": {
                "properties": {
                    "__self__": {
                        "type": "ref",
                        "$ref": "#/provider"
                    }
                },
                "type": "pulumi:providers:consul/terraformConfig",
                "required": [
                    "__self__"
                ]
            },
            "outputs": {
                "properties": {
                    "result": {
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "type": "object"
                    }
                },
                "required": [
                    "result"
                ],
                "type": "object"
            }
        }
    }
}