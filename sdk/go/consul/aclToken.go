// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package consul

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-consul/sdk/v3/go/consul/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-consul/sdk/v3/go/consul"
//	"github.com/pulumi/pulumi-random/sdk/v4/go/random"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			agent, err := consul.NewAclPolicy(ctx, "agent", &consul.AclPolicyArgs{
//				Rules: pulumi.String("node_prefix \"\" {\n  policy = \"read\"\n}\n"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = consul.NewAclToken(ctx, "testAclToken", &consul.AclTokenArgs{
//				Description: pulumi.String("my test token"),
//				Policies: pulumi.StringArray{
//					agent.Name,
//				},
//				Local: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = random.NewRandomUuid(ctx, "testRandomUuid", nil)
//			if err != nil {
//				return err
//			}
//			_, err = consul.NewAclToken(ctx, "testPredefinedId", &consul.AclTokenArgs{
//				AccessorId:  pulumi.Any(random_uuid.Test_uuid.Result),
//				Description: pulumi.String("my test uuid token"),
//				Policies: pulumi.StringArray{
//					agent.Name,
//				},
//				Local: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
//
//	$ pulumi import consul:index/aclToken:AclToken anonymous 00000000-0000-0000-0000-000000000002
//
// ```
//
// ```sh
//
//	$ pulumi import consul:index/aclToken:AclToken master-token 624d94ca-bc5c-f960-4e83-0a609cf588be
//
// ```
type AclToken struct {
	pulumi.CustomResourceState

	// The uuid of the token. If omitted, Consul will generate a random uuid.
	AccessorId pulumi.StringOutput `pulumi:"accessorId"`
	// The description of the token.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// If set this represents the point after which a token should be considered revoked and is eligible for destruction.
	ExpirationTime pulumi.StringPtrOutput `pulumi:"expirationTime"`
	// The flag to set the token local to the current datacenter.
	Local pulumi.BoolPtrOutput `pulumi:"local"`
	// The namespace to create the token within.
	Namespace pulumi.StringPtrOutput `pulumi:"namespace"`
	// The list of node identities that should be applied to the token.
	NodeIdentities AclTokenNodeIdentityArrayOutput `pulumi:"nodeIdentities"`
	// The partition the ACL token is associated with.
	Partition pulumi.StringPtrOutput `pulumi:"partition"`
	// The list of policies attached to the token.
	Policies pulumi.StringArrayOutput `pulumi:"policies"`
	// The list of roles attached to the token.
	Roles pulumi.StringArrayOutput `pulumi:"roles"`
	// The list of service identities that should be applied to the token.
	ServiceIdentities AclTokenServiceIdentityArrayOutput `pulumi:"serviceIdentities"`
	// The list of templated policies that should be applied to the token.
	TemplatedPolicies AclTokenTemplatedPolicyArrayOutput `pulumi:"templatedPolicies"`
}

// NewAclToken registers a new resource with the given unique name, arguments, and options.
func NewAclToken(ctx *pulumi.Context,
	name string, args *AclTokenArgs, opts ...pulumi.ResourceOption) (*AclToken, error) {
	if args == nil {
		args = &AclTokenArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource AclToken
	err := ctx.RegisterResource("consul:index/aclToken:AclToken", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAclToken gets an existing AclToken resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAclToken(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AclTokenState, opts ...pulumi.ResourceOption) (*AclToken, error) {
	var resource AclToken
	err := ctx.ReadResource("consul:index/aclToken:AclToken", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AclToken resources.
type aclTokenState struct {
	// The uuid of the token. If omitted, Consul will generate a random uuid.
	AccessorId *string `pulumi:"accessorId"`
	// The description of the token.
	Description *string `pulumi:"description"`
	// If set this represents the point after which a token should be considered revoked and is eligible for destruction.
	ExpirationTime *string `pulumi:"expirationTime"`
	// The flag to set the token local to the current datacenter.
	Local *bool `pulumi:"local"`
	// The namespace to create the token within.
	Namespace *string `pulumi:"namespace"`
	// The list of node identities that should be applied to the token.
	NodeIdentities []AclTokenNodeIdentity `pulumi:"nodeIdentities"`
	// The partition the ACL token is associated with.
	Partition *string `pulumi:"partition"`
	// The list of policies attached to the token.
	Policies []string `pulumi:"policies"`
	// The list of roles attached to the token.
	Roles []string `pulumi:"roles"`
	// The list of service identities that should be applied to the token.
	ServiceIdentities []AclTokenServiceIdentity `pulumi:"serviceIdentities"`
	// The list of templated policies that should be applied to the token.
	TemplatedPolicies []AclTokenTemplatedPolicy `pulumi:"templatedPolicies"`
}

type AclTokenState struct {
	// The uuid of the token. If omitted, Consul will generate a random uuid.
	AccessorId pulumi.StringPtrInput
	// The description of the token.
	Description pulumi.StringPtrInput
	// If set this represents the point after which a token should be considered revoked and is eligible for destruction.
	ExpirationTime pulumi.StringPtrInput
	// The flag to set the token local to the current datacenter.
	Local pulumi.BoolPtrInput
	// The namespace to create the token within.
	Namespace pulumi.StringPtrInput
	// The list of node identities that should be applied to the token.
	NodeIdentities AclTokenNodeIdentityArrayInput
	// The partition the ACL token is associated with.
	Partition pulumi.StringPtrInput
	// The list of policies attached to the token.
	Policies pulumi.StringArrayInput
	// The list of roles attached to the token.
	Roles pulumi.StringArrayInput
	// The list of service identities that should be applied to the token.
	ServiceIdentities AclTokenServiceIdentityArrayInput
	// The list of templated policies that should be applied to the token.
	TemplatedPolicies AclTokenTemplatedPolicyArrayInput
}

func (AclTokenState) ElementType() reflect.Type {
	return reflect.TypeOf((*aclTokenState)(nil)).Elem()
}

type aclTokenArgs struct {
	// The uuid of the token. If omitted, Consul will generate a random uuid.
	AccessorId *string `pulumi:"accessorId"`
	// The description of the token.
	Description *string `pulumi:"description"`
	// If set this represents the point after which a token should be considered revoked and is eligible for destruction.
	ExpirationTime *string `pulumi:"expirationTime"`
	// The flag to set the token local to the current datacenter.
	Local *bool `pulumi:"local"`
	// The namespace to create the token within.
	Namespace *string `pulumi:"namespace"`
	// The list of node identities that should be applied to the token.
	NodeIdentities []AclTokenNodeIdentity `pulumi:"nodeIdentities"`
	// The partition the ACL token is associated with.
	Partition *string `pulumi:"partition"`
	// The list of policies attached to the token.
	Policies []string `pulumi:"policies"`
	// The list of roles attached to the token.
	Roles []string `pulumi:"roles"`
	// The list of service identities that should be applied to the token.
	ServiceIdentities []AclTokenServiceIdentity `pulumi:"serviceIdentities"`
	// The list of templated policies that should be applied to the token.
	TemplatedPolicies []AclTokenTemplatedPolicy `pulumi:"templatedPolicies"`
}

// The set of arguments for constructing a AclToken resource.
type AclTokenArgs struct {
	// The uuid of the token. If omitted, Consul will generate a random uuid.
	AccessorId pulumi.StringPtrInput
	// The description of the token.
	Description pulumi.StringPtrInput
	// If set this represents the point after which a token should be considered revoked and is eligible for destruction.
	ExpirationTime pulumi.StringPtrInput
	// The flag to set the token local to the current datacenter.
	Local pulumi.BoolPtrInput
	// The namespace to create the token within.
	Namespace pulumi.StringPtrInput
	// The list of node identities that should be applied to the token.
	NodeIdentities AclTokenNodeIdentityArrayInput
	// The partition the ACL token is associated with.
	Partition pulumi.StringPtrInput
	// The list of policies attached to the token.
	Policies pulumi.StringArrayInput
	// The list of roles attached to the token.
	Roles pulumi.StringArrayInput
	// The list of service identities that should be applied to the token.
	ServiceIdentities AclTokenServiceIdentityArrayInput
	// The list of templated policies that should be applied to the token.
	TemplatedPolicies AclTokenTemplatedPolicyArrayInput
}

func (AclTokenArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*aclTokenArgs)(nil)).Elem()
}

type AclTokenInput interface {
	pulumi.Input

	ToAclTokenOutput() AclTokenOutput
	ToAclTokenOutputWithContext(ctx context.Context) AclTokenOutput
}

func (*AclToken) ElementType() reflect.Type {
	return reflect.TypeOf((**AclToken)(nil)).Elem()
}

func (i *AclToken) ToAclTokenOutput() AclTokenOutput {
	return i.ToAclTokenOutputWithContext(context.Background())
}

func (i *AclToken) ToAclTokenOutputWithContext(ctx context.Context) AclTokenOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AclTokenOutput)
}

func (i *AclToken) ToOutput(ctx context.Context) pulumix.Output[*AclToken] {
	return pulumix.Output[*AclToken]{
		OutputState: i.ToAclTokenOutputWithContext(ctx).OutputState,
	}
}

// AclTokenArrayInput is an input type that accepts AclTokenArray and AclTokenArrayOutput values.
// You can construct a concrete instance of `AclTokenArrayInput` via:
//
//	AclTokenArray{ AclTokenArgs{...} }
type AclTokenArrayInput interface {
	pulumi.Input

	ToAclTokenArrayOutput() AclTokenArrayOutput
	ToAclTokenArrayOutputWithContext(context.Context) AclTokenArrayOutput
}

type AclTokenArray []AclTokenInput

func (AclTokenArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AclToken)(nil)).Elem()
}

func (i AclTokenArray) ToAclTokenArrayOutput() AclTokenArrayOutput {
	return i.ToAclTokenArrayOutputWithContext(context.Background())
}

func (i AclTokenArray) ToAclTokenArrayOutputWithContext(ctx context.Context) AclTokenArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AclTokenArrayOutput)
}

func (i AclTokenArray) ToOutput(ctx context.Context) pulumix.Output[[]*AclToken] {
	return pulumix.Output[[]*AclToken]{
		OutputState: i.ToAclTokenArrayOutputWithContext(ctx).OutputState,
	}
}

// AclTokenMapInput is an input type that accepts AclTokenMap and AclTokenMapOutput values.
// You can construct a concrete instance of `AclTokenMapInput` via:
//
//	AclTokenMap{ "key": AclTokenArgs{...} }
type AclTokenMapInput interface {
	pulumi.Input

	ToAclTokenMapOutput() AclTokenMapOutput
	ToAclTokenMapOutputWithContext(context.Context) AclTokenMapOutput
}

type AclTokenMap map[string]AclTokenInput

func (AclTokenMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AclToken)(nil)).Elem()
}

func (i AclTokenMap) ToAclTokenMapOutput() AclTokenMapOutput {
	return i.ToAclTokenMapOutputWithContext(context.Background())
}

func (i AclTokenMap) ToAclTokenMapOutputWithContext(ctx context.Context) AclTokenMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AclTokenMapOutput)
}

func (i AclTokenMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*AclToken] {
	return pulumix.Output[map[string]*AclToken]{
		OutputState: i.ToAclTokenMapOutputWithContext(ctx).OutputState,
	}
}

type AclTokenOutput struct{ *pulumi.OutputState }

func (AclTokenOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AclToken)(nil)).Elem()
}

func (o AclTokenOutput) ToAclTokenOutput() AclTokenOutput {
	return o
}

func (o AclTokenOutput) ToAclTokenOutputWithContext(ctx context.Context) AclTokenOutput {
	return o
}

func (o AclTokenOutput) ToOutput(ctx context.Context) pulumix.Output[*AclToken] {
	return pulumix.Output[*AclToken]{
		OutputState: o.OutputState,
	}
}

// The uuid of the token. If omitted, Consul will generate a random uuid.
func (o AclTokenOutput) AccessorId() pulumi.StringOutput {
	return o.ApplyT(func(v *AclToken) pulumi.StringOutput { return v.AccessorId }).(pulumi.StringOutput)
}

// The description of the token.
func (o AclTokenOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AclToken) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// If set this represents the point after which a token should be considered revoked and is eligible for destruction.
func (o AclTokenOutput) ExpirationTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AclToken) pulumi.StringPtrOutput { return v.ExpirationTime }).(pulumi.StringPtrOutput)
}

// The flag to set the token local to the current datacenter.
func (o AclTokenOutput) Local() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *AclToken) pulumi.BoolPtrOutput { return v.Local }).(pulumi.BoolPtrOutput)
}

// The namespace to create the token within.
func (o AclTokenOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AclToken) pulumi.StringPtrOutput { return v.Namespace }).(pulumi.StringPtrOutput)
}

// The list of node identities that should be applied to the token.
func (o AclTokenOutput) NodeIdentities() AclTokenNodeIdentityArrayOutput {
	return o.ApplyT(func(v *AclToken) AclTokenNodeIdentityArrayOutput { return v.NodeIdentities }).(AclTokenNodeIdentityArrayOutput)
}

// The partition the ACL token is associated with.
func (o AclTokenOutput) Partition() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *AclToken) pulumi.StringPtrOutput { return v.Partition }).(pulumi.StringPtrOutput)
}

// The list of policies attached to the token.
func (o AclTokenOutput) Policies() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AclToken) pulumi.StringArrayOutput { return v.Policies }).(pulumi.StringArrayOutput)
}

// The list of roles attached to the token.
func (o AclTokenOutput) Roles() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *AclToken) pulumi.StringArrayOutput { return v.Roles }).(pulumi.StringArrayOutput)
}

// The list of service identities that should be applied to the token.
func (o AclTokenOutput) ServiceIdentities() AclTokenServiceIdentityArrayOutput {
	return o.ApplyT(func(v *AclToken) AclTokenServiceIdentityArrayOutput { return v.ServiceIdentities }).(AclTokenServiceIdentityArrayOutput)
}

// The list of templated policies that should be applied to the token.
func (o AclTokenOutput) TemplatedPolicies() AclTokenTemplatedPolicyArrayOutput {
	return o.ApplyT(func(v *AclToken) AclTokenTemplatedPolicyArrayOutput { return v.TemplatedPolicies }).(AclTokenTemplatedPolicyArrayOutput)
}

type AclTokenArrayOutput struct{ *pulumi.OutputState }

func (AclTokenArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AclToken)(nil)).Elem()
}

func (o AclTokenArrayOutput) ToAclTokenArrayOutput() AclTokenArrayOutput {
	return o
}

func (o AclTokenArrayOutput) ToAclTokenArrayOutputWithContext(ctx context.Context) AclTokenArrayOutput {
	return o
}

func (o AclTokenArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*AclToken] {
	return pulumix.Output[[]*AclToken]{
		OutputState: o.OutputState,
	}
}

func (o AclTokenArrayOutput) Index(i pulumi.IntInput) AclTokenOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AclToken {
		return vs[0].([]*AclToken)[vs[1].(int)]
	}).(AclTokenOutput)
}

type AclTokenMapOutput struct{ *pulumi.OutputState }

func (AclTokenMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AclToken)(nil)).Elem()
}

func (o AclTokenMapOutput) ToAclTokenMapOutput() AclTokenMapOutput {
	return o
}

func (o AclTokenMapOutput) ToAclTokenMapOutputWithContext(ctx context.Context) AclTokenMapOutput {
	return o
}

func (o AclTokenMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*AclToken] {
	return pulumix.Output[map[string]*AclToken]{
		OutputState: o.OutputState,
	}
}

func (o AclTokenMapOutput) MapIndex(k pulumi.StringInput) AclTokenOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AclToken {
		return vs[0].(map[string]*AclToken)[vs[1].(string)]
	}).(AclTokenOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AclTokenInput)(nil)).Elem(), &AclToken{})
	pulumi.RegisterInputType(reflect.TypeOf((*AclTokenArrayInput)(nil)).Elem(), AclTokenArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AclTokenMapInput)(nil)).Elem(), AclTokenMap{})
	pulumi.RegisterOutputType(AclTokenOutput{})
	pulumi.RegisterOutputType(AclTokenArrayOutput{})
	pulumi.RegisterOutputType(AclTokenMapOutput{})
}
