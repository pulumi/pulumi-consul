// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package consul

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-consul/sdk/v3/go/consul/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// [Cluster Peering](https://www.consul.io/docs/connect/cluster-peering) can be used to create connections between two or more independent clusters so that services deployed to different partitions or datacenters can communicate.
//
// The `clusterPeeringToken` resource can be used to generate a peering token that can later be used to establish a peering connection.
//
// > **Cluster peering is currently in technical preview:** Functionality associated with cluster peering is subject to change. You should never use the technical preview release in secure environments or production scenarios. Features in technical preview may have performance issues, scaling issues, and limited support.
//
// The functionality described here is available only in Consul version 1.13.0 and later.
type PeeringToken struct {
	pulumi.CustomResourceState

	// Specifies KV metadata to associate with the peering. This parameter is not required and does not directly impact the cluster peering process.
	Meta      pulumi.StringMapOutput `pulumi:"meta"`
	Partition pulumi.StringPtrOutput `pulumi:"partition"`
	// The name assigned to the peer cluster. The `peerName` is used to reference the peer cluster in service discovery queries and configuration entries such as `service-intentions`. This field must be a valid DNS hostname label.
	PeerName pulumi.StringOutput `pulumi:"peerName"`
	// The generated peering token
	PeeringToken pulumi.StringOutput `pulumi:"peeringToken"`
}

// NewPeeringToken registers a new resource with the given unique name, arguments, and options.
func NewPeeringToken(ctx *pulumi.Context,
	name string, args *PeeringTokenArgs, opts ...pulumi.ResourceOption) (*PeeringToken, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.PeerName == nil {
		return nil, errors.New("invalid value for required argument 'PeerName'")
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"peeringToken",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource PeeringToken
	err := ctx.RegisterResource("consul:index/peeringToken:PeeringToken", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPeeringToken gets an existing PeeringToken resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPeeringToken(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PeeringTokenState, opts ...pulumi.ResourceOption) (*PeeringToken, error) {
	var resource PeeringToken
	err := ctx.ReadResource("consul:index/peeringToken:PeeringToken", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering PeeringToken resources.
type peeringTokenState struct {
	// Specifies KV metadata to associate with the peering. This parameter is not required and does not directly impact the cluster peering process.
	Meta      map[string]string `pulumi:"meta"`
	Partition *string           `pulumi:"partition"`
	// The name assigned to the peer cluster. The `peerName` is used to reference the peer cluster in service discovery queries and configuration entries such as `service-intentions`. This field must be a valid DNS hostname label.
	PeerName *string `pulumi:"peerName"`
	// The generated peering token
	PeeringToken *string `pulumi:"peeringToken"`
}

type PeeringTokenState struct {
	// Specifies KV metadata to associate with the peering. This parameter is not required and does not directly impact the cluster peering process.
	Meta      pulumi.StringMapInput
	Partition pulumi.StringPtrInput
	// The name assigned to the peer cluster. The `peerName` is used to reference the peer cluster in service discovery queries and configuration entries such as `service-intentions`. This field must be a valid DNS hostname label.
	PeerName pulumi.StringPtrInput
	// The generated peering token
	PeeringToken pulumi.StringPtrInput
}

func (PeeringTokenState) ElementType() reflect.Type {
	return reflect.TypeOf((*peeringTokenState)(nil)).Elem()
}

type peeringTokenArgs struct {
	// Specifies KV metadata to associate with the peering. This parameter is not required and does not directly impact the cluster peering process.
	Meta      map[string]string `pulumi:"meta"`
	Partition *string           `pulumi:"partition"`
	// The name assigned to the peer cluster. The `peerName` is used to reference the peer cluster in service discovery queries and configuration entries such as `service-intentions`. This field must be a valid DNS hostname label.
	PeerName string `pulumi:"peerName"`
}

// The set of arguments for constructing a PeeringToken resource.
type PeeringTokenArgs struct {
	// Specifies KV metadata to associate with the peering. This parameter is not required and does not directly impact the cluster peering process.
	Meta      pulumi.StringMapInput
	Partition pulumi.StringPtrInput
	// The name assigned to the peer cluster. The `peerName` is used to reference the peer cluster in service discovery queries and configuration entries such as `service-intentions`. This field must be a valid DNS hostname label.
	PeerName pulumi.StringInput
}

func (PeeringTokenArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*peeringTokenArgs)(nil)).Elem()
}

type PeeringTokenInput interface {
	pulumi.Input

	ToPeeringTokenOutput() PeeringTokenOutput
	ToPeeringTokenOutputWithContext(ctx context.Context) PeeringTokenOutput
}

func (*PeeringToken) ElementType() reflect.Type {
	return reflect.TypeOf((**PeeringToken)(nil)).Elem()
}

func (i *PeeringToken) ToPeeringTokenOutput() PeeringTokenOutput {
	return i.ToPeeringTokenOutputWithContext(context.Background())
}

func (i *PeeringToken) ToPeeringTokenOutputWithContext(ctx context.Context) PeeringTokenOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PeeringTokenOutput)
}

func (i *PeeringToken) ToOutput(ctx context.Context) pulumix.Output[*PeeringToken] {
	return pulumix.Output[*PeeringToken]{
		OutputState: i.ToPeeringTokenOutputWithContext(ctx).OutputState,
	}
}

// PeeringTokenArrayInput is an input type that accepts PeeringTokenArray and PeeringTokenArrayOutput values.
// You can construct a concrete instance of `PeeringTokenArrayInput` via:
//
//	PeeringTokenArray{ PeeringTokenArgs{...} }
type PeeringTokenArrayInput interface {
	pulumi.Input

	ToPeeringTokenArrayOutput() PeeringTokenArrayOutput
	ToPeeringTokenArrayOutputWithContext(context.Context) PeeringTokenArrayOutput
}

type PeeringTokenArray []PeeringTokenInput

func (PeeringTokenArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PeeringToken)(nil)).Elem()
}

func (i PeeringTokenArray) ToPeeringTokenArrayOutput() PeeringTokenArrayOutput {
	return i.ToPeeringTokenArrayOutputWithContext(context.Background())
}

func (i PeeringTokenArray) ToPeeringTokenArrayOutputWithContext(ctx context.Context) PeeringTokenArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PeeringTokenArrayOutput)
}

func (i PeeringTokenArray) ToOutput(ctx context.Context) pulumix.Output[[]*PeeringToken] {
	return pulumix.Output[[]*PeeringToken]{
		OutputState: i.ToPeeringTokenArrayOutputWithContext(ctx).OutputState,
	}
}

// PeeringTokenMapInput is an input type that accepts PeeringTokenMap and PeeringTokenMapOutput values.
// You can construct a concrete instance of `PeeringTokenMapInput` via:
//
//	PeeringTokenMap{ "key": PeeringTokenArgs{...} }
type PeeringTokenMapInput interface {
	pulumi.Input

	ToPeeringTokenMapOutput() PeeringTokenMapOutput
	ToPeeringTokenMapOutputWithContext(context.Context) PeeringTokenMapOutput
}

type PeeringTokenMap map[string]PeeringTokenInput

func (PeeringTokenMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PeeringToken)(nil)).Elem()
}

func (i PeeringTokenMap) ToPeeringTokenMapOutput() PeeringTokenMapOutput {
	return i.ToPeeringTokenMapOutputWithContext(context.Background())
}

func (i PeeringTokenMap) ToPeeringTokenMapOutputWithContext(ctx context.Context) PeeringTokenMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PeeringTokenMapOutput)
}

func (i PeeringTokenMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*PeeringToken] {
	return pulumix.Output[map[string]*PeeringToken]{
		OutputState: i.ToPeeringTokenMapOutputWithContext(ctx).OutputState,
	}
}

type PeeringTokenOutput struct{ *pulumi.OutputState }

func (PeeringTokenOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PeeringToken)(nil)).Elem()
}

func (o PeeringTokenOutput) ToPeeringTokenOutput() PeeringTokenOutput {
	return o
}

func (o PeeringTokenOutput) ToPeeringTokenOutputWithContext(ctx context.Context) PeeringTokenOutput {
	return o
}

func (o PeeringTokenOutput) ToOutput(ctx context.Context) pulumix.Output[*PeeringToken] {
	return pulumix.Output[*PeeringToken]{
		OutputState: o.OutputState,
	}
}

// Specifies KV metadata to associate with the peering. This parameter is not required and does not directly impact the cluster peering process.
func (o PeeringTokenOutput) Meta() pulumi.StringMapOutput {
	return o.ApplyT(func(v *PeeringToken) pulumi.StringMapOutput { return v.Meta }).(pulumi.StringMapOutput)
}

func (o PeeringTokenOutput) Partition() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *PeeringToken) pulumi.StringPtrOutput { return v.Partition }).(pulumi.StringPtrOutput)
}

// The name assigned to the peer cluster. The `peerName` is used to reference the peer cluster in service discovery queries and configuration entries such as `service-intentions`. This field must be a valid DNS hostname label.
func (o PeeringTokenOutput) PeerName() pulumi.StringOutput {
	return o.ApplyT(func(v *PeeringToken) pulumi.StringOutput { return v.PeerName }).(pulumi.StringOutput)
}

// The generated peering token
func (o PeeringTokenOutput) PeeringToken() pulumi.StringOutput {
	return o.ApplyT(func(v *PeeringToken) pulumi.StringOutput { return v.PeeringToken }).(pulumi.StringOutput)
}

type PeeringTokenArrayOutput struct{ *pulumi.OutputState }

func (PeeringTokenArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*PeeringToken)(nil)).Elem()
}

func (o PeeringTokenArrayOutput) ToPeeringTokenArrayOutput() PeeringTokenArrayOutput {
	return o
}

func (o PeeringTokenArrayOutput) ToPeeringTokenArrayOutputWithContext(ctx context.Context) PeeringTokenArrayOutput {
	return o
}

func (o PeeringTokenArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*PeeringToken] {
	return pulumix.Output[[]*PeeringToken]{
		OutputState: o.OutputState,
	}
}

func (o PeeringTokenArrayOutput) Index(i pulumi.IntInput) PeeringTokenOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *PeeringToken {
		return vs[0].([]*PeeringToken)[vs[1].(int)]
	}).(PeeringTokenOutput)
}

type PeeringTokenMapOutput struct{ *pulumi.OutputState }

func (PeeringTokenMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*PeeringToken)(nil)).Elem()
}

func (o PeeringTokenMapOutput) ToPeeringTokenMapOutput() PeeringTokenMapOutput {
	return o
}

func (o PeeringTokenMapOutput) ToPeeringTokenMapOutputWithContext(ctx context.Context) PeeringTokenMapOutput {
	return o
}

func (o PeeringTokenMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*PeeringToken] {
	return pulumix.Output[map[string]*PeeringToken]{
		OutputState: o.OutputState,
	}
}

func (o PeeringTokenMapOutput) MapIndex(k pulumi.StringInput) PeeringTokenOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *PeeringToken {
		return vs[0].(map[string]*PeeringToken)[vs[1].(string)]
	}).(PeeringTokenOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PeeringTokenInput)(nil)).Elem(), &PeeringToken{})
	pulumi.RegisterInputType(reflect.TypeOf((*PeeringTokenArrayInput)(nil)).Elem(), PeeringTokenArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PeeringTokenMapInput)(nil)).Elem(), PeeringTokenMap{})
	pulumi.RegisterOutputType(PeeringTokenOutput{})
	pulumi.RegisterOutputType(PeeringTokenArrayOutput{})
	pulumi.RegisterOutputType(PeeringTokenMapOutput{})
}
