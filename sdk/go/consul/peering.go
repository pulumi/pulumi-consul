// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package consul

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-consul/sdk/v3/go/consul/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// [Cluster Peering](https://www.consul.io/docs/connect/cluster-peering) can be used to create connections between two or more independent clusters so that services deployed to different partitions or datacenters can communicate.
//
// The `clusterPeering` resource can be used to establish the peering after a peering token has been generated.
//
// > **Cluster peering is currently in technical preview:** Functionality associated with cluster peering is subject to change. You should never use the technical preview release in secure environments or production scenarios. Features in technical preview may have performance issues, scaling issues, and limited support.
//
// The functionality described here is available only in Consul version 1.13.0 and later.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-consul/sdk/v3/go/consul"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := consul.NewPeeringToken(ctx, "eu-us", &consul.PeeringTokenArgs{
//				PeerName: pulumi.String("eu-cluster"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = consul.NewPeering(ctx, "eu-us", &consul.PeeringArgs{
//				PeerName:     pulumi.String("eu-cluster"),
//				PeeringToken: pulumi.Any(token.PeeringToken),
//				Meta: pulumi.StringMap{
//					"hello": pulumi.String("world"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type Peering struct {
	pulumi.CustomResourceState

	DeletedAt pulumi.StringOutput `pulumi:"deletedAt"`
	// Specifies KV metadata to associate with the peering. This parameter is not required and does not directly impact the cluster peering process.
	Meta       pulumi.StringMapOutput   `pulumi:"meta"`
	Partition  pulumi.StringPtrOutput   `pulumi:"partition"`
	PeerCaPems pulumi.StringArrayOutput `pulumi:"peerCaPems"`
	PeerId     pulumi.StringOutput      `pulumi:"peerId"`
	// The name assigned to the peer cluster. The `peerName` is used to reference the peer cluster in service discovery queries and configuration entries such as `service-intentions`. This field must be a valid DNS hostname label.
	PeerName            pulumi.StringOutput      `pulumi:"peerName"`
	PeerServerAddresses pulumi.StringArrayOutput `pulumi:"peerServerAddresses"`
	PeerServerName      pulumi.StringOutput      `pulumi:"peerServerName"`
	// The peering token fetched from the peer cluster.
	PeeringToken pulumi.StringOutput `pulumi:"peeringToken"`
	State        pulumi.StringOutput `pulumi:"state"`
}

// NewPeering registers a new resource with the given unique name, arguments, and options.
func NewPeering(ctx *pulumi.Context,
	name string, args *PeeringArgs, opts ...pulumi.ResourceOption) (*Peering, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.PeerName == nil {
		return nil, errors.New("invalid value for required argument 'PeerName'")
	}
	if args.PeeringToken == nil {
		return nil, errors.New("invalid value for required argument 'PeeringToken'")
	}
	if args.PeeringToken != nil {
		args.PeeringToken = pulumi.ToSecret(args.PeeringToken).(pulumi.StringInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"peeringToken",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Peering
	err := ctx.RegisterResource("consul:index/peering:Peering", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPeering gets an existing Peering resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPeering(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PeeringState, opts ...pulumi.ResourceOption) (*Peering, error) {
	var resource Peering
	err := ctx.ReadResource("consul:index/peering:Peering", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Peering resources.
type peeringState struct {
	DeletedAt *string `pulumi:"deletedAt"`
	// Specifies KV metadata to associate with the peering. This parameter is not required and does not directly impact the cluster peering process.
	Meta       map[string]string `pulumi:"meta"`
	Partition  *string           `pulumi:"partition"`
	PeerCaPems []string          `pulumi:"peerCaPems"`
	PeerId     *string           `pulumi:"peerId"`
	// The name assigned to the peer cluster. The `peerName` is used to reference the peer cluster in service discovery queries and configuration entries such as `service-intentions`. This field must be a valid DNS hostname label.
	PeerName            *string  `pulumi:"peerName"`
	PeerServerAddresses []string `pulumi:"peerServerAddresses"`
	PeerServerName      *string  `pulumi:"peerServerName"`
	// The peering token fetched from the peer cluster.
	PeeringToken *string `pulumi:"peeringToken"`
	State        *string `pulumi:"state"`
}

type PeeringState struct {
	DeletedAt pulumi.StringPtrInput
	// Specifies KV metadata to associate with the peering. This parameter is not required and does not directly impact the cluster peering process.
	Meta       pulumi.StringMapInput
	Partition  pulumi.StringPtrInput
	PeerCaPems pulumi.StringArrayInput
	PeerId     pulumi.StringPtrInput
	// The name assigned to the peer cluster. The `peerName` is used to reference the peer cluster in service discovery queries and configuration entries such as `service-intentions`. This field must be a valid DNS hostname label.
	PeerName            pulumi.StringPtrInput
	PeerServerAddresses pulumi.StringArrayInput
	PeerServerName      pulumi.StringPtrInput
	// The peering token fetched from the peer cluster.
	PeeringToken pulumi.StringPtrInput
	State        pulumi.StringPtrInput
}

func (PeeringState) ElementType() reflect.Type {
	return reflect.TypeOf((*peeringState)(nil)).Elem()
}

type peeringArgs struct {
	// Specifies KV metadata to associate with the peering. This parameter is not required and does not directly impact the cluster peering process.
	Meta      map[string]string `pulumi:"meta"`
	Partition *string           `pulumi:"partition"`
	// The name assigned to the peer cluster. The `peerName` is used to reference the peer cluster in service discovery queries and configuration entries such as `service-intentions`. This field must be a valid DNS hostname label.
	PeerName string `pulumi:"peerName"`
	// The peering token fetched from the peer cluster.
	PeeringToken string `pulumi:"peeringToken"`
}

// The set of arguments for constructing a Peering resource.
type PeeringArgs struct {
	// Specifies KV metadata to associate with the peering. This parameter is not required and does not directly impact the cluster peering process.
	Meta      pulumi.StringMapInput
	Partition pulumi.StringPtrInput
	// The name assigned to the peer cluster. The `peerName` is used to reference the peer cluster in service discovery queries and configuration entries such as `service-intentions`. This field must be a valid DNS hostname label.
	PeerName pulumi.StringInput
	// The peering token fetched from the peer cluster.
	PeeringToken pulumi.StringInput
}

func (PeeringArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*peeringArgs)(nil)).Elem()
}

type PeeringInput interface {
	pulumi.Input

	ToPeeringOutput() PeeringOutput
	ToPeeringOutputWithContext(ctx context.Context) PeeringOutput
}

func (*Peering) ElementType() reflect.Type {
	return reflect.TypeOf((**Peering)(nil)).Elem()
}

func (i *Peering) ToPeeringOutput() PeeringOutput {
	return i.ToPeeringOutputWithContext(context.Background())
}

func (i *Peering) ToPeeringOutputWithContext(ctx context.Context) PeeringOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PeeringOutput)
}

// PeeringArrayInput is an input type that accepts PeeringArray and PeeringArrayOutput values.
// You can construct a concrete instance of `PeeringArrayInput` via:
//
//	PeeringArray{ PeeringArgs{...} }
type PeeringArrayInput interface {
	pulumi.Input

	ToPeeringArrayOutput() PeeringArrayOutput
	ToPeeringArrayOutputWithContext(context.Context) PeeringArrayOutput
}

type PeeringArray []PeeringInput

func (PeeringArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Peering)(nil)).Elem()
}

func (i PeeringArray) ToPeeringArrayOutput() PeeringArrayOutput {
	return i.ToPeeringArrayOutputWithContext(context.Background())
}

func (i PeeringArray) ToPeeringArrayOutputWithContext(ctx context.Context) PeeringArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PeeringArrayOutput)
}

// PeeringMapInput is an input type that accepts PeeringMap and PeeringMapOutput values.
// You can construct a concrete instance of `PeeringMapInput` via:
//
//	PeeringMap{ "key": PeeringArgs{...} }
type PeeringMapInput interface {
	pulumi.Input

	ToPeeringMapOutput() PeeringMapOutput
	ToPeeringMapOutputWithContext(context.Context) PeeringMapOutput
}

type PeeringMap map[string]PeeringInput

func (PeeringMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Peering)(nil)).Elem()
}

func (i PeeringMap) ToPeeringMapOutput() PeeringMapOutput {
	return i.ToPeeringMapOutputWithContext(context.Background())
}

func (i PeeringMap) ToPeeringMapOutputWithContext(ctx context.Context) PeeringMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PeeringMapOutput)
}

type PeeringOutput struct{ *pulumi.OutputState }

func (PeeringOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Peering)(nil)).Elem()
}

func (o PeeringOutput) ToPeeringOutput() PeeringOutput {
	return o
}

func (o PeeringOutput) ToPeeringOutputWithContext(ctx context.Context) PeeringOutput {
	return o
}

func (o PeeringOutput) DeletedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringOutput { return v.DeletedAt }).(pulumi.StringOutput)
}

// Specifies KV metadata to associate with the peering. This parameter is not required and does not directly impact the cluster peering process.
func (o PeeringOutput) Meta() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringMapOutput { return v.Meta }).(pulumi.StringMapOutput)
}

func (o PeeringOutput) Partition() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringPtrOutput { return v.Partition }).(pulumi.StringPtrOutput)
}

func (o PeeringOutput) PeerCaPems() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringArrayOutput { return v.PeerCaPems }).(pulumi.StringArrayOutput)
}

func (o PeeringOutput) PeerId() pulumi.StringOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringOutput { return v.PeerId }).(pulumi.StringOutput)
}

// The name assigned to the peer cluster. The `peerName` is used to reference the peer cluster in service discovery queries and configuration entries such as `service-intentions`. This field must be a valid DNS hostname label.
func (o PeeringOutput) PeerName() pulumi.StringOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringOutput { return v.PeerName }).(pulumi.StringOutput)
}

func (o PeeringOutput) PeerServerAddresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringArrayOutput { return v.PeerServerAddresses }).(pulumi.StringArrayOutput)
}

func (o PeeringOutput) PeerServerName() pulumi.StringOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringOutput { return v.PeerServerName }).(pulumi.StringOutput)
}

// The peering token fetched from the peer cluster.
func (o PeeringOutput) PeeringToken() pulumi.StringOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringOutput { return v.PeeringToken }).(pulumi.StringOutput)
}

func (o PeeringOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v *Peering) pulumi.StringOutput { return v.State }).(pulumi.StringOutput)
}

type PeeringArrayOutput struct{ *pulumi.OutputState }

func (PeeringArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Peering)(nil)).Elem()
}

func (o PeeringArrayOutput) ToPeeringArrayOutput() PeeringArrayOutput {
	return o
}

func (o PeeringArrayOutput) ToPeeringArrayOutputWithContext(ctx context.Context) PeeringArrayOutput {
	return o
}

func (o PeeringArrayOutput) Index(i pulumi.IntInput) PeeringOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Peering {
		return vs[0].([]*Peering)[vs[1].(int)]
	}).(PeeringOutput)
}

type PeeringMapOutput struct{ *pulumi.OutputState }

func (PeeringMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Peering)(nil)).Elem()
}

func (o PeeringMapOutput) ToPeeringMapOutput() PeeringMapOutput {
	return o
}

func (o PeeringMapOutput) ToPeeringMapOutputWithContext(ctx context.Context) PeeringMapOutput {
	return o
}

func (o PeeringMapOutput) MapIndex(k pulumi.StringInput) PeeringOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Peering {
		return vs[0].(map[string]*Peering)[vs[1].(string)]
	}).(PeeringOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*PeeringInput)(nil)).Elem(), &Peering{})
	pulumi.RegisterInputType(reflect.TypeOf((*PeeringArrayInput)(nil)).Elem(), PeeringArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*PeeringMapInput)(nil)).Elem(), PeeringMap{})
	pulumi.RegisterOutputType(PeeringOutput{})
	pulumi.RegisterOutputType(PeeringArrayOutput{})
	pulumi.RegisterOutputType(PeeringMapOutput{})
}
