# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from . import _utilities, _tables

__all__ = [
    'AclAuthMethodNamespaceRuleArgs',
    'AclRoleServiceIdentityArgs',
    'CatalogEntryServiceArgs',
    'KeyPrefixSubkeyCollectionArgs',
    'KeysKeyArgs',
    'PreparedQueryDnsArgs',
    'PreparedQueryFailoverArgs',
    'PreparedQueryTemplateArgs',
    'ServiceCheckArgs',
    'ServiceCheckHeaderArgs',
    'GetAclRolePolicyArgs',
    'GetAclRoleServiceIdentityArgs',
    'GetAclTokenPolicyArgs',
    'GetCatalogNodesQueryOptionArgs',
    'GetCatalogServiceQueryOptionArgs',
    'GetCatalogServicesQueryOptionArgs',
    'GetKeyPrefixSubkeyCollectionArgs',
    'GetKeysKeyArgs',
    'GetNodesQueryOptionArgs',
    'GetServiceQueryOptionArgs',
    'GetServicesQueryOptionArgs',
]

@pulumi.input_type
class AclAuthMethodNamespaceRuleArgs:
    def __init__(__self__, *,
                 bind_namespace: pulumi.Input[str],
                 selector: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bind_namespace: If the namespace rule's `selector` matches then
               this is used to control the namespace where the token is created.
        :param pulumi.Input[str] selector: Specifies the expression used to match this namespace
               rule against valid identities returned from an auth method validation.
               Defaults to `""`.
        """
        pulumi.set(__self__, "bind_namespace", bind_namespace)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter(name="bindNamespace")
    def bind_namespace(self) -> pulumi.Input[str]:
        """
        If the namespace rule's `selector` matches then
        this is used to control the namespace where the token is created.
        """
        return pulumi.get(self, "bind_namespace")

    @bind_namespace.setter
    def bind_namespace(self, value: pulumi.Input[str]):
        pulumi.set(self, "bind_namespace", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the expression used to match this namespace
        rule against valid identities returned from an auth method validation.
        Defaults to `""`.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "selector", value)


@pulumi.input_type
class AclRoleServiceIdentityArgs:
    def __init__(__self__, *,
                 service_name: pulumi.Input[str],
                 datacenters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] service_name: The name of the service.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] datacenters: The datacenters the effective policy is valid within.
        """
        pulumi.set(__self__, "service_name", service_name)
        if datacenters is not None:
            pulumi.set(__self__, "datacenters", datacenters)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> pulumi.Input[str]:
        """
        The name of the service.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter
    def datacenters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The datacenters the effective policy is valid within.
        """
        return pulumi.get(self, "datacenters")

    @datacenters.setter
    def datacenters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "datacenters", value)


@pulumi.input_type
class CatalogEntryServiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 address: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The name of the service
        :param pulumi.Input[str] address: The address of the service. Defaults to the
               node address.
        :param pulumi.Input[str] id: The ID of the service. Defaults to the `name`.
        :param pulumi.Input[int] port: The port of the service.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: A list of values that are opaque to Consul,
               but can be used to distinguish between services or nodes.
        """
        pulumi.set(__self__, "name", name)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the service
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The address of the service. Defaults to the
        node address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the service. Defaults to the `name`.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port of the service.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of values that are opaque to Consul,
        but can be used to distinguish between services or nodes.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class KeyPrefixSubkeyCollectionArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 value: pulumi.Input[str],
                 flags: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] path: This is the path (which will be appended to the given
               `path_prefix`) in Consul that should be written to.
        :param pulumi.Input[str] value: The value to write to the given path.
        :param pulumi.Input[int] flags: An [unsigned integer value](https://www.consul.io/api/kv.html#flags-1)
               to attach to the key (defaults to 0).
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "value", value)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        This is the path (which will be appended to the given
        `path_prefix`) in Consul that should be written to.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value to write to the given path.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def flags(self) -> Optional[pulumi.Input[int]]:
        """
        An [unsigned integer value](https://www.consul.io/api/kv.html#flags-1)
        to attach to the key (defaults to 0).
        """
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "flags", value)


@pulumi.input_type
class KeysKeyArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 default: Optional[pulumi.Input[str]] = None,
                 delete: Optional[pulumi.Input[bool]] = None,
                 flags: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] path: This is the path in Consul that should be written to.
        :param pulumi.Input[bool] delete: If true, then the key will be deleted when
               either its configuration block is removed from the configuration or
               the entire resource is destroyed. Otherwise, it will be left in Consul.
               Defaults to false.
        :param pulumi.Input[int] flags: An [unsigned integer value](https://www.consul.io/api/kv.html#flags-1)
               to attach to the key (defaults to 0).
        :param pulumi.Input[str] value: The value to write to the given path.
        """
        pulumi.set(__self__, "path", path)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if name is not None:
            warnings.warn("""Using consul_keys resource to *read* is deprecated; please use consul_keys data source instead""", DeprecationWarning)
            pulumi.log.warn("name is deprecated: Using consul_keys resource to *read* is deprecated; please use consul_keys data source instead")
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        This is the path in Consul that should be written to.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, then the key will be deleted when
        either its configuration block is removed from the configuration or
        the entire resource is destroyed. Otherwise, it will be left in Consul.
        Defaults to false.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter
    def flags(self) -> Optional[pulumi.Input[int]]:
        """
        An [unsigned integer value](https://www.consul.io/api/kv.html#flags-1)
        to attach to the key (defaults to 0).
        """
        return pulumi.get(self, "flags")

    @flags.setter
    def flags(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "flags", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value to write to the given path.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class PreparedQueryDnsArgs:
    def __init__(__self__, *,
                 ttl: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ttl: The TTL to send when returning DNS results.
        """
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[str]]:
        """
        The TTL to send when returning DNS results.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ttl", value)


@pulumi.input_type
class PreparedQueryFailoverArgs:
    def __init__(__self__, *,
                 datacenters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 nearest_n: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] datacenters: Remote datacenters to return results from.
        :param pulumi.Input[int] nearest_n: Return results from this many datacenters,
               sorted in ascending order of estimated RTT.
        """
        if datacenters is not None:
            pulumi.set(__self__, "datacenters", datacenters)
        if nearest_n is not None:
            pulumi.set(__self__, "nearest_n", nearest_n)

    @property
    @pulumi.getter
    def datacenters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Remote datacenters to return results from.
        """
        return pulumi.get(self, "datacenters")

    @datacenters.setter
    def datacenters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "datacenters", value)

    @property
    @pulumi.getter(name="nearestN")
    def nearest_n(self) -> Optional[pulumi.Input[int]]:
        """
        Return results from this many datacenters,
        sorted in ascending order of estimated RTT.
        """
        return pulumi.get(self, "nearest_n")

    @nearest_n.setter
    def nearest_n(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nearest_n", value)


@pulumi.input_type
class PreparedQueryTemplateArgs:
    def __init__(__self__, *,
                 regexp: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] regexp: The regular expression to match with. When using
               `name_prefix_match`, this regex is applied against the query name.
        :param pulumi.Input[str] type: The type of template matching to perform. Currently
               only `name_prefix_match` is supported.
        """
        pulumi.set(__self__, "regexp", regexp)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        """
        The regular expression to match with. When using
        `name_prefix_match`, this regex is applied against the query name.
        """
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of template matching to perform. Currently
        only `name_prefix_match` is supported.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ServiceCheckArgs:
    def __init__(__self__, *,
                 check_id: pulumi.Input[str],
                 interval: pulumi.Input[str],
                 name: pulumi.Input[str],
                 timeout: pulumi.Input[str],
                 deregister_critical_service_after: Optional[pulumi.Input[str]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceCheckHeaderArgs']]]] = None,
                 http: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 notes: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tcp: Optional[pulumi.Input[str]] = None,
                 tls_skip_verify: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] check_id: An ID, *unique per agent*. Will default to *name*
               if not set.
        :param pulumi.Input[str] interval: The interval to wait between each health-check
               invocation.
        :param pulumi.Input[str] name: The name of the health-check.
        :param pulumi.Input[str] timeout: The timeout value for HTTP checks.
        :param pulumi.Input[str] deregister_critical_service_after: The time after which
               the service is automatically deregistered when in the `critical` state.
               Defaults to `30s`.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceCheckHeaderArgs']]] headers: The headers to send for an HTTP check.
               The attributes of each header is given below.
        :param pulumi.Input[str] http: The HTTP endpoint to call for an HTTP check.
        :param pulumi.Input[str] method: The method to use for HTTP health-checks. Defaults
               to `GET`.
        :param pulumi.Input[str] notes: An opaque field meant to hold human readable text.
        :param pulumi.Input[str] status: The initial health-check status.
        :param pulumi.Input[str] tcp: The TCP address and port to connect to for a TCP check.
        :param pulumi.Input[bool] tls_skip_verify: Whether to deactivate certificate
               verification for HTTP health-checks. Defaults to `false`.
        """
        pulumi.set(__self__, "check_id", check_id)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "timeout", timeout)
        if deregister_critical_service_after is not None:
            pulumi.set(__self__, "deregister_critical_service_after", deregister_critical_service_after)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if tls_skip_verify is not None:
            pulumi.set(__self__, "tls_skip_verify", tls_skip_verify)

    @property
    @pulumi.getter(name="checkId")
    def check_id(self) -> pulumi.Input[str]:
        """
        An ID, *unique per agent*. Will default to *name*
        if not set.
        """
        return pulumi.get(self, "check_id")

    @check_id.setter
    def check_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "check_id", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[str]:
        """
        The interval to wait between each health-check
        invocation.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[str]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the health-check.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def timeout(self) -> pulumi.Input[str]:
        """
        The timeout value for HTTP checks.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: pulumi.Input[str]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="deregisterCriticalServiceAfter")
    def deregister_critical_service_after(self) -> Optional[pulumi.Input[str]]:
        """
        The time after which
        the service is automatically deregistered when in the `critical` state.
        Defaults to `30s`.
        """
        return pulumi.get(self, "deregister_critical_service_after")

    @deregister_critical_service_after.setter
    def deregister_critical_service_after(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deregister_critical_service_after", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceCheckHeaderArgs']]]]:
        """
        The headers to send for an HTTP check.
        The attributes of each header is given below.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceCheckHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP endpoint to call for an HTTP check.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        The method to use for HTTP health-checks. Defaults
        to `GET`.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def notes(self) -> Optional[pulumi.Input[str]]:
        """
        An opaque field meant to hold human readable text.
        """
        return pulumi.get(self, "notes")

    @notes.setter
    def notes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "notes", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The initial health-check status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def tcp(self) -> Optional[pulumi.Input[str]]:
        """
        The TCP address and port to connect to for a TCP check.
        """
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tcp", value)

    @property
    @pulumi.getter(name="tlsSkipVerify")
    def tls_skip_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to deactivate certificate
        verification for HTTP health-checks. Defaults to `false`.
        """
        return pulumi.get(self, "tls_skip_verify")

    @tls_skip_verify.setter
    def tls_skip_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls_skip_verify", value)


@pulumi.input_type
class ServiceCheckHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] name: The name of the header.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: The header's list of values.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the header.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The header's list of values.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetAclRolePolicyArgs:
    def __init__(__self__, *,
                 id: str,
                 name: str):
        """
        :param str name: The name of the ACL Role.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the ACL Role.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)


@pulumi.input_type
class GetAclRoleServiceIdentityArgs:
    def __init__(__self__, *,
                 datacenters: Optional[Sequence[str]] = None,
                 service_name: Optional[str] = None):
        if datacenters is not None:
            pulumi.set(__self__, "datacenters", datacenters)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def datacenters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "datacenters")

    @datacenters.setter
    def datacenters(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "datacenters", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[str]):
        pulumi.set(self, "service_name", value)


@pulumi.input_type
class GetAclTokenPolicyArgs:
    def __init__(__self__, *,
                 id: str,
                 name: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)


@pulumi.input_type
class GetCatalogNodesQueryOptionArgs:
    def __init__(__self__, *,
                 allow_stale: Optional[bool] = None,
                 datacenter: Optional[str] = None,
                 near: Optional[str] = None,
                 node_meta: Optional[Mapping[str, str]] = None,
                 require_consistent: Optional[bool] = None,
                 token: Optional[str] = None,
                 wait_index: Optional[int] = None,
                 wait_time: Optional[str] = None):
        if allow_stale is not None:
            pulumi.set(__self__, "allow_stale", allow_stale)
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if near is not None:
            pulumi.set(__self__, "near", near)
        if node_meta is not None:
            pulumi.set(__self__, "node_meta", node_meta)
        if require_consistent is not None:
            pulumi.set(__self__, "require_consistent", require_consistent)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if wait_index is not None:
            pulumi.set(__self__, "wait_index", wait_index)
        if wait_time is not None:
            pulumi.set(__self__, "wait_time", wait_time)

    @property
    @pulumi.getter(name="allowStale")
    def allow_stale(self) -> Optional[bool]:
        return pulumi.get(self, "allow_stale")

    @allow_stale.setter
    def allow_stale(self, value: Optional[bool]):
        pulumi.set(self, "allow_stale", value)

    @property
    @pulumi.getter
    def datacenter(self) -> Optional[str]:
        return pulumi.get(self, "datacenter")

    @datacenter.setter
    def datacenter(self, value: Optional[str]):
        pulumi.set(self, "datacenter", value)

    @property
    @pulumi.getter
    def near(self) -> Optional[str]:
        return pulumi.get(self, "near")

    @near.setter
    def near(self, value: Optional[str]):
        pulumi.set(self, "near", value)

    @property
    @pulumi.getter(name="nodeMeta")
    def node_meta(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "node_meta")

    @node_meta.setter
    def node_meta(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "node_meta", value)

    @property
    @pulumi.getter(name="requireConsistent")
    def require_consistent(self) -> Optional[bool]:
        return pulumi.get(self, "require_consistent")

    @require_consistent.setter
    def require_consistent(self, value: Optional[bool]):
        pulumi.set(self, "require_consistent", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="waitIndex")
    def wait_index(self) -> Optional[int]:
        return pulumi.get(self, "wait_index")

    @wait_index.setter
    def wait_index(self, value: Optional[int]):
        pulumi.set(self, "wait_index", value)

    @property
    @pulumi.getter(name="waitTime")
    def wait_time(self) -> Optional[str]:
        return pulumi.get(self, "wait_time")

    @wait_time.setter
    def wait_time(self, value: Optional[str]):
        pulumi.set(self, "wait_time", value)


@pulumi.input_type
class GetCatalogServiceQueryOptionArgs:
    def __init__(__self__, *,
                 allow_stale: Optional[bool] = None,
                 datacenter: Optional[str] = None,
                 namespace: Optional[str] = None,
                 near: Optional[str] = None,
                 node_meta: Optional[Mapping[str, str]] = None,
                 require_consistent: Optional[bool] = None,
                 token: Optional[str] = None,
                 wait_index: Optional[int] = None,
                 wait_time: Optional[str] = None):
        if allow_stale is not None:
            pulumi.set(__self__, "allow_stale", allow_stale)
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if near is not None:
            pulumi.set(__self__, "near", near)
        if node_meta is not None:
            pulumi.set(__self__, "node_meta", node_meta)
        if require_consistent is not None:
            pulumi.set(__self__, "require_consistent", require_consistent)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if wait_index is not None:
            pulumi.set(__self__, "wait_index", wait_index)
        if wait_time is not None:
            pulumi.set(__self__, "wait_time", wait_time)

    @property
    @pulumi.getter(name="allowStale")
    def allow_stale(self) -> Optional[bool]:
        return pulumi.get(self, "allow_stale")

    @allow_stale.setter
    def allow_stale(self, value: Optional[bool]):
        pulumi.set(self, "allow_stale", value)

    @property
    @pulumi.getter
    def datacenter(self) -> Optional[str]:
        return pulumi.get(self, "datacenter")

    @datacenter.setter
    def datacenter(self, value: Optional[str]):
        pulumi.set(self, "datacenter", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def near(self) -> Optional[str]:
        return pulumi.get(self, "near")

    @near.setter
    def near(self, value: Optional[str]):
        pulumi.set(self, "near", value)

    @property
    @pulumi.getter(name="nodeMeta")
    def node_meta(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "node_meta")

    @node_meta.setter
    def node_meta(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "node_meta", value)

    @property
    @pulumi.getter(name="requireConsistent")
    def require_consistent(self) -> Optional[bool]:
        return pulumi.get(self, "require_consistent")

    @require_consistent.setter
    def require_consistent(self, value: Optional[bool]):
        pulumi.set(self, "require_consistent", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="waitIndex")
    def wait_index(self) -> Optional[int]:
        return pulumi.get(self, "wait_index")

    @wait_index.setter
    def wait_index(self, value: Optional[int]):
        pulumi.set(self, "wait_index", value)

    @property
    @pulumi.getter(name="waitTime")
    def wait_time(self) -> Optional[str]:
        return pulumi.get(self, "wait_time")

    @wait_time.setter
    def wait_time(self, value: Optional[str]):
        pulumi.set(self, "wait_time", value)


@pulumi.input_type
class GetCatalogServicesQueryOptionArgs:
    def __init__(__self__, *,
                 allow_stale: Optional[bool] = None,
                 datacenter: Optional[str] = None,
                 namespace: Optional[str] = None,
                 near: Optional[str] = None,
                 node_meta: Optional[Mapping[str, str]] = None,
                 require_consistent: Optional[bool] = None,
                 token: Optional[str] = None,
                 wait_index: Optional[int] = None,
                 wait_time: Optional[str] = None):
        if allow_stale is not None:
            pulumi.set(__self__, "allow_stale", allow_stale)
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if near is not None:
            pulumi.set(__self__, "near", near)
        if node_meta is not None:
            pulumi.set(__self__, "node_meta", node_meta)
        if require_consistent is not None:
            pulumi.set(__self__, "require_consistent", require_consistent)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if wait_index is not None:
            pulumi.set(__self__, "wait_index", wait_index)
        if wait_time is not None:
            pulumi.set(__self__, "wait_time", wait_time)

    @property
    @pulumi.getter(name="allowStale")
    def allow_stale(self) -> Optional[bool]:
        return pulumi.get(self, "allow_stale")

    @allow_stale.setter
    def allow_stale(self, value: Optional[bool]):
        pulumi.set(self, "allow_stale", value)

    @property
    @pulumi.getter
    def datacenter(self) -> Optional[str]:
        return pulumi.get(self, "datacenter")

    @datacenter.setter
    def datacenter(self, value: Optional[str]):
        pulumi.set(self, "datacenter", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def near(self) -> Optional[str]:
        return pulumi.get(self, "near")

    @near.setter
    def near(self, value: Optional[str]):
        pulumi.set(self, "near", value)

    @property
    @pulumi.getter(name="nodeMeta")
    def node_meta(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "node_meta")

    @node_meta.setter
    def node_meta(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "node_meta", value)

    @property
    @pulumi.getter(name="requireConsistent")
    def require_consistent(self) -> Optional[bool]:
        return pulumi.get(self, "require_consistent")

    @require_consistent.setter
    def require_consistent(self, value: Optional[bool]):
        pulumi.set(self, "require_consistent", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="waitIndex")
    def wait_index(self) -> Optional[int]:
        return pulumi.get(self, "wait_index")

    @wait_index.setter
    def wait_index(self, value: Optional[int]):
        pulumi.set(self, "wait_index", value)

    @property
    @pulumi.getter(name="waitTime")
    def wait_time(self) -> Optional[str]:
        return pulumi.get(self, "wait_time")

    @wait_time.setter
    def wait_time(self, value: Optional[str]):
        pulumi.set(self, "wait_time", value)


@pulumi.input_type
class GetKeyPrefixSubkeyCollectionArgs:
    def __init__(__self__, *,
                 name: str,
                 path: str,
                 default: Optional[str] = None):
        """
        :param str name: This is the name of the key. This value of the
               key is exposed as `var.<name>`. This is not the path of the subkey
               in Consul.
        :param str path: This is the subkey path in Consul (which will be appended
               to the given `path_prefix`) to construct the full key that will be used
               to read the value.
        :param str default: This is the default value to set for `var.<name>`
               if the key does not exist in Consul. Defaults to an empty string.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        if default is not None:
            pulumi.set(__self__, "default", default)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        This is the name of the key. This value of the
        key is exposed as `var.<name>`. This is not the path of the subkey
        in Consul.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        This is the subkey path in Consul (which will be appended
        to the given `path_prefix`) to construct the full key that will be used
        to read the value.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: str):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[str]:
        """
        This is the default value to set for `var.<name>`
        if the key does not exist in Consul. Defaults to an empty string.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[str]):
        pulumi.set(self, "default", value)


@pulumi.input_type
class GetKeysKeyArgs:
    def __init__(__self__, *,
                 name: str,
                 path: str,
                 default: Optional[str] = None):
        """
        :param str name: This is the name of the key. This value of the
               key is exposed as `var.<name>`. This is not the path of the key
               in Consul.
        :param str path: This is the path in Consul that should be read
               or written to.
        :param str default: This is the default value to set for `var.<name>`
               if the key does not exist in Consul. Defaults to an empty string.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        if default is not None:
            pulumi.set(__self__, "default", default)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        This is the name of the key. This value of the
        key is exposed as `var.<name>`. This is not the path of the key
        in Consul.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        This is the path in Consul that should be read
        or written to.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: str):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[str]:
        """
        This is the default value to set for `var.<name>`
        if the key does not exist in Consul. Defaults to an empty string.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[str]):
        pulumi.set(self, "default", value)


@pulumi.input_type
class GetNodesQueryOptionArgs:
    def __init__(__self__, *,
                 allow_stale: Optional[bool] = None,
                 datacenter: Optional[str] = None,
                 near: Optional[str] = None,
                 node_meta: Optional[Mapping[str, str]] = None,
                 require_consistent: Optional[bool] = None,
                 token: Optional[str] = None,
                 wait_index: Optional[int] = None,
                 wait_time: Optional[str] = None):
        """
        :param bool allow_stale: When `true`, the default, allow responses from
               Consul servers that are followers.
        :param str datacenter: The Consul datacenter to query.  Defaults to the
               same value found in `query_options` parameter specified below, or if that is
               empty, the `datacenter` value found in the Consul agent that this provider is
               configured to talk to then the datacenter in the provider setup.
        :param bool require_consistent: When `true` force the client to perform a
               read on at least quorum servers and verify the result is the same.  Defaults
               to `false`.
        :param str token: Specify the Consul ACL token to use when performing the
               request.  This defaults to the same API token configured by the `consul`
               provider but may be overriden if necessary.
        :param int wait_index: Index number used to enable blocking quereis.
        :param str wait_time: Max time the client should wait for a blocking query
               to return.
        """
        if allow_stale is not None:
            pulumi.set(__self__, "allow_stale", allow_stale)
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if near is not None:
            pulumi.set(__self__, "near", near)
        if node_meta is not None:
            pulumi.set(__self__, "node_meta", node_meta)
        if require_consistent is not None:
            pulumi.set(__self__, "require_consistent", require_consistent)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if wait_index is not None:
            pulumi.set(__self__, "wait_index", wait_index)
        if wait_time is not None:
            pulumi.set(__self__, "wait_time", wait_time)

    @property
    @pulumi.getter(name="allowStale")
    def allow_stale(self) -> Optional[bool]:
        """
        When `true`, the default, allow responses from
        Consul servers that are followers.
        """
        return pulumi.get(self, "allow_stale")

    @allow_stale.setter
    def allow_stale(self, value: Optional[bool]):
        pulumi.set(self, "allow_stale", value)

    @property
    @pulumi.getter
    def datacenter(self) -> Optional[str]:
        """
        The Consul datacenter to query.  Defaults to the
        same value found in `query_options` parameter specified below, or if that is
        empty, the `datacenter` value found in the Consul agent that this provider is
        configured to talk to then the datacenter in the provider setup.
        """
        return pulumi.get(self, "datacenter")

    @datacenter.setter
    def datacenter(self, value: Optional[str]):
        pulumi.set(self, "datacenter", value)

    @property
    @pulumi.getter
    def near(self) -> Optional[str]:
        return pulumi.get(self, "near")

    @near.setter
    def near(self, value: Optional[str]):
        pulumi.set(self, "near", value)

    @property
    @pulumi.getter(name="nodeMeta")
    def node_meta(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "node_meta")

    @node_meta.setter
    def node_meta(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "node_meta", value)

    @property
    @pulumi.getter(name="requireConsistent")
    def require_consistent(self) -> Optional[bool]:
        """
        When `true` force the client to perform a
        read on at least quorum servers and verify the result is the same.  Defaults
        to `false`.
        """
        return pulumi.get(self, "require_consistent")

    @require_consistent.setter
    def require_consistent(self, value: Optional[bool]):
        pulumi.set(self, "require_consistent", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        Specify the Consul ACL token to use when performing the
        request.  This defaults to the same API token configured by the `consul`
        provider but may be overriden if necessary.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="waitIndex")
    def wait_index(self) -> Optional[int]:
        """
        Index number used to enable blocking quereis.
        """
        return pulumi.get(self, "wait_index")

    @wait_index.setter
    def wait_index(self, value: Optional[int]):
        pulumi.set(self, "wait_index", value)

    @property
    @pulumi.getter(name="waitTime")
    def wait_time(self) -> Optional[str]:
        """
        Max time the client should wait for a blocking query
        to return.
        """
        return pulumi.get(self, "wait_time")

    @wait_time.setter
    def wait_time(self, value: Optional[str]):
        pulumi.set(self, "wait_time", value)


@pulumi.input_type
class GetServiceQueryOptionArgs:
    def __init__(__self__, *,
                 allow_stale: Optional[bool] = None,
                 datacenter: Optional[str] = None,
                 namespace: Optional[str] = None,
                 near: Optional[str] = None,
                 node_meta: Optional[Mapping[str, str]] = None,
                 require_consistent: Optional[bool] = None,
                 token: Optional[str] = None,
                 wait_index: Optional[int] = None,
                 wait_time: Optional[str] = None):
        """
        :param bool allow_stale: When `true`, the default, allow responses from
               Consul servers that are followers.
        :param str datacenter: The Consul datacenter to query.  Defaults to the
               same value found in `query_options` parameter specified below, or if that is
               empty, the `datacenter` value found in the Consul agent that this provider is
               configured to talk to.
        :param str namespace: The namespace to lookup the service.
        :param bool require_consistent: When `true` force the client to perform a
               read on at least quorum servers and verify the result is the same.  Defaults
               to `false`.
        :param str token: Specify the Consul ACL token to use when performing the
               request.  This defaults to the same API token configured by the `consul`
               provider but may be overriden if necessary.
        :param int wait_index: Index number used to enable blocking quereis.
        :param str wait_time: Max time the client should wait for a blocking query
               to return.
        """
        if allow_stale is not None:
            pulumi.set(__self__, "allow_stale", allow_stale)
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if near is not None:
            pulumi.set(__self__, "near", near)
        if node_meta is not None:
            pulumi.set(__self__, "node_meta", node_meta)
        if require_consistent is not None:
            pulumi.set(__self__, "require_consistent", require_consistent)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if wait_index is not None:
            pulumi.set(__self__, "wait_index", wait_index)
        if wait_time is not None:
            pulumi.set(__self__, "wait_time", wait_time)

    @property
    @pulumi.getter(name="allowStale")
    def allow_stale(self) -> Optional[bool]:
        """
        When `true`, the default, allow responses from
        Consul servers that are followers.
        """
        return pulumi.get(self, "allow_stale")

    @allow_stale.setter
    def allow_stale(self, value: Optional[bool]):
        pulumi.set(self, "allow_stale", value)

    @property
    @pulumi.getter
    def datacenter(self) -> Optional[str]:
        """
        The Consul datacenter to query.  Defaults to the
        same value found in `query_options` parameter specified below, or if that is
        empty, the `datacenter` value found in the Consul agent that this provider is
        configured to talk to.
        """
        return pulumi.get(self, "datacenter")

    @datacenter.setter
    def datacenter(self, value: Optional[str]):
        pulumi.set(self, "datacenter", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to lookup the service.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def near(self) -> Optional[str]:
        return pulumi.get(self, "near")

    @near.setter
    def near(self, value: Optional[str]):
        pulumi.set(self, "near", value)

    @property
    @pulumi.getter(name="nodeMeta")
    def node_meta(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "node_meta")

    @node_meta.setter
    def node_meta(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "node_meta", value)

    @property
    @pulumi.getter(name="requireConsistent")
    def require_consistent(self) -> Optional[bool]:
        """
        When `true` force the client to perform a
        read on at least quorum servers and verify the result is the same.  Defaults
        to `false`.
        """
        return pulumi.get(self, "require_consistent")

    @require_consistent.setter
    def require_consistent(self, value: Optional[bool]):
        pulumi.set(self, "require_consistent", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        Specify the Consul ACL token to use when performing the
        request.  This defaults to the same API token configured by the `consul`
        provider but may be overriden if necessary.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="waitIndex")
    def wait_index(self) -> Optional[int]:
        """
        Index number used to enable blocking quereis.
        """
        return pulumi.get(self, "wait_index")

    @wait_index.setter
    def wait_index(self, value: Optional[int]):
        pulumi.set(self, "wait_index", value)

    @property
    @pulumi.getter(name="waitTime")
    def wait_time(self) -> Optional[str]:
        """
        Max time the client should wait for a blocking query
        to return.
        """
        return pulumi.get(self, "wait_time")

    @wait_time.setter
    def wait_time(self, value: Optional[str]):
        pulumi.set(self, "wait_time", value)


@pulumi.input_type
class GetServicesQueryOptionArgs:
    def __init__(__self__, *,
                 allow_stale: Optional[bool] = None,
                 datacenter: Optional[str] = None,
                 namespace: Optional[str] = None,
                 near: Optional[str] = None,
                 node_meta: Optional[Mapping[str, str]] = None,
                 require_consistent: Optional[bool] = None,
                 token: Optional[str] = None,
                 wait_index: Optional[int] = None,
                 wait_time: Optional[str] = None):
        """
        :param bool allow_stale: When `true`, the default, allow responses from
               Consul servers that are followers.
        :param str datacenter: The Consul datacenter to query.  Defaults to the
               same value found in `query_options` parameter specified below, or if that is
               empty, the `datacenter` value found in the Consul agent that this provider is
               configured to talk to.
        :param str namespace: The namespace to lookup the services.
        :param bool require_consistent: When `true` force the client to perform a
               read on at least quorum servers and verify the result is the same.  Defaults
               to `false`.
        :param str token: Specify the Consul ACL token to use when performing the
               request.  This defaults to the same API token configured by the `consul`
               provider but may be overriden if necessary.
        :param int wait_index: Index number used to enable blocking quereis.
        :param str wait_time: Max time the client should wait for a blocking query
               to return.
        """
        if allow_stale is not None:
            pulumi.set(__self__, "allow_stale", allow_stale)
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if near is not None:
            pulumi.set(__self__, "near", near)
        if node_meta is not None:
            pulumi.set(__self__, "node_meta", node_meta)
        if require_consistent is not None:
            pulumi.set(__self__, "require_consistent", require_consistent)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if wait_index is not None:
            pulumi.set(__self__, "wait_index", wait_index)
        if wait_time is not None:
            pulumi.set(__self__, "wait_time", wait_time)

    @property
    @pulumi.getter(name="allowStale")
    def allow_stale(self) -> Optional[bool]:
        """
        When `true`, the default, allow responses from
        Consul servers that are followers.
        """
        return pulumi.get(self, "allow_stale")

    @allow_stale.setter
    def allow_stale(self, value: Optional[bool]):
        pulumi.set(self, "allow_stale", value)

    @property
    @pulumi.getter
    def datacenter(self) -> Optional[str]:
        """
        The Consul datacenter to query.  Defaults to the
        same value found in `query_options` parameter specified below, or if that is
        empty, the `datacenter` value found in the Consul agent that this provider is
        configured to talk to.
        """
        return pulumi.get(self, "datacenter")

    @datacenter.setter
    def datacenter(self, value: Optional[str]):
        pulumi.set(self, "datacenter", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The namespace to lookup the services.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def near(self) -> Optional[str]:
        return pulumi.get(self, "near")

    @near.setter
    def near(self, value: Optional[str]):
        pulumi.set(self, "near", value)

    @property
    @pulumi.getter(name="nodeMeta")
    def node_meta(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "node_meta")

    @node_meta.setter
    def node_meta(self, value: Optional[Mapping[str, str]]):
        pulumi.set(self, "node_meta", value)

    @property
    @pulumi.getter(name="requireConsistent")
    def require_consistent(self) -> Optional[bool]:
        """
        When `true` force the client to perform a
        read on at least quorum servers and verify the result is the same.  Defaults
        to `false`.
        """
        return pulumi.get(self, "require_consistent")

    @require_consistent.setter
    def require_consistent(self, value: Optional[bool]):
        pulumi.set(self, "require_consistent", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        Specify the Consul ACL token to use when performing the
        request.  This defaults to the same API token configured by the `consul`
        provider but may be overriden if necessary.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[str]):
        pulumi.set(self, "token", value)

    @property
    @pulumi.getter(name="waitIndex")
    def wait_index(self) -> Optional[int]:
        """
        Index number used to enable blocking quereis.
        """
        return pulumi.get(self, "wait_index")

    @wait_index.setter
    def wait_index(self, value: Optional[int]):
        pulumi.set(self, "wait_index", value)

    @property
    @pulumi.getter(name="waitTime")
    def wait_time(self) -> Optional[str]:
        """
        Max time the client should wait for a blocking query
        to return.
        """
        return pulumi.get(self, "wait_time")

    @wait_time.setter
    def wait_time(self, value: Optional[str]):
        pulumi.set(self, "wait_time", value)


