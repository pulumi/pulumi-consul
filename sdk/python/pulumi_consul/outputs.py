# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'AclAuthMethodNamespaceRule',
    'AclBindingRuleBindVars',
    'AclRoleNodeIdentity',
    'AclRoleServiceIdentity',
    'AclRoleTemplatedPolicy',
    'AclRoleTemplatedPolicyTemplateVariables',
    'AclTokenNodeIdentity',
    'AclTokenServiceIdentity',
    'AclTokenTemplatedPolicy',
    'AclTokenTemplatedPolicyTemplateVariables',
    'CatalogEntryService',
    'ConfigEntryServiceDefaultsDestination',
    'ConfigEntryServiceDefaultsEnvoyExtension',
    'ConfigEntryServiceDefaultsExpose',
    'ConfigEntryServiceDefaultsExposePath',
    'ConfigEntryServiceDefaultsMeshGateway',
    'ConfigEntryServiceDefaultsTransparentProxy',
    'ConfigEntryServiceDefaultsUpstreamConfig',
    'ConfigEntryServiceDefaultsUpstreamConfigDefault',
    'ConfigEntryServiceDefaultsUpstreamConfigDefaultLimit',
    'ConfigEntryServiceDefaultsUpstreamConfigDefaultMeshGateway',
    'ConfigEntryServiceDefaultsUpstreamConfigDefaultPassiveHealthCheck',
    'ConfigEntryServiceDefaultsUpstreamConfigOverride',
    'ConfigEntryServiceDefaultsUpstreamConfigOverrideLimit',
    'ConfigEntryServiceDefaultsUpstreamConfigOverrideMeshGateway',
    'ConfigEntryServiceDefaultsUpstreamConfigOverridePassiveHealthCheck',
    'ConfigEntryServiceIntentionsJwt',
    'ConfigEntryServiceIntentionsJwtProvider',
    'ConfigEntryServiceIntentionsJwtProviderVerifyClaim',
    'ConfigEntryServiceIntentionsSource',
    'ConfigEntryServiceIntentionsSourcePermission',
    'ConfigEntryServiceIntentionsSourcePermissionHttp',
    'ConfigEntryServiceIntentionsSourcePermissionHttpHeader',
    'ConfigEntryServiceResolverFailover',
    'ConfigEntryServiceResolverFailoverTarget',
    'ConfigEntryServiceResolverLoadBalancer',
    'ConfigEntryServiceResolverLoadBalancerHashPolicy',
    'ConfigEntryServiceResolverLoadBalancerHashPolicyCookieConfig',
    'ConfigEntryServiceResolverLoadBalancerLeastRequestConfig',
    'ConfigEntryServiceResolverLoadBalancerRingHashConfig',
    'ConfigEntryServiceResolverRedirect',
    'ConfigEntryServiceResolverSubset',
    'ConfigEntryServiceRouterRoute',
    'ConfigEntryServiceRouterRouteDestination',
    'ConfigEntryServiceRouterRouteDestinationRequestHeaders',
    'ConfigEntryServiceRouterRouteDestinationResponseHeaders',
    'ConfigEntryServiceRouterRouteMatch',
    'ConfigEntryServiceRouterRouteMatchHttp',
    'ConfigEntryServiceRouterRouteMatchHttpHeader',
    'ConfigEntryServiceRouterRouteMatchHttpQueryParam',
    'ConfigEntryServiceSplitterSplit',
    'ConfigEntryServiceSplitterSplitRequestHeaders',
    'ConfigEntryServiceSplitterSplitResponseHeaders',
    'KeyPrefixSubkeyCollection',
    'KeysKey',
    'PreparedQueryDns',
    'PreparedQueryFailover',
    'PreparedQueryFailoverTarget',
    'PreparedQueryTemplate',
    'ServiceCheck',
    'ServiceCheckHeader',
    'GetAclAuthMethodNamespaceRuleResult',
    'GetAclRoleNodeIdentityResult',
    'GetAclRolePolicyResult',
    'GetAclRoleServiceIdentityResult',
    'GetAclRoleTemplatedPolicyResult',
    'GetAclRoleTemplatedPolicyTemplateVariableResult',
    'GetAclTokenNodeIdentityResult',
    'GetAclTokenPolicyResult',
    'GetAclTokenRoleResult',
    'GetAclTokenServiceIdentityResult',
    'GetAclTokenTemplatedPolicyResult',
    'GetAclTokenTemplatedPolicyTemplateVariableResult',
    'GetAutopilotHealthServerResult',
    'GetCatalogNodesNodeResult',
    'GetCatalogNodesQueryOptionResult',
    'GetCatalogServiceQueryOptionResult',
    'GetCatalogServiceServiceResult',
    'GetCatalogServicesQueryOptionResult',
    'GetKeyPrefixSubkeyCollectionResult',
    'GetKeysKeyResult',
    'GetNetworkAreaMembersMemberResult',
    'GetNodesNodeResult',
    'GetNodesQueryOptionResult',
    'GetPeeringsPeerResult',
    'GetServiceHealthResultResult',
    'GetServiceHealthResultCheckResult',
    'GetServiceHealthResultNodeResult',
    'GetServiceHealthResultServiceResult',
    'GetServiceQueryOptionResult',
    'GetServiceServiceResult',
    'GetServicesQueryOptionResult',
]

@pulumi.output_type
class AclAuthMethodNamespaceRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindNamespace":
            suggest = "bind_namespace"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AclAuthMethodNamespaceRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AclAuthMethodNamespaceRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AclAuthMethodNamespaceRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind_namespace: _builtins.str,
                 selector: Optional[_builtins.str] = None):
        """
        :param _builtins.str bind_namespace: If the namespace rule's `selector` matches then this is used to control the namespace where the token is created.
        :param _builtins.str selector: Specifies the expression used to match this namespace rule against valid identities returned from an auth method validation.
        """
        pulumi.set(__self__, "bind_namespace", bind_namespace)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @_builtins.property
    @pulumi.getter(name="bindNamespace")
    def bind_namespace(self) -> _builtins.str:
        """
        If the namespace rule's `selector` matches then this is used to control the namespace where the token is created.
        """
        return pulumi.get(self, "bind_namespace")

    @_builtins.property
    @pulumi.getter
    def selector(self) -> Optional[_builtins.str]:
        """
        Specifies the expression used to match this namespace rule against valid identities returned from an auth method validation.
        """
        return pulumi.get(self, "selector")


@pulumi.output_type
class AclBindingRuleBindVars(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of node, workload identity or service.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of node, workload identity or service.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AclRoleNodeIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeName":
            suggest = "node_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AclRoleNodeIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AclRoleNodeIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AclRoleNodeIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter: _builtins.str,
                 node_name: _builtins.str):
        """
        :param _builtins.str datacenter: Specifies the node's datacenter.
        :param _builtins.str node_name: The name of the node.
        """
        pulumi.set(__self__, "datacenter", datacenter)
        pulumi.set(__self__, "node_name", node_name)

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> _builtins.str:
        """
        Specifies the node's datacenter.
        """
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> _builtins.str:
        """
        The name of the node.
        """
        return pulumi.get(self, "node_name")


@pulumi.output_type
class AclRoleServiceIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AclRoleServiceIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AclRoleServiceIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AclRoleServiceIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_name: _builtins.str,
                 datacenters: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str service_name: The name of the service.
        :param Sequence[_builtins.str] datacenters: The datacenters the effective policy is valid within. When no datacenters are provided the effective policy is valid in all datacenters including those which do not yet exist but may in the future.
        """
        pulumi.set(__self__, "service_name", service_name)
        if datacenters is not None:
            pulumi.set(__self__, "datacenters", datacenters)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> _builtins.str:
        """
        The name of the service.
        """
        return pulumi.get(self, "service_name")

    @_builtins.property
    @pulumi.getter
    def datacenters(self) -> Optional[Sequence[_builtins.str]]:
        """
        The datacenters the effective policy is valid within. When no datacenters are provided the effective policy is valid in all datacenters including those which do not yet exist but may in the future.
        """
        return pulumi.get(self, "datacenters")


@pulumi.output_type
class AclRoleTemplatedPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateName":
            suggest = "template_name"
        elif key == "templateVariables":
            suggest = "template_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AclRoleTemplatedPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AclRoleTemplatedPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AclRoleTemplatedPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template_name: _builtins.str,
                 datacenters: Optional[Sequence[_builtins.str]] = None,
                 template_variables: Optional['outputs.AclRoleTemplatedPolicyTemplateVariables'] = None):
        """
        :param _builtins.str template_name: The name of the templated policies.
        :param Sequence[_builtins.str] datacenters: Specifies the datacenters the effective policy is valid within.
        :param 'AclRoleTemplatedPolicyTemplateVariablesArgs' template_variables: The templated policy variables.
        """
        pulumi.set(__self__, "template_name", template_name)
        if datacenters is not None:
            pulumi.set(__self__, "datacenters", datacenters)
        if template_variables is not None:
            pulumi.set(__self__, "template_variables", template_variables)

    @_builtins.property
    @pulumi.getter(name="templateName")
    def template_name(self) -> _builtins.str:
        """
        The name of the templated policies.
        """
        return pulumi.get(self, "template_name")

    @_builtins.property
    @pulumi.getter
    def datacenters(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the datacenters the effective policy is valid within.
        """
        return pulumi.get(self, "datacenters")

    @_builtins.property
    @pulumi.getter(name="templateVariables")
    def template_variables(self) -> Optional['outputs.AclRoleTemplatedPolicyTemplateVariables']:
        """
        The templated policy variables.
        """
        return pulumi.get(self, "template_variables")


@pulumi.output_type
class AclRoleTemplatedPolicyTemplateVariables(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of node, workload identity or service.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of node, workload identity or service.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AclTokenNodeIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeName":
            suggest = "node_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AclTokenNodeIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AclTokenNodeIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AclTokenNodeIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter: _builtins.str,
                 node_name: _builtins.str):
        """
        :param _builtins.str datacenter: The datacenter of the node.
        :param _builtins.str node_name: The name of the node.
        """
        pulumi.set(__self__, "datacenter", datacenter)
        pulumi.set(__self__, "node_name", node_name)

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> _builtins.str:
        """
        The datacenter of the node.
        """
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> _builtins.str:
        """
        The name of the node.
        """
        return pulumi.get(self, "node_name")


@pulumi.output_type
class AclTokenServiceIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AclTokenServiceIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AclTokenServiceIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AclTokenServiceIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_name: _builtins.str,
                 datacenters: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str service_name: The name of the service.
        :param Sequence[_builtins.str] datacenters: Specifies the datacenters the effective policy is valid within.
        """
        pulumi.set(__self__, "service_name", service_name)
        if datacenters is not None:
            pulumi.set(__self__, "datacenters", datacenters)

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> _builtins.str:
        """
        The name of the service.
        """
        return pulumi.get(self, "service_name")

    @_builtins.property
    @pulumi.getter
    def datacenters(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the datacenters the effective policy is valid within.
        """
        return pulumi.get(self, "datacenters")


@pulumi.output_type
class AclTokenTemplatedPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateName":
            suggest = "template_name"
        elif key == "templateVariables":
            suggest = "template_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AclTokenTemplatedPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AclTokenTemplatedPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AclTokenTemplatedPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template_name: _builtins.str,
                 datacenters: Optional[Sequence[_builtins.str]] = None,
                 template_variables: Optional['outputs.AclTokenTemplatedPolicyTemplateVariables'] = None):
        """
        :param _builtins.str template_name: The name of the templated policies.
        :param Sequence[_builtins.str] datacenters: Specifies the datacenters the effective policy is valid within.
        :param 'AclTokenTemplatedPolicyTemplateVariablesArgs' template_variables: The templated policy variables.
        """
        pulumi.set(__self__, "template_name", template_name)
        if datacenters is not None:
            pulumi.set(__self__, "datacenters", datacenters)
        if template_variables is not None:
            pulumi.set(__self__, "template_variables", template_variables)

    @_builtins.property
    @pulumi.getter(name="templateName")
    def template_name(self) -> _builtins.str:
        """
        The name of the templated policies.
        """
        return pulumi.get(self, "template_name")

    @_builtins.property
    @pulumi.getter
    def datacenters(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the datacenters the effective policy is valid within.
        """
        return pulumi.get(self, "datacenters")

    @_builtins.property
    @pulumi.getter(name="templateVariables")
    def template_variables(self) -> Optional['outputs.AclTokenTemplatedPolicyTemplateVariables']:
        """
        The templated policy variables.
        """
        return pulumi.get(self, "template_variables")


@pulumi.output_type
class AclTokenTemplatedPolicyTemplateVariables(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of node, workload identity or service.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of node, workload identity or service.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CatalogEntryService(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 address: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 tags: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str name: The name of the service
        :param _builtins.str address: The address of the service. Defaults to the
               node address.
        :param _builtins.str id: The ID of the service. Defaults to the `name`.
        :param _builtins.int port: The port of the service.
        :param Sequence[_builtins.str] tags: A list of values that are opaque to Consul,
               but can be used to distinguish between services or nodes.
        """
        pulumi.set(__self__, "name", name)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the service
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        The address of the service. Defaults to the
        node address.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the service. Defaults to the `name`.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port of the service.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of values that are opaque to Consul,
        but can be used to distinguish between services or nodes.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ConfigEntryServiceDefaultsDestination(dict):
    def __init__(__self__, *,
                 addresses: Sequence[_builtins.str],
                 port: _builtins.int):
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "addresses")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        return pulumi.get(self, "port")


@pulumi.output_type
class ConfigEntryServiceDefaultsEnvoyExtension(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consulVersion":
            suggest = "consul_version"
        elif key == "envoyVersion":
            suggest = "envoy_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceDefaultsEnvoyExtension. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceDefaultsEnvoyExtension.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceDefaultsEnvoyExtension.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arguments: Optional[Mapping[str, _builtins.str]] = None,
                 consul_version: Optional[_builtins.str] = None,
                 envoy_version: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 required: Optional[_builtins.bool] = None):
        if arguments is not None:
            pulumi.set(__self__, "arguments", arguments)
        if consul_version is not None:
            pulumi.set(__self__, "consul_version", consul_version)
        if envoy_version is not None:
            pulumi.set(__self__, "envoy_version", envoy_version)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter
    def arguments(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "arguments")

    @_builtins.property
    @pulumi.getter(name="consulVersion")
    def consul_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "consul_version")

    @_builtins.property
    @pulumi.getter(name="envoyVersion")
    def envoy_version(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "envoy_version")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "required")


@pulumi.output_type
class ConfigEntryServiceDefaultsExpose(dict):
    def __init__(__self__, *,
                 checks: Optional[_builtins.bool] = None,
                 paths: Optional[Sequence['outputs.ConfigEntryServiceDefaultsExposePath']] = None):
        if checks is not None:
            pulumi.set(__self__, "checks", checks)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)

    @_builtins.property
    @pulumi.getter
    def checks(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "checks")

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Optional[Sequence['outputs.ConfigEntryServiceDefaultsExposePath']]:
        return pulumi.get(self, "paths")


@pulumi.output_type
class ConfigEntryServiceDefaultsExposePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "listenerPort":
            suggest = "listener_port"
        elif key == "localPathPort":
            suggest = "local_path_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceDefaultsExposePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceDefaultsExposePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceDefaultsExposePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 listener_port: Optional[_builtins.int] = None,
                 local_path_port: Optional[_builtins.int] = None,
                 path: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None):
        if listener_port is not None:
            pulumi.set(__self__, "listener_port", listener_port)
        if local_path_port is not None:
            pulumi.set(__self__, "local_path_port", local_path_port)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="listenerPort")
    def listener_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "listener_port")

    @_builtins.property
    @pulumi.getter(name="localPathPort")
    def local_path_port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "local_path_port")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "protocol")


@pulumi.output_type
class ConfigEntryServiceDefaultsMeshGateway(dict):
    def __init__(__self__, *,
                 mode: _builtins.str):
        pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> _builtins.str:
        return pulumi.get(self, "mode")


@pulumi.output_type
class ConfigEntryServiceDefaultsTransparentProxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dialedDirectly":
            suggest = "dialed_directly"
        elif key == "outboundListenerPort":
            suggest = "outbound_listener_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceDefaultsTransparentProxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceDefaultsTransparentProxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceDefaultsTransparentProxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dialed_directly: _builtins.bool,
                 outbound_listener_port: _builtins.int):
        pulumi.set(__self__, "dialed_directly", dialed_directly)
        pulumi.set(__self__, "outbound_listener_port", outbound_listener_port)

    @_builtins.property
    @pulumi.getter(name="dialedDirectly")
    def dialed_directly(self) -> _builtins.bool:
        return pulumi.get(self, "dialed_directly")

    @_builtins.property
    @pulumi.getter(name="outboundListenerPort")
    def outbound_listener_port(self) -> _builtins.int:
        return pulumi.get(self, "outbound_listener_port")


@pulumi.output_type
class ConfigEntryServiceDefaultsUpstreamConfig(dict):
    def __init__(__self__, *,
                 defaults: Optional[Sequence['outputs.ConfigEntryServiceDefaultsUpstreamConfigDefault']] = None,
                 overrides: Optional[Sequence['outputs.ConfigEntryServiceDefaultsUpstreamConfigOverride']] = None):
        """
        :param Sequence['ConfigEntryServiceDefaultsUpstreamConfigDefaultArgs'] defaults: Specifies configurations that set default upstream settings. For information about overriding the default configurations for in for individual upstreams, refer to UpstreamConfig.Overrides.
        :param Sequence['ConfigEntryServiceDefaultsUpstreamConfigOverrideArgs'] overrides: Specifies options that override the default upstream configurations for individual upstreams.
        """
        if defaults is not None:
            pulumi.set(__self__, "defaults", defaults)
        if overrides is not None:
            pulumi.set(__self__, "overrides", overrides)

    @_builtins.property
    @pulumi.getter
    def defaults(self) -> Optional[Sequence['outputs.ConfigEntryServiceDefaultsUpstreamConfigDefault']]:
        """
        Specifies configurations that set default upstream settings. For information about overriding the default configurations for in for individual upstreams, refer to UpstreamConfig.Overrides.
        """
        return pulumi.get(self, "defaults")

    @_builtins.property
    @pulumi.getter
    def overrides(self) -> Optional[Sequence['outputs.ConfigEntryServiceDefaultsUpstreamConfigOverride']]:
        """
        Specifies options that override the default upstream configurations for individual upstreams.
        """
        return pulumi.get(self, "overrides")


@pulumi.output_type
class ConfigEntryServiceDefaultsUpstreamConfigDefault(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "balanceOutboundConnections":
            suggest = "balance_outbound_connections"
        elif key == "connectTimeoutMs":
            suggest = "connect_timeout_ms"
        elif key == "meshGateways":
            suggest = "mesh_gateways"
        elif key == "passiveHealthChecks":
            suggest = "passive_health_checks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceDefaultsUpstreamConfigDefault. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceDefaultsUpstreamConfigDefault.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceDefaultsUpstreamConfigDefault.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 balance_outbound_connections: Optional[_builtins.str] = None,
                 connect_timeout_ms: Optional[_builtins.int] = None,
                 limits: Optional[Sequence['outputs.ConfigEntryServiceDefaultsUpstreamConfigDefaultLimit']] = None,
                 mesh_gateways: Optional[Sequence['outputs.ConfigEntryServiceDefaultsUpstreamConfigDefaultMeshGateway']] = None,
                 passive_health_checks: Optional[Sequence['outputs.ConfigEntryServiceDefaultsUpstreamConfigDefaultPassiveHealthCheck']] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str balance_outbound_connections: Sets the strategy for allocating outbound connections from upstreams across Envoy proxy threads.
        :param Sequence['ConfigEntryServiceDefaultsUpstreamConfigDefaultLimitArgs'] limits: Map that specifies a set of limits to apply to when connecting upstream services.
        :param Sequence['ConfigEntryServiceDefaultsUpstreamConfigDefaultMeshGatewayArgs'] mesh_gateways: Specifies the default mesh gateway mode field for all upstreams.
        :param Sequence['ConfigEntryServiceDefaultsUpstreamConfigDefaultPassiveHealthCheckArgs'] passive_health_checks: Map that specifies a set of rules that enable Consul to remove hosts from the upstream cluster that are unreachable or that return errors.
        :param _builtins.str protocol: Specifies the default protocol for the service.
        """
        if balance_outbound_connections is not None:
            pulumi.set(__self__, "balance_outbound_connections", balance_outbound_connections)
        if connect_timeout_ms is not None:
            pulumi.set(__self__, "connect_timeout_ms", connect_timeout_ms)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if mesh_gateways is not None:
            pulumi.set(__self__, "mesh_gateways", mesh_gateways)
        if passive_health_checks is not None:
            pulumi.set(__self__, "passive_health_checks", passive_health_checks)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="balanceOutboundConnections")
    def balance_outbound_connections(self) -> Optional[_builtins.str]:
        """
        Sets the strategy for allocating outbound connections from upstreams across Envoy proxy threads.
        """
        return pulumi.get(self, "balance_outbound_connections")

    @_builtins.property
    @pulumi.getter(name="connectTimeoutMs")
    def connect_timeout_ms(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "connect_timeout_ms")

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[Sequence['outputs.ConfigEntryServiceDefaultsUpstreamConfigDefaultLimit']]:
        """
        Map that specifies a set of limits to apply to when connecting upstream services.
        """
        return pulumi.get(self, "limits")

    @_builtins.property
    @pulumi.getter(name="meshGateways")
    def mesh_gateways(self) -> Optional[Sequence['outputs.ConfigEntryServiceDefaultsUpstreamConfigDefaultMeshGateway']]:
        """
        Specifies the default mesh gateway mode field for all upstreams.
        """
        return pulumi.get(self, "mesh_gateways")

    @_builtins.property
    @pulumi.getter(name="passiveHealthChecks")
    def passive_health_checks(self) -> Optional[Sequence['outputs.ConfigEntryServiceDefaultsUpstreamConfigDefaultPassiveHealthCheck']]:
        """
        Map that specifies a set of rules that enable Consul to remove hosts from the upstream cluster that are unreachable or that return errors.
        """
        return pulumi.get(self, "passive_health_checks")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Specifies the default protocol for the service.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class ConfigEntryServiceDefaultsUpstreamConfigDefaultLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentRequests":
            suggest = "max_concurrent_requests"
        elif key == "maxConnections":
            suggest = "max_connections"
        elif key == "maxPendingRequests":
            suggest = "max_pending_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceDefaultsUpstreamConfigDefaultLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceDefaultsUpstreamConfigDefaultLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceDefaultsUpstreamConfigDefaultLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_requests: Optional[_builtins.int] = None,
                 max_connections: Optional[_builtins.int] = None,
                 max_pending_requests: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_concurrent_requests: Specifies the maximum number of concurrent requests.
        :param _builtins.int max_connections: Specifies the maximum number of connections a service instance can establish against the upstream.
        :param _builtins.int max_pending_requests: Specifies the maximum number of requests that are queued while waiting for a connection to establish.
        """
        if max_concurrent_requests is not None:
            pulumi.set(__self__, "max_concurrent_requests", max_concurrent_requests)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if max_pending_requests is not None:
            pulumi.set(__self__, "max_pending_requests", max_pending_requests)

    @_builtins.property
    @pulumi.getter(name="maxConcurrentRequests")
    def max_concurrent_requests(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum number of concurrent requests.
        """
        return pulumi.get(self, "max_concurrent_requests")

    @_builtins.property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum number of connections a service instance can establish against the upstream.
        """
        return pulumi.get(self, "max_connections")

    @_builtins.property
    @pulumi.getter(name="maxPendingRequests")
    def max_pending_requests(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum number of requests that are queued while waiting for a connection to establish.
        """
        return pulumi.get(self, "max_pending_requests")


@pulumi.output_type
class ConfigEntryServiceDefaultsUpstreamConfigDefaultMeshGateway(dict):
    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None):
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")


@pulumi.output_type
class ConfigEntryServiceDefaultsUpstreamConfigDefaultPassiveHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseEjectionTime":
            suggest = "base_ejection_time"
        elif key == "enforcingConsecutive5xx":
            suggest = "enforcing_consecutive5xx"
        elif key == "maxEjectionPercent":
            suggest = "max_ejection_percent"
        elif key == "maxFailures":
            suggest = "max_failures"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceDefaultsUpstreamConfigDefaultPassiveHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceDefaultsUpstreamConfigDefaultPassiveHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceDefaultsUpstreamConfigDefaultPassiveHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_ejection_time: Optional[_builtins.str] = None,
                 enforcing_consecutive5xx: Optional[_builtins.int] = None,
                 interval: Optional[_builtins.str] = None,
                 max_ejection_percent: Optional[_builtins.int] = None,
                 max_failures: Optional[_builtins.int] = None):
        """
        :param _builtins.str base_ejection_time: Specifies the minimum amount of time that an ejected host must remain outside the cluster before rejoining.
        :param _builtins.int enforcing_consecutive5xx: Specifies a percentage that indicates how many times out of 100 that Consul ejects the host when it detects an outlier status.
        :param _builtins.str interval: Specifies the time between checks.
        :param _builtins.int max_ejection_percent: Specifies the maximum percentage of an upstream cluster that Consul ejects when the proxy reports an outlier.
        :param _builtins.int max_failures: Specifies the number of consecutive failures allowed per check interval. If exceeded, Consul removes the host from the load balancer.
        """
        if base_ejection_time is not None:
            pulumi.set(__self__, "base_ejection_time", base_ejection_time)
        if enforcing_consecutive5xx is not None:
            pulumi.set(__self__, "enforcing_consecutive5xx", enforcing_consecutive5xx)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if max_ejection_percent is not None:
            pulumi.set(__self__, "max_ejection_percent", max_ejection_percent)
        if max_failures is not None:
            pulumi.set(__self__, "max_failures", max_failures)

    @_builtins.property
    @pulumi.getter(name="baseEjectionTime")
    def base_ejection_time(self) -> Optional[_builtins.str]:
        """
        Specifies the minimum amount of time that an ejected host must remain outside the cluster before rejoining.
        """
        return pulumi.get(self, "base_ejection_time")

    @_builtins.property
    @pulumi.getter(name="enforcingConsecutive5xx")
    def enforcing_consecutive5xx(self) -> Optional[_builtins.int]:
        """
        Specifies a percentage that indicates how many times out of 100 that Consul ejects the host when it detects an outlier status.
        """
        return pulumi.get(self, "enforcing_consecutive5xx")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.str]:
        """
        Specifies the time between checks.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum percentage of an upstream cluster that Consul ejects when the proxy reports an outlier.
        """
        return pulumi.get(self, "max_ejection_percent")

    @_builtins.property
    @pulumi.getter(name="maxFailures")
    def max_failures(self) -> Optional[_builtins.int]:
        """
        Specifies the number of consecutive failures allowed per check interval. If exceeded, Consul removes the host from the load balancer.
        """
        return pulumi.get(self, "max_failures")


@pulumi.output_type
class ConfigEntryServiceDefaultsUpstreamConfigOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "balanceOutboundConnections":
            suggest = "balance_outbound_connections"
        elif key == "connectTimeoutMs":
            suggest = "connect_timeout_ms"
        elif key == "envoyListenerJson":
            suggest = "envoy_listener_json"
        elif key == "meshGateways":
            suggest = "mesh_gateways"
        elif key == "passiveHealthChecks":
            suggest = "passive_health_checks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceDefaultsUpstreamConfigOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceDefaultsUpstreamConfigOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceDefaultsUpstreamConfigOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 balance_outbound_connections: Optional[_builtins.str] = None,
                 connect_timeout_ms: Optional[_builtins.int] = None,
                 envoy_listener_json: Optional[_builtins.str] = None,
                 limits: Optional[Sequence['outputs.ConfigEntryServiceDefaultsUpstreamConfigOverrideLimit']] = None,
                 mesh_gateways: Optional[Sequence['outputs.ConfigEntryServiceDefaultsUpstreamConfigOverrideMeshGateway']] = None,
                 name: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 partition: Optional[_builtins.str] = None,
                 passive_health_checks: Optional[Sequence['outputs.ConfigEntryServiceDefaultsUpstreamConfigOverridePassiveHealthCheck']] = None,
                 peer: Optional[_builtins.str] = None,
                 protocol: Optional[_builtins.str] = None):
        """
        :param _builtins.str balance_outbound_connections: Sets the strategy for allocating outbound connections from upstreams across Envoy proxy threads.
        :param Sequence['ConfigEntryServiceDefaultsUpstreamConfigOverrideLimitArgs'] limits: Map that specifies a set of limits to apply to when connecting upstream services.
        :param Sequence['ConfigEntryServiceDefaultsUpstreamConfigOverrideMeshGatewayArgs'] mesh_gateways: Specifies the default mesh gateway mode field for all upstreams.
        :param _builtins.str name: Specifies the name of the service you are setting the defaults for.
        :param _builtins.str namespace: Specifies the namespace containing the upstream service that the configuration applies to.
        :param _builtins.str partition: Specifies the name of the name of the Consul admin partition that the configuration entry applies to.
        :param Sequence['ConfigEntryServiceDefaultsUpstreamConfigOverridePassiveHealthCheckArgs'] passive_health_checks: Map that specifies a set of rules that enable Consul to remove hosts from the upstream cluster that are unreachable or that return errors.
        :param _builtins.str peer: Specifies the peer name of the upstream service that the configuration applies to.
        :param _builtins.str protocol: Specifies the default protocol for the service.
        """
        if balance_outbound_connections is not None:
            pulumi.set(__self__, "balance_outbound_connections", balance_outbound_connections)
        if connect_timeout_ms is not None:
            pulumi.set(__self__, "connect_timeout_ms", connect_timeout_ms)
        if envoy_listener_json is not None:
            pulumi.set(__self__, "envoy_listener_json", envoy_listener_json)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if mesh_gateways is not None:
            pulumi.set(__self__, "mesh_gateways", mesh_gateways)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if passive_health_checks is not None:
            pulumi.set(__self__, "passive_health_checks", passive_health_checks)
        if peer is not None:
            pulumi.set(__self__, "peer", peer)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter(name="balanceOutboundConnections")
    def balance_outbound_connections(self) -> Optional[_builtins.str]:
        """
        Sets the strategy for allocating outbound connections from upstreams across Envoy proxy threads.
        """
        return pulumi.get(self, "balance_outbound_connections")

    @_builtins.property
    @pulumi.getter(name="connectTimeoutMs")
    def connect_timeout_ms(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "connect_timeout_ms")

    @_builtins.property
    @pulumi.getter(name="envoyListenerJson")
    def envoy_listener_json(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "envoy_listener_json")

    @_builtins.property
    @pulumi.getter
    def limits(self) -> Optional[Sequence['outputs.ConfigEntryServiceDefaultsUpstreamConfigOverrideLimit']]:
        """
        Map that specifies a set of limits to apply to when connecting upstream services.
        """
        return pulumi.get(self, "limits")

    @_builtins.property
    @pulumi.getter(name="meshGateways")
    def mesh_gateways(self) -> Optional[Sequence['outputs.ConfigEntryServiceDefaultsUpstreamConfigOverrideMeshGateway']]:
        """
        Specifies the default mesh gateway mode field for all upstreams.
        """
        return pulumi.get(self, "mesh_gateways")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the name of the service you are setting the defaults for.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Specifies the namespace containing the upstream service that the configuration applies to.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def partition(self) -> Optional[_builtins.str]:
        """
        Specifies the name of the name of the Consul admin partition that the configuration entry applies to.
        """
        return pulumi.get(self, "partition")

    @_builtins.property
    @pulumi.getter(name="passiveHealthChecks")
    def passive_health_checks(self) -> Optional[Sequence['outputs.ConfigEntryServiceDefaultsUpstreamConfigOverridePassiveHealthCheck']]:
        """
        Map that specifies a set of rules that enable Consul to remove hosts from the upstream cluster that are unreachable or that return errors.
        """
        return pulumi.get(self, "passive_health_checks")

    @_builtins.property
    @pulumi.getter
    def peer(self) -> Optional[_builtins.str]:
        """
        Specifies the peer name of the upstream service that the configuration applies to.
        """
        return pulumi.get(self, "peer")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[_builtins.str]:
        """
        Specifies the default protocol for the service.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class ConfigEntryServiceDefaultsUpstreamConfigOverrideLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentRequests":
            suggest = "max_concurrent_requests"
        elif key == "maxConnections":
            suggest = "max_connections"
        elif key == "maxPendingRequests":
            suggest = "max_pending_requests"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceDefaultsUpstreamConfigOverrideLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceDefaultsUpstreamConfigOverrideLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceDefaultsUpstreamConfigOverrideLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrent_requests: Optional[_builtins.int] = None,
                 max_connections: Optional[_builtins.int] = None,
                 max_pending_requests: Optional[_builtins.int] = None):
        """
        :param _builtins.int max_concurrent_requests: Specifies the maximum number of concurrent requests.
        :param _builtins.int max_connections: Specifies the maximum number of connections a service instance can establish against the upstream.
        :param _builtins.int max_pending_requests: Specifies the maximum number of requests that are queued while waiting for a connection to establish.
        """
        if max_concurrent_requests is not None:
            pulumi.set(__self__, "max_concurrent_requests", max_concurrent_requests)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if max_pending_requests is not None:
            pulumi.set(__self__, "max_pending_requests", max_pending_requests)

    @_builtins.property
    @pulumi.getter(name="maxConcurrentRequests")
    def max_concurrent_requests(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum number of concurrent requests.
        """
        return pulumi.get(self, "max_concurrent_requests")

    @_builtins.property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum number of connections a service instance can establish against the upstream.
        """
        return pulumi.get(self, "max_connections")

    @_builtins.property
    @pulumi.getter(name="maxPendingRequests")
    def max_pending_requests(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum number of requests that are queued while waiting for a connection to establish.
        """
        return pulumi.get(self, "max_pending_requests")


@pulumi.output_type
class ConfigEntryServiceDefaultsUpstreamConfigOverrideMeshGateway(dict):
    def __init__(__self__, *,
                 mode: Optional[_builtins.str] = None):
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "mode")


@pulumi.output_type
class ConfigEntryServiceDefaultsUpstreamConfigOverridePassiveHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseEjectionTime":
            suggest = "base_ejection_time"
        elif key == "enforcingConsecutive5xx":
            suggest = "enforcing_consecutive5xx"
        elif key == "maxEjectionPercent":
            suggest = "max_ejection_percent"
        elif key == "maxFailures":
            suggest = "max_failures"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceDefaultsUpstreamConfigOverridePassiveHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceDefaultsUpstreamConfigOverridePassiveHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceDefaultsUpstreamConfigOverridePassiveHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_ejection_time: Optional[_builtins.str] = None,
                 enforcing_consecutive5xx: Optional[_builtins.int] = None,
                 interval: Optional[_builtins.str] = None,
                 max_ejection_percent: Optional[_builtins.int] = None,
                 max_failures: Optional[_builtins.int] = None):
        """
        :param _builtins.str base_ejection_time: Specifies the minimum amount of time that an ejected host must remain outside the cluster before rejoining.
        :param _builtins.int enforcing_consecutive5xx: Specifies a percentage that indicates how many times out of 100 that Consul ejects the host when it detects an outlier status.
        :param _builtins.str interval: Specifies the time between checks.
        :param _builtins.int max_ejection_percent: Specifies the maximum percentage of an upstream cluster that Consul ejects when the proxy reports an outlier.
        :param _builtins.int max_failures: Specifies the number of consecutive failures allowed per check interval. If exceeded, Consul removes the host from the load balancer.
        """
        if base_ejection_time is not None:
            pulumi.set(__self__, "base_ejection_time", base_ejection_time)
        if enforcing_consecutive5xx is not None:
            pulumi.set(__self__, "enforcing_consecutive5xx", enforcing_consecutive5xx)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if max_ejection_percent is not None:
            pulumi.set(__self__, "max_ejection_percent", max_ejection_percent)
        if max_failures is not None:
            pulumi.set(__self__, "max_failures", max_failures)

    @_builtins.property
    @pulumi.getter(name="baseEjectionTime")
    def base_ejection_time(self) -> Optional[_builtins.str]:
        """
        Specifies the minimum amount of time that an ejected host must remain outside the cluster before rejoining.
        """
        return pulumi.get(self, "base_ejection_time")

    @_builtins.property
    @pulumi.getter(name="enforcingConsecutive5xx")
    def enforcing_consecutive5xx(self) -> Optional[_builtins.int]:
        """
        Specifies a percentage that indicates how many times out of 100 that Consul ejects the host when it detects an outlier status.
        """
        return pulumi.get(self, "enforcing_consecutive5xx")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[_builtins.str]:
        """
        Specifies the time between checks.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> Optional[_builtins.int]:
        """
        Specifies the maximum percentage of an upstream cluster that Consul ejects when the proxy reports an outlier.
        """
        return pulumi.get(self, "max_ejection_percent")

    @_builtins.property
    @pulumi.getter(name="maxFailures")
    def max_failures(self) -> Optional[_builtins.int]:
        """
        Specifies the number of consecutive failures allowed per check interval. If exceeded, Consul removes the host from the load balancer.
        """
        return pulumi.get(self, "max_failures")


@pulumi.output_type
class ConfigEntryServiceIntentionsJwt(dict):
    def __init__(__self__, *,
                 providers: Optional[Sequence['outputs.ConfigEntryServiceIntentionsJwtProvider']] = None):
        """
        :param Sequence['ConfigEntryServiceIntentionsJwtProviderArgs'] providers: Specifies the names of one or more previously configured JWT provider configuration entries, which include the information necessary to validate a JSON web token.
        """
        if providers is not None:
            pulumi.set(__self__, "providers", providers)

    @_builtins.property
    @pulumi.getter
    def providers(self) -> Optional[Sequence['outputs.ConfigEntryServiceIntentionsJwtProvider']]:
        """
        Specifies the names of one or more previously configured JWT provider configuration entries, which include the information necessary to validate a JSON web token.
        """
        return pulumi.get(self, "providers")


@pulumi.output_type
class ConfigEntryServiceIntentionsJwtProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "verifyClaims":
            suggest = "verify_claims"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceIntentionsJwtProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceIntentionsJwtProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceIntentionsJwtProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 verify_claims: Optional[Sequence['outputs.ConfigEntryServiceIntentionsJwtProviderVerifyClaim']] = None):
        """
        :param _builtins.str name: Specifies the name of a JWT provider defined in the Name field of the jwt-provider configuration entry.
        :param Sequence['ConfigEntryServiceIntentionsJwtProviderVerifyClaimArgs'] verify_claims: Specifies additional token information to verify beyond what is configured in the JWT provider configuration entry.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if verify_claims is not None:
            pulumi.set(__self__, "verify_claims", verify_claims)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the name of a JWT provider defined in the Name field of the jwt-provider configuration entry.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="verifyClaims")
    def verify_claims(self) -> Optional[Sequence['outputs.ConfigEntryServiceIntentionsJwtProviderVerifyClaim']]:
        """
        Specifies additional token information to verify beyond what is configured in the JWT provider configuration entry.
        """
        return pulumi.get(self, "verify_claims")


@pulumi.output_type
class ConfigEntryServiceIntentionsJwtProviderVerifyClaim(dict):
    def __init__(__self__, *,
                 paths: Optional[Sequence[_builtins.str]] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] paths: Specifies the path to the claim in the JSON web token.
        :param _builtins.str value: Specifies the value to match on when verifying the the claim designated in path.
        """
        if paths is not None:
            pulumi.set(__self__, "paths", paths)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the path to the claim in the JSON web token.
        """
        return pulumi.get(self, "paths")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Specifies the value to match on when verifying the the claim designated in path.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ConfigEntryServiceIntentionsSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "samenessGroup":
            suggest = "sameness_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceIntentionsSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceIntentionsSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceIntentionsSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 partition: Optional[_builtins.str] = None,
                 peer: Optional[_builtins.str] = None,
                 permissions: Optional[Sequence['outputs.ConfigEntryServiceIntentionsSourcePermission']] = None,
                 precedence: Optional[_builtins.int] = None,
                 sameness_group: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str action: Specifies the action to take when the source sends traffic to the destination service.
        :param _builtins.str description: Specifies a description of the intention.
        :param _builtins.str name: Specifies the name of the source that the intention allows or denies traffic from.
        :param _builtins.str namespace: Specifies the traffic source namespace that the intention allows or denies traffic from.
        :param _builtins.str partition: Specifies the name of an admin partition that the intention allows or denies traffic from.
        :param _builtins.str peer: Specifies the name of a peered Consul cluster that the intention allows or denies traffic from
        :param Sequence['ConfigEntryServiceIntentionsSourcePermissionArgs'] permissions: Specifies a list of permissions for L7 traffic sources. The list contains one or more actions and a set of match criteria for each action.
        :param _builtins.int precedence: The Precedence field contains a read-only integer. Consul generates the value based on name configurations for the source and destination services.
        :param _builtins.str sameness_group: Specifies the name of a sameness group that the intention allows or denies traffic from.
        :param _builtins.str type: Specifies the type of destination service that the configuration entry applies to.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if peer is not None:
            pulumi.set(__self__, "peer", peer)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)
        if precedence is not None:
            pulumi.set(__self__, "precedence", precedence)
        if sameness_group is not None:
            pulumi.set(__self__, "sameness_group", sameness_group)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        Specifies the action to take when the source sends traffic to the destination service.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Specifies a description of the intention.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the name of the source that the intention allows or denies traffic from.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Specifies the traffic source namespace that the intention allows or denies traffic from.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def partition(self) -> Optional[_builtins.str]:
        """
        Specifies the name of an admin partition that the intention allows or denies traffic from.
        """
        return pulumi.get(self, "partition")

    @_builtins.property
    @pulumi.getter
    def peer(self) -> Optional[_builtins.str]:
        """
        Specifies the name of a peered Consul cluster that the intention allows or denies traffic from
        """
        return pulumi.get(self, "peer")

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> Optional[Sequence['outputs.ConfigEntryServiceIntentionsSourcePermission']]:
        """
        Specifies a list of permissions for L7 traffic sources. The list contains one or more actions and a set of match criteria for each action.
        """
        return pulumi.get(self, "permissions")

    @_builtins.property
    @pulumi.getter
    def precedence(self) -> Optional[_builtins.int]:
        """
        The Precedence field contains a read-only integer. Consul generates the value based on name configurations for the source and destination services.
        """
        return pulumi.get(self, "precedence")

    @_builtins.property
    @pulumi.getter(name="samenessGroup")
    def sameness_group(self) -> Optional[_builtins.str]:
        """
        Specifies the name of a sameness group that the intention allows or denies traffic from.
        """
        return pulumi.get(self, "sameness_group")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Specifies the type of destination service that the configuration entry applies to.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ConfigEntryServiceIntentionsSourcePermission(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 https: Sequence['outputs.ConfigEntryServiceIntentionsSourcePermissionHttp']):
        """
        :param _builtins.str action: Specifies the action to take when the source sends traffic to the destination service. The value is either allow or deny.
        :param Sequence['ConfigEntryServiceIntentionsSourcePermissionHttpArgs'] https: Specifies a set of HTTP-specific match criteria.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "https", https)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Specifies the action to take when the source sends traffic to the destination service. The value is either allow or deny.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def https(self) -> Sequence['outputs.ConfigEntryServiceIntentionsSourcePermissionHttp']:
        """
        Specifies a set of HTTP-specific match criteria.
        """
        return pulumi.get(self, "https")


@pulumi.output_type
class ConfigEntryServiceIntentionsSourcePermissionHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pathExact":
            suggest = "path_exact"
        elif key == "pathPrefix":
            suggest = "path_prefix"
        elif key == "pathRegex":
            suggest = "path_regex"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceIntentionsSourcePermissionHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceIntentionsSourcePermissionHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceIntentionsSourcePermissionHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence['outputs.ConfigEntryServiceIntentionsSourcePermissionHttpHeader']] = None,
                 methods: Optional[Sequence[_builtins.str]] = None,
                 path_exact: Optional[_builtins.str] = None,
                 path_prefix: Optional[_builtins.str] = None,
                 path_regex: Optional[_builtins.str] = None):
        """
        :param Sequence['ConfigEntryServiceIntentionsSourcePermissionHttpHeaderArgs'] headers: Specifies a header name and matching criteria for HTTP request headers.
        :param Sequence[_builtins.str] methods: Specifies a list of HTTP methods.
        :param _builtins.str path_exact: Specifies an exact path to match on the HTTP request path.
        :param _builtins.str path_prefix: Specifies a path prefix to match on the HTTP request path.
        :param _builtins.str path_regex: Defines a regular expression to match on the HTTP request path.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if path_exact is not None:
            pulumi.set(__self__, "path_exact", path_exact)
        if path_prefix is not None:
            pulumi.set(__self__, "path_prefix", path_prefix)
        if path_regex is not None:
            pulumi.set(__self__, "path_regex", path_regex)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.ConfigEntryServiceIntentionsSourcePermissionHttpHeader']]:
        """
        Specifies a header name and matching criteria for HTTP request headers.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies a list of HTTP methods.
        """
        return pulumi.get(self, "methods")

    @_builtins.property
    @pulumi.getter(name="pathExact")
    def path_exact(self) -> Optional[_builtins.str]:
        """
        Specifies an exact path to match on the HTTP request path.
        """
        return pulumi.get(self, "path_exact")

    @_builtins.property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> Optional[_builtins.str]:
        """
        Specifies a path prefix to match on the HTTP request path.
        """
        return pulumi.get(self, "path_prefix")

    @_builtins.property
    @pulumi.getter(name="pathRegex")
    def path_regex(self) -> Optional[_builtins.str]:
        """
        Defines a regular expression to match on the HTTP request path.
        """
        return pulumi.get(self, "path_regex")


@pulumi.output_type
class ConfigEntryServiceIntentionsSourcePermissionHttpHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 exact: Optional[_builtins.str] = None,
                 invert: Optional[_builtins.bool] = None,
                 prefix: Optional[_builtins.str] = None,
                 present: Optional[_builtins.bool] = None,
                 regex: Optional[_builtins.str] = None,
                 suffix: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Specifies the name of the header to match.
        :param _builtins.str exact: Specifies a value for the header key set in the Name field. If the request header value matches the Exact value, Consul applies the permission.
        :param _builtins.bool invert: Inverts the matching logic configured in the Header.
        :param _builtins.str prefix: Specifies a prefix value for the header key set in the Name field.
        :param _builtins.bool present: Enables a match if the header configured in the Name field appears in the request. Consul matches on any value as long as the header key appears in the request.
        :param _builtins.str regex: Specifies a regular expression pattern as the value for the header key set in the Name field.
        :param _builtins.str suffix: Specifies a suffix value for the header key set in the Name field.
        """
        pulumi.set(__self__, "name", name)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if invert is not None:
            pulumi.set(__self__, "invert", invert)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if present is not None:
            pulumi.set(__self__, "present", present)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Specifies the name of the header to match.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Specifies a value for the header key set in the Name field. If the request header value matches the Exact value, Consul applies the permission.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    def invert(self) -> Optional[_builtins.bool]:
        """
        Inverts the matching logic configured in the Header.
        """
        return pulumi.get(self, "invert")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Specifies a prefix value for the header key set in the Name field.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def present(self) -> Optional[_builtins.bool]:
        """
        Enables a match if the header configured in the Name field appears in the request. Consul matches on any value as long as the header key appears in the request.
        """
        return pulumi.get(self, "present")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        Specifies a regular expression pattern as the value for the header key set in the Name field.
        """
        return pulumi.get(self, "regex")

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[_builtins.str]:
        """
        Specifies a suffix value for the header key set in the Name field.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class ConfigEntryServiceResolverFailover(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subsetName":
            suggest = "subset_name"
        elif key == "samenessGroup":
            suggest = "sameness_group"
        elif key == "serviceSubset":
            suggest = "service_subset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceResolverFailover. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceResolverFailover.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceResolverFailover.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subset_name: _builtins.str,
                 datacenters: Optional[Sequence[_builtins.str]] = None,
                 namespace: Optional[_builtins.str] = None,
                 sameness_group: Optional[_builtins.str] = None,
                 service: Optional[_builtins.str] = None,
                 service_subset: Optional[_builtins.str] = None,
                 targets: Optional[Sequence['outputs.ConfigEntryServiceResolverFailoverTarget']] = None):
        """
        :param _builtins.str subset_name: Name of subset.
        :param Sequence[_builtins.str] datacenters: Specifies an ordered list of datacenters at the failover location to attempt connections to during a failover scenario. When Consul cannot establish a connection with the first datacenter in the list, it proceeds sequentially until establishing a connection with another datacenter.
        :param _builtins.str namespace: Specifies the namespace at the failover location where the failover services are deployed.
        :param _builtins.str sameness_group: Specifies the sameness group at the failover location where the failover services are deployed.
        :param _builtins.str service: Specifies the name of the service to resolve at the failover location during a failover scenario.
        :param _builtins.str service_subset: Specifies the name of a subset of service instances to resolve at the failover location during a failover scenario.
        :param Sequence['ConfigEntryServiceResolverFailoverTargetArgs'] targets: Specifies a fixed list of failover targets to try during failover. This list can express complicated failover scenarios.
        """
        pulumi.set(__self__, "subset_name", subset_name)
        if datacenters is not None:
            pulumi.set(__self__, "datacenters", datacenters)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if sameness_group is not None:
            pulumi.set(__self__, "sameness_group", sameness_group)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if service_subset is not None:
            pulumi.set(__self__, "service_subset", service_subset)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)

    @_builtins.property
    @pulumi.getter(name="subsetName")
    def subset_name(self) -> _builtins.str:
        """
        Name of subset.
        """
        return pulumi.get(self, "subset_name")

    @_builtins.property
    @pulumi.getter
    def datacenters(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies an ordered list of datacenters at the failover location to attempt connections to during a failover scenario. When Consul cannot establish a connection with the first datacenter in the list, it proceeds sequentially until establishing a connection with another datacenter.
        """
        return pulumi.get(self, "datacenters")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Specifies the namespace at the failover location where the failover services are deployed.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="samenessGroup")
    def sameness_group(self) -> Optional[_builtins.str]:
        """
        Specifies the sameness group at the failover location where the failover services are deployed.
        """
        return pulumi.get(self, "sameness_group")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Specifies the name of the service to resolve at the failover location during a failover scenario.
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter(name="serviceSubset")
    def service_subset(self) -> Optional[_builtins.str]:
        """
        Specifies the name of a subset of service instances to resolve at the failover location during a failover scenario.
        """
        return pulumi.get(self, "service_subset")

    @_builtins.property
    @pulumi.getter
    def targets(self) -> Optional[Sequence['outputs.ConfigEntryServiceResolverFailoverTarget']]:
        """
        Specifies a fixed list of failover targets to try during failover. This list can express complicated failover scenarios.
        """
        return pulumi.get(self, "targets")


@pulumi.output_type
class ConfigEntryServiceResolverFailoverTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceSubset":
            suggest = "service_subset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceResolverFailoverTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceResolverFailoverTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceResolverFailoverTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 partition: Optional[_builtins.str] = None,
                 peer: Optional[_builtins.str] = None,
                 service: Optional[_builtins.str] = None,
                 service_subset: Optional[_builtins.str] = None):
        """
        :param _builtins.str datacenter: Specifies the WAN federated datacenter to use for the failover target. If empty, the current datacenter is used.
        :param _builtins.str namespace: Specifies the namespace to use for the failover target. If empty, the default namespace is used.
        :param _builtins.str partition: Specifies the admin partition within the same datacenter to use for the failover target. If empty, the default partition is used.
        :param _builtins.str peer: Specifies the destination cluster peer to resolve the target service name from.
        :param _builtins.str service: Specifies the service name to use for the failover target. If empty, the current service name is used.
        :param _builtins.str service_subset: Specifies the named subset to use for the failover target. If empty, the default subset for the requested service name is used.
        """
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if peer is not None:
            pulumi.set(__self__, "peer", peer)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if service_subset is not None:
            pulumi.set(__self__, "service_subset", service_subset)

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> Optional[_builtins.str]:
        """
        Specifies the WAN federated datacenter to use for the failover target. If empty, the current datacenter is used.
        """
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Specifies the namespace to use for the failover target. If empty, the default namespace is used.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def partition(self) -> Optional[_builtins.str]:
        """
        Specifies the admin partition within the same datacenter to use for the failover target. If empty, the default partition is used.
        """
        return pulumi.get(self, "partition")

    @_builtins.property
    @pulumi.getter
    def peer(self) -> Optional[_builtins.str]:
        """
        Specifies the destination cluster peer to resolve the target service name from.
        """
        return pulumi.get(self, "peer")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Specifies the service name to use for the failover target. If empty, the current service name is used.
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter(name="serviceSubset")
    def service_subset(self) -> Optional[_builtins.str]:
        """
        Specifies the named subset to use for the failover target. If empty, the default subset for the requested service name is used.
        """
        return pulumi.get(self, "service_subset")


@pulumi.output_type
class ConfigEntryServiceResolverLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hashPolicies":
            suggest = "hash_policies"
        elif key == "leastRequestConfigs":
            suggest = "least_request_configs"
        elif key == "ringHashConfigs":
            suggest = "ring_hash_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceResolverLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceResolverLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceResolverLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hash_policies: Optional[Sequence['outputs.ConfigEntryServiceResolverLoadBalancerHashPolicy']] = None,
                 least_request_configs: Optional[Sequence['outputs.ConfigEntryServiceResolverLoadBalancerLeastRequestConfig']] = None,
                 policy: Optional[_builtins.str] = None,
                 ring_hash_configs: Optional[Sequence['outputs.ConfigEntryServiceResolverLoadBalancerRingHashConfig']] = None):
        """
        :param Sequence['ConfigEntryServiceResolverLoadBalancerHashPolicyArgs'] hash_policies: Specifies a list of hash policies to use for hashing load balancing algorithms. Consul evaluates hash policies individually and combines them so that identical lists result in the same hash.
        :param Sequence['ConfigEntryServiceResolverLoadBalancerLeastRequestConfigArgs'] least_request_configs: Specifies configuration for the least*request policy type.
        :param _builtins.str policy: Specifies the type of load balancing policy for selecting a host.
        :param Sequence['ConfigEntryServiceResolverLoadBalancerRingHashConfigArgs'] ring_hash_configs: Specifies configuration for the ring*hash policy type.
        """
        if hash_policies is not None:
            pulumi.set(__self__, "hash_policies", hash_policies)
        if least_request_configs is not None:
            pulumi.set(__self__, "least_request_configs", least_request_configs)
        if policy is not None:
            pulumi.set(__self__, "policy", policy)
        if ring_hash_configs is not None:
            pulumi.set(__self__, "ring_hash_configs", ring_hash_configs)

    @_builtins.property
    @pulumi.getter(name="hashPolicies")
    def hash_policies(self) -> Optional[Sequence['outputs.ConfigEntryServiceResolverLoadBalancerHashPolicy']]:
        """
        Specifies a list of hash policies to use for hashing load balancing algorithms. Consul evaluates hash policies individually and combines them so that identical lists result in the same hash.
        """
        return pulumi.get(self, "hash_policies")

    @_builtins.property
    @pulumi.getter(name="leastRequestConfigs")
    def least_request_configs(self) -> Optional[Sequence['outputs.ConfigEntryServiceResolverLoadBalancerLeastRequestConfig']]:
        """
        Specifies configuration for the least*request policy type.
        """
        return pulumi.get(self, "least_request_configs")

    @_builtins.property
    @pulumi.getter
    def policy(self) -> Optional[_builtins.str]:
        """
        Specifies the type of load balancing policy for selecting a host.
        """
        return pulumi.get(self, "policy")

    @_builtins.property
    @pulumi.getter(name="ringHashConfigs")
    def ring_hash_configs(self) -> Optional[Sequence['outputs.ConfigEntryServiceResolverLoadBalancerRingHashConfig']]:
        """
        Specifies configuration for the ring*hash policy type.
        """
        return pulumi.get(self, "ring_hash_configs")


@pulumi.output_type
class ConfigEntryServiceResolverLoadBalancerHashPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cookieConfigs":
            suggest = "cookie_configs"
        elif key == "fieldValue":
            suggest = "field_value"
        elif key == "sourceIp":
            suggest = "source_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceResolverLoadBalancerHashPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceResolverLoadBalancerHashPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceResolverLoadBalancerHashPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie_configs: Optional[Sequence['outputs.ConfigEntryServiceResolverLoadBalancerHashPolicyCookieConfig']] = None,
                 field: Optional[_builtins.str] = None,
                 field_value: Optional[_builtins.str] = None,
                 source_ip: Optional[_builtins.bool] = None,
                 terminal: Optional[_builtins.bool] = None):
        """
        :param Sequence['ConfigEntryServiceResolverLoadBalancerHashPolicyCookieConfigArgs'] cookie_configs: Specifies additional configuration options for the cookie hash policy type.
        :param _builtins.str field: Specifies the attribute type to hash on. You cannot specify the Field parameter if SourceIP is also configured.
        :param _builtins.str field_value: Specifies the value to hash, such as a header name, cookie name, or a URL query parameter name.
        :param _builtins.bool source_ip: Determines if the hash type should be source IP address.
        :param _builtins.bool terminal: Determines if Consul should stop computing the hash when multiple hash policies are present.
        """
        if cookie_configs is not None:
            pulumi.set(__self__, "cookie_configs", cookie_configs)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if field_value is not None:
            pulumi.set(__self__, "field_value", field_value)
        if source_ip is not None:
            pulumi.set(__self__, "source_ip", source_ip)
        if terminal is not None:
            pulumi.set(__self__, "terminal", terminal)

    @_builtins.property
    @pulumi.getter(name="cookieConfigs")
    def cookie_configs(self) -> Optional[Sequence['outputs.ConfigEntryServiceResolverLoadBalancerHashPolicyCookieConfig']]:
        """
        Specifies additional configuration options for the cookie hash policy type.
        """
        return pulumi.get(self, "cookie_configs")

    @_builtins.property
    @pulumi.getter
    def field(self) -> Optional[_builtins.str]:
        """
        Specifies the attribute type to hash on. You cannot specify the Field parameter if SourceIP is also configured.
        """
        return pulumi.get(self, "field")

    @_builtins.property
    @pulumi.getter(name="fieldValue")
    def field_value(self) -> Optional[_builtins.str]:
        """
        Specifies the value to hash, such as a header name, cookie name, or a URL query parameter name.
        """
        return pulumi.get(self, "field_value")

    @_builtins.property
    @pulumi.getter(name="sourceIp")
    def source_ip(self) -> Optional[_builtins.bool]:
        """
        Determines if the hash type should be source IP address.
        """
        return pulumi.get(self, "source_ip")

    @_builtins.property
    @pulumi.getter
    def terminal(self) -> Optional[_builtins.bool]:
        """
        Determines if Consul should stop computing the hash when multiple hash policies are present.
        """
        return pulumi.get(self, "terminal")


@pulumi.output_type
class ConfigEntryServiceResolverLoadBalancerHashPolicyCookieConfig(dict):
    def __init__(__self__, *,
                 path: Optional[_builtins.str] = None,
                 session: Optional[_builtins.bool] = None,
                 ttl: Optional[_builtins.str] = None):
        """
        :param _builtins.str path: Specifies the path to set for the cookie.
        :param _builtins.bool session: Directs Consul to generate a session cookie with no expiration.
        :param _builtins.str ttl: Specifies the TTL for generated cookies. Cannot be specified for session cookies.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if session is not None:
            pulumi.set(__self__, "session", session)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Specifies the path to set for the cookie.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def session(self) -> Optional[_builtins.bool]:
        """
        Directs Consul to generate a session cookie with no expiration.
        """
        return pulumi.get(self, "session")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.str]:
        """
        Specifies the TTL for generated cookies. Cannot be specified for session cookies.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class ConfigEntryServiceResolverLoadBalancerLeastRequestConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "choiceCount":
            suggest = "choice_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceResolverLoadBalancerLeastRequestConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceResolverLoadBalancerLeastRequestConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceResolverLoadBalancerLeastRequestConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 choice_count: Optional[_builtins.int] = None):
        if choice_count is not None:
            pulumi.set(__self__, "choice_count", choice_count)

    @_builtins.property
    @pulumi.getter(name="choiceCount")
    def choice_count(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "choice_count")


@pulumi.output_type
class ConfigEntryServiceResolverLoadBalancerRingHashConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maximumRingSize":
            suggest = "maximum_ring_size"
        elif key == "minimumRingSize":
            suggest = "minimum_ring_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceResolverLoadBalancerRingHashConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceResolverLoadBalancerRingHashConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceResolverLoadBalancerRingHashConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maximum_ring_size: Optional[_builtins.int] = None,
                 minimum_ring_size: Optional[_builtins.int] = None):
        """
        :param _builtins.int maximum_ring_size: Determines the maximum number of entries in the hash ring.
        :param _builtins.int minimum_ring_size: Determines the minimum number of entries in the hash ring.
        """
        if maximum_ring_size is not None:
            pulumi.set(__self__, "maximum_ring_size", maximum_ring_size)
        if minimum_ring_size is not None:
            pulumi.set(__self__, "minimum_ring_size", minimum_ring_size)

    @_builtins.property
    @pulumi.getter(name="maximumRingSize")
    def maximum_ring_size(self) -> Optional[_builtins.int]:
        """
        Determines the maximum number of entries in the hash ring.
        """
        return pulumi.get(self, "maximum_ring_size")

    @_builtins.property
    @pulumi.getter(name="minimumRingSize")
    def minimum_ring_size(self) -> Optional[_builtins.int]:
        """
        Determines the minimum number of entries in the hash ring.
        """
        return pulumi.get(self, "minimum_ring_size")


@pulumi.output_type
class ConfigEntryServiceResolverRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "samenessGroup":
            suggest = "sameness_group"
        elif key == "serviceSubset":
            suggest = "service_subset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceResolverRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceResolverRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceResolverRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 partition: Optional[_builtins.str] = None,
                 peer: Optional[_builtins.str] = None,
                 sameness_group: Optional[_builtins.str] = None,
                 service: Optional[_builtins.str] = None,
                 service_subset: Optional[_builtins.str] = None):
        """
        :param _builtins.str datacenter: Specifies the datacenter at the redirects destination that resolves local upstream requests.
        :param _builtins.str namespace: Specifies the namespace at the redirects destination that resolves local upstream requests.
        :param _builtins.str partition: Specifies the admin partition at the redirects destination that resolves local upstream requests.
        :param _builtins.str peer: Specifies the cluster with an active cluster peering connection at the redirects destination that resolves local upstream requests.
        :param _builtins.str sameness_group: Specifies the sameness group at the redirects destination that resolves local upstream requests.
        :param _builtins.str service: Specifies the name of a service at the redirects destination that resolves local upstream requests.
        :param _builtins.str service_subset: Specifies the name of a subset of services at the redirects destination that resolves local upstream requests. If empty, the default subset is used. If specified, you must also specify at least one of the following in the same Redirect map: Service, Namespace, andDatacenter.
        """
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if peer is not None:
            pulumi.set(__self__, "peer", peer)
        if sameness_group is not None:
            pulumi.set(__self__, "sameness_group", sameness_group)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if service_subset is not None:
            pulumi.set(__self__, "service_subset", service_subset)

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> Optional[_builtins.str]:
        """
        Specifies the datacenter at the redirects destination that resolves local upstream requests.
        """
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Specifies the namespace at the redirects destination that resolves local upstream requests.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def partition(self) -> Optional[_builtins.str]:
        """
        Specifies the admin partition at the redirects destination that resolves local upstream requests.
        """
        return pulumi.get(self, "partition")

    @_builtins.property
    @pulumi.getter
    def peer(self) -> Optional[_builtins.str]:
        """
        Specifies the cluster with an active cluster peering connection at the redirects destination that resolves local upstream requests.
        """
        return pulumi.get(self, "peer")

    @_builtins.property
    @pulumi.getter(name="samenessGroup")
    def sameness_group(self) -> Optional[_builtins.str]:
        """
        Specifies the sameness group at the redirects destination that resolves local upstream requests.
        """
        return pulumi.get(self, "sameness_group")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Specifies the name of a service at the redirects destination that resolves local upstream requests.
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter(name="serviceSubset")
    def service_subset(self) -> Optional[_builtins.str]:
        """
        Specifies the name of a subset of services at the redirects destination that resolves local upstream requests. If empty, the default subset is used. If specified, you must also specify at least one of the following in the same Redirect map: Service, Namespace, andDatacenter.
        """
        return pulumi.get(self, "service_subset")


@pulumi.output_type
class ConfigEntryServiceResolverSubset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onlyPassing":
            suggest = "only_passing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceResolverSubset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceResolverSubset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceResolverSubset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter: _builtins.str,
                 name: _builtins.str,
                 only_passing: _builtins.bool):
        """
        :param _builtins.str filter: Specifies an expression that filters the DNS elements of service instances that belong to the subset. If empty, all healthy instances of a service are returned.
        :param _builtins.str name: Name of subset.
        :param _builtins.bool only_passing: Determines if instances that return a warning from a health check are allowed to resolve a request. When set to false, instances with passing and warning states are considered healthy. When set to true, only instances with a passing health check state are considered healthy.
        """
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "only_passing", only_passing)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> _builtins.str:
        """
        Specifies an expression that filters the DNS elements of service instances that belong to the subset. If empty, all healthy instances of a service are returned.
        """
        return pulumi.get(self, "filter")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of subset.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="onlyPassing")
    def only_passing(self) -> _builtins.bool:
        """
        Determines if instances that return a warning from a health check are allowed to resolve a request. When set to false, instances with passing and warning states are considered healthy. When set to true, only instances with a passing health check state are considered healthy.
        """
        return pulumi.get(self, "only_passing")


@pulumi.output_type
class ConfigEntryServiceRouterRoute(dict):
    def __init__(__self__, *,
                 destination: Optional['outputs.ConfigEntryServiceRouterRouteDestination'] = None,
                 match: Optional['outputs.ConfigEntryServiceRouterRouteMatch'] = None):
        """
        :param 'ConfigEntryServiceRouterRouteDestinationArgs' destination: Specifies the target service to route matching requests to, as well as behavior for the request to follow when routed.
        :param 'ConfigEntryServiceRouterRouteMatchArgs' match: Describes a set of criteria that Consul compares incoming L7 traffic with.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if match is not None:
            pulumi.set(__self__, "match", match)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional['outputs.ConfigEntryServiceRouterRouteDestination']:
        """
        Specifies the target service to route matching requests to, as well as behavior for the request to follow when routed.
        """
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional['outputs.ConfigEntryServiceRouterRouteMatch']:
        """
        Describes a set of criteria that Consul compares incoming L7 traffic with.
        """
        return pulumi.get(self, "match")


@pulumi.output_type
class ConfigEntryServiceRouterRouteDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "idleTimeout":
            suggest = "idle_timeout"
        elif key == "numRetries":
            suggest = "num_retries"
        elif key == "prefixRewrite":
            suggest = "prefix_rewrite"
        elif key == "requestHeaders":
            suggest = "request_headers"
        elif key == "requestTimeout":
            suggest = "request_timeout"
        elif key == "responseHeaders":
            suggest = "response_headers"
        elif key == "retryOnConnectFailure":
            suggest = "retry_on_connect_failure"
        elif key == "retryOnStatusCodes":
            suggest = "retry_on_status_codes"
        elif key == "retryOns":
            suggest = "retry_ons"
        elif key == "serviceSubset":
            suggest = "service_subset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceRouterRouteDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceRouterRouteDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceRouterRouteDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 idle_timeout: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 num_retries: Optional[_builtins.int] = None,
                 partition: Optional[_builtins.str] = None,
                 prefix_rewrite: Optional[_builtins.str] = None,
                 request_headers: Optional['outputs.ConfigEntryServiceRouterRouteDestinationRequestHeaders'] = None,
                 request_timeout: Optional[_builtins.str] = None,
                 response_headers: Optional['outputs.ConfigEntryServiceRouterRouteDestinationResponseHeaders'] = None,
                 retry_on_connect_failure: Optional[_builtins.bool] = None,
                 retry_on_status_codes: Optional[Sequence[_builtins.int]] = None,
                 retry_ons: Optional[Sequence[_builtins.str]] = None,
                 service: Optional[_builtins.str] = None,
                 service_subset: Optional[_builtins.str] = None):
        """
        :param _builtins.str idle_timeout: Specifies the total amount of time permitted for the request stream to be idle.
        :param _builtins.str namespace: Specifies the Consul namespace to resolve the service from instead of the current namespace.
        :param _builtins.int num_retries: Specifies the number of times to retry the request when a retry condition occurs.
        :param _builtins.str partition: Specifies the Consul admin partition to resolve the service from instead of the current partition.
        :param _builtins.str prefix_rewrite: Specifies rewrites to the HTTP request path before proxying it to its final destination.
        :param 'ConfigEntryServiceRouterRouteDestinationRequestHeadersArgs' request_headers: Specifies a set of HTTP-specific header modification rules applied to requests routed with the service router.
        :param _builtins.str request_timeout: Specifies the total amount of time permitted for the entire downstream request to be processed, including retry attempts.
        :param 'ConfigEntryServiceRouterRouteDestinationResponseHeadersArgs' response_headers: Specifies a set of HTTP-specific header modification rules applied to responses routed with the service router.
        :param _builtins.bool retry_on_connect_failure: Specifies that connection failure errors that trigger a retry request.
        :param Sequence[_builtins.int] retry_on_status_codes: Specifies a list of integers for HTTP response status codes that trigger a retry request.
        :param Sequence[_builtins.str] retry_ons: Specifies a list of conditions for Consul to retry requests based on the response from an upstream service.
        :param _builtins.str service: Specifies the name of the service to resolve.
        :param _builtins.str service_subset: Specifies a named subset of the given service to resolve instead of the one defined as that service's `default_subset` in the service resolver configuration entry.
        """
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if num_retries is not None:
            pulumi.set(__self__, "num_retries", num_retries)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if prefix_rewrite is not None:
            pulumi.set(__self__, "prefix_rewrite", prefix_rewrite)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if request_timeout is not None:
            pulumi.set(__self__, "request_timeout", request_timeout)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)
        if retry_on_connect_failure is not None:
            pulumi.set(__self__, "retry_on_connect_failure", retry_on_connect_failure)
        if retry_on_status_codes is not None:
            pulumi.set(__self__, "retry_on_status_codes", retry_on_status_codes)
        if retry_ons is not None:
            pulumi.set(__self__, "retry_ons", retry_ons)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if service_subset is not None:
            pulumi.set(__self__, "service_subset", service_subset)

    @_builtins.property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[_builtins.str]:
        """
        Specifies the total amount of time permitted for the request stream to be idle.
        """
        return pulumi.get(self, "idle_timeout")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Specifies the Consul namespace to resolve the service from instead of the current namespace.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="numRetries")
    def num_retries(self) -> Optional[_builtins.int]:
        """
        Specifies the number of times to retry the request when a retry condition occurs.
        """
        return pulumi.get(self, "num_retries")

    @_builtins.property
    @pulumi.getter
    def partition(self) -> Optional[_builtins.str]:
        """
        Specifies the Consul admin partition to resolve the service from instead of the current partition.
        """
        return pulumi.get(self, "partition")

    @_builtins.property
    @pulumi.getter(name="prefixRewrite")
    def prefix_rewrite(self) -> Optional[_builtins.str]:
        """
        Specifies rewrites to the HTTP request path before proxying it to its final destination.
        """
        return pulumi.get(self, "prefix_rewrite")

    @_builtins.property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional['outputs.ConfigEntryServiceRouterRouteDestinationRequestHeaders']:
        """
        Specifies a set of HTTP-specific header modification rules applied to requests routed with the service router.
        """
        return pulumi.get(self, "request_headers")

    @_builtins.property
    @pulumi.getter(name="requestTimeout")
    def request_timeout(self) -> Optional[_builtins.str]:
        """
        Specifies the total amount of time permitted for the entire downstream request to be processed, including retry attempts.
        """
        return pulumi.get(self, "request_timeout")

    @_builtins.property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional['outputs.ConfigEntryServiceRouterRouteDestinationResponseHeaders']:
        """
        Specifies a set of HTTP-specific header modification rules applied to responses routed with the service router.
        """
        return pulumi.get(self, "response_headers")

    @_builtins.property
    @pulumi.getter(name="retryOnConnectFailure")
    def retry_on_connect_failure(self) -> Optional[_builtins.bool]:
        """
        Specifies that connection failure errors that trigger a retry request.
        """
        return pulumi.get(self, "retry_on_connect_failure")

    @_builtins.property
    @pulumi.getter(name="retryOnStatusCodes")
    def retry_on_status_codes(self) -> Optional[Sequence[_builtins.int]]:
        """
        Specifies a list of integers for HTTP response status codes that trigger a retry request.
        """
        return pulumi.get(self, "retry_on_status_codes")

    @_builtins.property
    @pulumi.getter(name="retryOns")
    def retry_ons(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies a list of conditions for Consul to retry requests based on the response from an upstream service.
        """
        return pulumi.get(self, "retry_ons")

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        Specifies the name of the service to resolve.
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter(name="serviceSubset")
    def service_subset(self) -> Optional[_builtins.str]:
        """
        Specifies a named subset of the given service to resolve instead of the one defined as that service's `default_subset` in the service resolver configuration entry.
        """
        return pulumi.get(self, "service_subset")


@pulumi.output_type
class ConfigEntryServiceRouterRouteDestinationRequestHeaders(dict):
    def __init__(__self__, *,
                 add: Optional[Mapping[str, _builtins.str]] = None,
                 removes: Optional[Sequence[_builtins.str]] = None,
                 set: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] add: Defines a set of key-value pairs to add to the header. Use header names as the keys.
        :param Sequence[_builtins.str] removes: Defines a list of headers to remove.
        :param Mapping[str, _builtins.str] set: Defines a set of key-value pairs to add to the request header or to replace existing header values with.
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if removes is not None:
            pulumi.set(__self__, "removes", removes)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @_builtins.property
    @pulumi.getter
    def add(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Defines a set of key-value pairs to add to the header. Use header names as the keys.
        """
        return pulumi.get(self, "add")

    @_builtins.property
    @pulumi.getter
    def removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Defines a list of headers to remove.
        """
        return pulumi.get(self, "removes")

    @_builtins.property
    @pulumi.getter
    def set(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Defines a set of key-value pairs to add to the request header or to replace existing header values with.
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class ConfigEntryServiceRouterRouteDestinationResponseHeaders(dict):
    def __init__(__self__, *,
                 add: Optional[Mapping[str, _builtins.str]] = None,
                 removes: Optional[Sequence[_builtins.str]] = None,
                 set: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] add: Defines a set of key-value pairs to add to the header. Use header names as the keys
        :param Sequence[_builtins.str] removes: Defines a list of headers to remove.
        :param Mapping[str, _builtins.str] set: Defines a set of key-value pairs to add to the response header or to replace existing header values with
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if removes is not None:
            pulumi.set(__self__, "removes", removes)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @_builtins.property
    @pulumi.getter
    def add(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Defines a set of key-value pairs to add to the header. Use header names as the keys
        """
        return pulumi.get(self, "add")

    @_builtins.property
    @pulumi.getter
    def removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Defines a list of headers to remove.
        """
        return pulumi.get(self, "removes")

    @_builtins.property
    @pulumi.getter
    def set(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Defines a set of key-value pairs to add to the response header or to replace existing header values with
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class ConfigEntryServiceRouterRouteMatch(dict):
    def __init__(__self__, *,
                 http: Optional['outputs.ConfigEntryServiceRouterRouteMatchHttp'] = None):
        """
        :param 'ConfigEntryServiceRouterRouteMatchHttpArgs' http: Specifies a set of HTTP criteria used to evaluate incoming L7 traffic for matches.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)

    @_builtins.property
    @pulumi.getter
    def http(self) -> Optional['outputs.ConfigEntryServiceRouterRouteMatchHttp']:
        """
        Specifies a set of HTTP criteria used to evaluate incoming L7 traffic for matches.
        """
        return pulumi.get(self, "http")


@pulumi.output_type
class ConfigEntryServiceRouterRouteMatchHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pathExact":
            suggest = "path_exact"
        elif key == "pathPrefix":
            suggest = "path_prefix"
        elif key == "pathRegex":
            suggest = "path_regex"
        elif key == "queryParams":
            suggest = "query_params"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceRouterRouteMatchHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceRouterRouteMatchHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceRouterRouteMatchHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 headers: Optional[Sequence['outputs.ConfigEntryServiceRouterRouteMatchHttpHeader']] = None,
                 methods: Optional[Sequence[_builtins.str]] = None,
                 path_exact: Optional[_builtins.str] = None,
                 path_prefix: Optional[_builtins.str] = None,
                 path_regex: Optional[_builtins.str] = None,
                 query_params: Optional[Sequence['outputs.ConfigEntryServiceRouterRouteMatchHttpQueryParam']] = None):
        """
        :param Sequence['ConfigEntryServiceRouterRouteMatchHttpHeaderArgs'] headers: Specifies information in the HTTP request header to match with.
        :param Sequence[_builtins.str] methods: Specifies HTTP methods that the match applies to.
        :param _builtins.str path_exact: Specifies the exact path to match on the HTTP request path.
        :param _builtins.str path_prefix: Specifies the path prefix to match on the HTTP request path.
        :param _builtins.str path_regex: Specifies a regular expression to match on the HTTP request path.
        :param Sequence['ConfigEntryServiceRouterRouteMatchHttpQueryParamArgs'] query_params: Specifies information to match to on HTTP query parameters.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if path_exact is not None:
            pulumi.set(__self__, "path_exact", path_exact)
        if path_prefix is not None:
            pulumi.set(__self__, "path_prefix", path_prefix)
        if path_regex is not None:
            pulumi.set(__self__, "path_regex", path_regex)
        if query_params is not None:
            pulumi.set(__self__, "query_params", query_params)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.ConfigEntryServiceRouterRouteMatchHttpHeader']]:
        """
        Specifies information in the HTTP request header to match with.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies HTTP methods that the match applies to.
        """
        return pulumi.get(self, "methods")

    @_builtins.property
    @pulumi.getter(name="pathExact")
    def path_exact(self) -> Optional[_builtins.str]:
        """
        Specifies the exact path to match on the HTTP request path.
        """
        return pulumi.get(self, "path_exact")

    @_builtins.property
    @pulumi.getter(name="pathPrefix")
    def path_prefix(self) -> Optional[_builtins.str]:
        """
        Specifies the path prefix to match on the HTTP request path.
        """
        return pulumi.get(self, "path_prefix")

    @_builtins.property
    @pulumi.getter(name="pathRegex")
    def path_regex(self) -> Optional[_builtins.str]:
        """
        Specifies a regular expression to match on the HTTP request path.
        """
        return pulumi.get(self, "path_regex")

    @_builtins.property
    @pulumi.getter(name="queryParams")
    def query_params(self) -> Optional[Sequence['outputs.ConfigEntryServiceRouterRouteMatchHttpQueryParam']]:
        """
        Specifies information to match to on HTTP query parameters.
        """
        return pulumi.get(self, "query_params")


@pulumi.output_type
class ConfigEntryServiceRouterRouteMatchHttpHeader(dict):
    def __init__(__self__, *,
                 exact: Optional[_builtins.str] = None,
                 invert: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None,
                 present: Optional[_builtins.bool] = None,
                 regex: Optional[_builtins.str] = None,
                 suffix: Optional[_builtins.str] = None):
        """
        :param _builtins.str exact: Specifies that a request matches when the header with the given name is this exact value.
        :param _builtins.bool invert: Specifies that the logic for the HTTP header match should be inverted.
        :param _builtins.str name: Specifies the name of the HTTP header to match.
        :param _builtins.str prefix: Specifies that a request matches when the header with the given name has this prefix.
        :param _builtins.bool present: Specifies that a request matches when the value in the `name` argument is present anywhere in the HTTP header.
        :param _builtins.str regex: Specifies that a request matches when the header with the given name matches this regular expression.
        :param _builtins.str suffix: Specifies that a request matches when the header with the given name has this suffix.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if invert is not None:
            pulumi.set(__self__, "invert", invert)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if present is not None:
            pulumi.set(__self__, "present", present)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Specifies that a request matches when the header with the given name is this exact value.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    def invert(self) -> Optional[_builtins.bool]:
        """
        Specifies that the logic for the HTTP header match should be inverted.
        """
        return pulumi.get(self, "invert")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the name of the HTTP header to match.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Specifies that a request matches when the header with the given name has this prefix.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def present(self) -> Optional[_builtins.bool]:
        """
        Specifies that a request matches when the value in the `name` argument is present anywhere in the HTTP header.
        """
        return pulumi.get(self, "present")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        Specifies that a request matches when the header with the given name matches this regular expression.
        """
        return pulumi.get(self, "regex")

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[_builtins.str]:
        """
        Specifies that a request matches when the header with the given name has this suffix.
        """
        return pulumi.get(self, "suffix")


@pulumi.output_type
class ConfigEntryServiceRouterRouteMatchHttpQueryParam(dict):
    def __init__(__self__, *,
                 exact: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 present: Optional[_builtins.bool] = None,
                 regex: Optional[_builtins.str] = None):
        """
        :param _builtins.str exact: Specifies that a request matches when the query parameter with the given name is this exact value.
        :param _builtins.str name: Specifies the name of the HTTP query parameter to match.
        :param _builtins.bool present: Specifies that a request matches when the value in the `name` argument is present anywhere in the HTTP query parameter.
        :param _builtins.str regex: Specifies that a request matches when the query parameter with the given name matches this regular expression.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if present is not None:
            pulumi.set(__self__, "present", present)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Specifies that a request matches when the query parameter with the given name is this exact value.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Specifies the name of the HTTP query parameter to match.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def present(self) -> Optional[_builtins.bool]:
        """
        Specifies that a request matches when the value in the `name` argument is present anywhere in the HTTP query parameter.
        """
        return pulumi.get(self, "present")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        Specifies that a request matches when the query parameter with the given name matches this regular expression.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class ConfigEntryServiceSplitterSplit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestHeaders":
            suggest = "request_headers"
        elif key == "responseHeaders":
            suggest = "response_headers"
        elif key == "serviceSubset":
            suggest = "service_subset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConfigEntryServiceSplitterSplit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConfigEntryServiceSplitterSplit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConfigEntryServiceSplitterSplit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service: _builtins.str,
                 weight: _builtins.float,
                 namespace: Optional[_builtins.str] = None,
                 partition: Optional[_builtins.str] = None,
                 request_headers: Optional['outputs.ConfigEntryServiceSplitterSplitRequestHeaders'] = None,
                 response_headers: Optional['outputs.ConfigEntryServiceSplitterSplitResponseHeaders'] = None,
                 service_subset: Optional[_builtins.str] = None):
        """
        :param _builtins.str service: Specifies the name of the service to resolve.
        :param _builtins.float weight: Specifies the percentage of traffic sent to the set of service instances specified in the `service` field. Each weight must be a floating integer between `0` and `100`. The smallest representable value is `.01`. The sum of weights across all splits must add up to `100`.
        :param _builtins.str namespace: Specifies the namespace to use in the FQDN when resolving the service.
        :param _builtins.str partition: Specifies the admin partition to use in the FQDN when resolving the service.
        :param 'ConfigEntryServiceSplitterSplitRequestHeadersArgs' request_headers: Specifies a set of HTTP-specific header modification rules applied to requests routed with the service split. You cannot configure request headers if the listener protocol is set to `tcp`.
        :param 'ConfigEntryServiceSplitterSplitResponseHeadersArgs' response_headers: Specifies a set of HTTP-specific header modification rules applied to responses routed with the service split. You cannot configure request headers if the listener protocol is set to `tcp`.
        :param _builtins.str service_subset: Specifies a subset of the service to resolve. A service subset assigns a name to a specific subset of discoverable service instances within a datacenter, such as `version2` or `canary`. All services have an unnamed default subset that returns all healthy instances.
        """
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "weight", weight)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)
        if service_subset is not None:
            pulumi.set(__self__, "service_subset", service_subset)

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        Specifies the name of the service to resolve.
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.float:
        """
        Specifies the percentage of traffic sent to the set of service instances specified in the `service` field. Each weight must be a floating integer between `0` and `100`. The smallest representable value is `.01`. The sum of weights across all splits must add up to `100`.
        """
        return pulumi.get(self, "weight")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Specifies the namespace to use in the FQDN when resolving the service.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def partition(self) -> Optional[_builtins.str]:
        """
        Specifies the admin partition to use in the FQDN when resolving the service.
        """
        return pulumi.get(self, "partition")

    @_builtins.property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional['outputs.ConfigEntryServiceSplitterSplitRequestHeaders']:
        """
        Specifies a set of HTTP-specific header modification rules applied to requests routed with the service split. You cannot configure request headers if the listener protocol is set to `tcp`.
        """
        return pulumi.get(self, "request_headers")

    @_builtins.property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional['outputs.ConfigEntryServiceSplitterSplitResponseHeaders']:
        """
        Specifies a set of HTTP-specific header modification rules applied to responses routed with the service split. You cannot configure request headers if the listener protocol is set to `tcp`.
        """
        return pulumi.get(self, "response_headers")

    @_builtins.property
    @pulumi.getter(name="serviceSubset")
    def service_subset(self) -> Optional[_builtins.str]:
        """
        Specifies a subset of the service to resolve. A service subset assigns a name to a specific subset of discoverable service instances within a datacenter, such as `version2` or `canary`. All services have an unnamed default subset that returns all healthy instances.
        """
        return pulumi.get(self, "service_subset")


@pulumi.output_type
class ConfigEntryServiceSplitterSplitRequestHeaders(dict):
    def __init__(__self__, *,
                 add: Optional[Mapping[str, _builtins.str]] = None,
                 removes: Optional[Sequence[_builtins.str]] = None,
                 set: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] add: Map of one or more key-value pairs. Defines a set of key-value pairs to add to the header. Use header names as the keys. Header names are not case-sensitive. If header values with the same name already exist, the value is appended and Consul applies both headers.
        :param Sequence[_builtins.str] removes: Defines an list of headers to remove. Consul removes only headers containing exact matches. Header names are not case-sensitive.
        :param Mapping[str, _builtins.str] set: Map of one or more key-value pairs. Defines a set of key-value pairs to add to the request header or to replace existing header values with. Use header names as the keys. Header names are not case-sensitive. If header values with the same names already exist, Consul replaces the header values.
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if removes is not None:
            pulumi.set(__self__, "removes", removes)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @_builtins.property
    @pulumi.getter
    def add(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map of one or more key-value pairs. Defines a set of key-value pairs to add to the header. Use header names as the keys. Header names are not case-sensitive. If header values with the same name already exist, the value is appended and Consul applies both headers.
        """
        return pulumi.get(self, "add")

    @_builtins.property
    @pulumi.getter
    def removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Defines an list of headers to remove. Consul removes only headers containing exact matches. Header names are not case-sensitive.
        """
        return pulumi.get(self, "removes")

    @_builtins.property
    @pulumi.getter
    def set(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map of one or more key-value pairs. Defines a set of key-value pairs to add to the request header or to replace existing header values with. Use header names as the keys. Header names are not case-sensitive. If header values with the same names already exist, Consul replaces the header values.
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class ConfigEntryServiceSplitterSplitResponseHeaders(dict):
    def __init__(__self__, *,
                 add: Optional[Mapping[str, _builtins.str]] = None,
                 removes: Optional[Sequence[_builtins.str]] = None,
                 set: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param Mapping[str, _builtins.str] add: Map of one or more key-value pairs. Defines a set of key-value pairs to add to the header. Use header names as the keys. Header names are not case-sensitive. If header values with the same name already exist, the value is appended and Consul applies both headers.
        :param Sequence[_builtins.str] removes: Defines an list of headers to remove. Consul removes only headers containing exact matches. Header names are not case-sensitive.
        :param Mapping[str, _builtins.str] set: Map of one or more key-value pairs. Defines a set of key-value pairs to add to the request header or to replace existing header values with. Use header names as the keys. Header names are not case-sensitive. If header values with the same names already exist, Consul replaces the header values.
        """
        if add is not None:
            pulumi.set(__self__, "add", add)
        if removes is not None:
            pulumi.set(__self__, "removes", removes)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @_builtins.property
    @pulumi.getter
    def add(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map of one or more key-value pairs. Defines a set of key-value pairs to add to the header. Use header names as the keys. Header names are not case-sensitive. If header values with the same name already exist, the value is appended and Consul applies both headers.
        """
        return pulumi.get(self, "add")

    @_builtins.property
    @pulumi.getter
    def removes(self) -> Optional[Sequence[_builtins.str]]:
        """
        Defines an list of headers to remove. Consul removes only headers containing exact matches. Header names are not case-sensitive.
        """
        return pulumi.get(self, "removes")

    @_builtins.property
    @pulumi.getter
    def set(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Map of one or more key-value pairs. Defines a set of key-value pairs to add to the request header or to replace existing header values with. Use header names as the keys. Header names are not case-sensitive. If header values with the same names already exist, Consul replaces the header values.
        """
        return pulumi.get(self, "set")


@pulumi.output_type
class KeyPrefixSubkeyCollection(dict):
    def __init__(__self__, *,
                 path: _builtins.str,
                 value: _builtins.str,
                 flags: Optional[_builtins.int] = None):
        """
        :param _builtins.str path: This is the path (which will be appended to the given
               `path_prefix`) in Consul that should be written to.
        :param _builtins.str value: The value to write to the given path.
        :param _builtins.int flags: An [unsigned integer value](https://www.consul.io/api/kv.html#flags-1)
               to attach to the key (defaults to 0).
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "value", value)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        This is the path (which will be appended to the given
        `path_prefix`) in Consul that should be written to.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value to write to the given path.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def flags(self) -> Optional[_builtins.int]:
        """
        An [unsigned integer value](https://www.consul.io/api/kv.html#flags-1)
        to attach to the key (defaults to 0).
        """
        return pulumi.get(self, "flags")


@pulumi.output_type
class KeysKey(dict):
    def __init__(__self__, *,
                 path: _builtins.str,
                 default: Optional[_builtins.str] = None,
                 delete: Optional[_builtins.bool] = None,
                 flags: Optional[_builtins.int] = None,
                 name: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str path: This is the path in Consul that should be written to.
        :param _builtins.bool delete: If true, then the key will be deleted when
               either its configuration block is removed from the configuration or
               the entire resource is destroyed. Otherwise, it will be left in Consul.
               Defaults to false.
        :param _builtins.int flags: An [unsigned integer value](https://www.consul.io/api/kv.html#flags-1)
               to attach to the key (defaults to 0).
        :param _builtins.str value: The value to write to the given path.
        """
        pulumi.set(__self__, "path", path)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        This is the path in Consul that should be written to.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[_builtins.bool]:
        """
        If true, then the key will be deleted when
        either its configuration block is removed from the configuration or
        the entire resource is destroyed. Otherwise, it will be left in Consul.
        Defaults to false.
        """
        return pulumi.get(self, "delete")

    @_builtins.property
    @pulumi.getter
    def flags(self) -> Optional[_builtins.int]:
        """
        An [unsigned integer value](https://www.consul.io/api/kv.html#flags-1)
        to attach to the key (defaults to 0).
        """
        return pulumi.get(self, "flags")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Using Keys resource to *read* is deprecated; please use Keys data source instead""")
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value to write to the given path.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PreparedQueryDns(dict):
    def __init__(__self__, *,
                 ttl: Optional[_builtins.str] = None):
        """
        :param _builtins.str ttl: The TTL to send when returning DNS results.
        """
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.str]:
        """
        The TTL to send when returning DNS results.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class PreparedQueryFailover(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nearestN":
            suggest = "nearest_n"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PreparedQueryFailover. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PreparedQueryFailover.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PreparedQueryFailover.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenters: Optional[Sequence[_builtins.str]] = None,
                 nearest_n: Optional[_builtins.int] = None,
                 targets: Optional[Sequence['outputs.PreparedQueryFailoverTarget']] = None):
        """
        :param Sequence[_builtins.str] datacenters: Remote datacenters to return results from.
        :param _builtins.int nearest_n: Return results from this many datacenters, sorted in ascending order of estimated RTT.
        :param Sequence['PreparedQueryFailoverTargetArgs'] targets: Specifies a sequential list of remote datacenters and cluster peers to failover to if there are no healthy service instances in the local datacenter. This option cannot be used with `nearest_n` or `datacenters`.
        """
        if datacenters is not None:
            pulumi.set(__self__, "datacenters", datacenters)
        if nearest_n is not None:
            pulumi.set(__self__, "nearest_n", nearest_n)
        if targets is not None:
            pulumi.set(__self__, "targets", targets)

    @_builtins.property
    @pulumi.getter
    def datacenters(self) -> Optional[Sequence[_builtins.str]]:
        """
        Remote datacenters to return results from.
        """
        return pulumi.get(self, "datacenters")

    @_builtins.property
    @pulumi.getter(name="nearestN")
    def nearest_n(self) -> Optional[_builtins.int]:
        """
        Return results from this many datacenters, sorted in ascending order of estimated RTT.
        """
        return pulumi.get(self, "nearest_n")

    @_builtins.property
    @pulumi.getter
    def targets(self) -> Optional[Sequence['outputs.PreparedQueryFailoverTarget']]:
        """
        Specifies a sequential list of remote datacenters and cluster peers to failover to if there are no healthy service instances in the local datacenter. This option cannot be used with `nearest_n` or `datacenters`.
        """
        return pulumi.get(self, "targets")


@pulumi.output_type
class PreparedQueryFailoverTarget(dict):
    def __init__(__self__, *,
                 datacenter: Optional[_builtins.str] = None,
                 peer: Optional[_builtins.str] = None):
        """
        :param _builtins.str datacenter: Specifies a WAN federated datacenter to forward the query to.
        :param _builtins.str peer: Specifies a cluster peer to use for failover.
        """
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if peer is not None:
            pulumi.set(__self__, "peer", peer)

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> Optional[_builtins.str]:
        """
        Specifies a WAN federated datacenter to forward the query to.
        """
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter
    def peer(self) -> Optional[_builtins.str]:
        """
        Specifies a cluster peer to use for failover.
        """
        return pulumi.get(self, "peer")


@pulumi.output_type
class PreparedQueryTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "removeEmptyTags":
            suggest = "remove_empty_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PreparedQueryTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PreparedQueryTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PreparedQueryTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 regexp: _builtins.str,
                 type: _builtins.str,
                 remove_empty_tags: Optional[_builtins.bool] = None):
        """
        :param _builtins.str regexp: The regular expression to match with. When using `name_prefix_match`, this regex is applied against the query name.
        :param _builtins.str type: The type of template matching to perform. Currently only `name_prefix_match` is supported.
        :param _builtins.bool remove_empty_tags: If set to true, will cause the tags list inside the service structure to be stripped of any empty strings.
        """
        pulumi.set(__self__, "regexp", regexp)
        pulumi.set(__self__, "type", type)
        if remove_empty_tags is not None:
            pulumi.set(__self__, "remove_empty_tags", remove_empty_tags)

    @_builtins.property
    @pulumi.getter
    def regexp(self) -> _builtins.str:
        """
        The regular expression to match with. When using `name_prefix_match`, this regex is applied against the query name.
        """
        return pulumi.get(self, "regexp")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of template matching to perform. Currently only `name_prefix_match` is supported.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="removeEmptyTags")
    def remove_empty_tags(self) -> Optional[_builtins.bool]:
        """
        If set to true, will cause the tags list inside the service structure to be stripped of any empty strings.
        """
        return pulumi.get(self, "remove_empty_tags")


@pulumi.output_type
class ServiceCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkId":
            suggest = "check_id"
        elif key == "deregisterCriticalServiceAfter":
            suggest = "deregister_critical_service_after"
        elif key == "tlsSkipVerify":
            suggest = "tls_skip_verify"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_id: _builtins.str,
                 interval: _builtins.str,
                 name: _builtins.str,
                 timeout: _builtins.str,
                 deregister_critical_service_after: Optional[_builtins.str] = None,
                 headers: Optional[Sequence['outputs.ServiceCheckHeader']] = None,
                 http: Optional[_builtins.str] = None,
                 method: Optional[_builtins.str] = None,
                 notes: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 tcp: Optional[_builtins.str] = None,
                 tls_skip_verify: Optional[_builtins.bool] = None):
        """
        :param _builtins.str check_id: An ID, *unique per agent*.
        :param _builtins.str interval: The interval to wait between each health-check invocation.
        :param _builtins.str name: The name of the health-check.
        :param _builtins.str timeout: Specifies a timeout for outgoing connections in the case of a HTTP or TCP check.
        :param _builtins.str deregister_critical_service_after: The time after which the service is automatically deregistered when in the `critical` state. Defaults to `30s`. Setting to `0` will disable.
        :param Sequence['ServiceCheckHeaderArgs'] headers: The headers to send for an HTTP check. The attributes of each header is given below.
        :param _builtins.str http: The HTTP endpoint to call for an HTTP check.
        :param _builtins.str method: The method to use for HTTP health-checks. Defaults to `GET`.
        :param _builtins.str notes: An opaque field meant to hold human readable text.
        :param _builtins.str status: The initial health-check status.
        :param _builtins.str tcp: The TCP address and port to connect to for a TCP check.
        :param _builtins.bool tls_skip_verify: Whether to deactivate certificate verification for HTTP health-checks. Defaults to `false`.
        """
        pulumi.set(__self__, "check_id", check_id)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "timeout", timeout)
        if deregister_critical_service_after is not None:
            pulumi.set(__self__, "deregister_critical_service_after", deregister_critical_service_after)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if notes is not None:
            pulumi.set(__self__, "notes", notes)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if tls_skip_verify is not None:
            pulumi.set(__self__, "tls_skip_verify", tls_skip_verify)

    @_builtins.property
    @pulumi.getter(name="checkId")
    def check_id(self) -> _builtins.str:
        """
        An ID, *unique per agent*.
        """
        return pulumi.get(self, "check_id")

    @_builtins.property
    @pulumi.getter
    def interval(self) -> _builtins.str:
        """
        The interval to wait between each health-check invocation.
        """
        return pulumi.get(self, "interval")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the health-check.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.str:
        """
        Specifies a timeout for outgoing connections in the case of a HTTP or TCP check.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter(name="deregisterCriticalServiceAfter")
    def deregister_critical_service_after(self) -> Optional[_builtins.str]:
        """
        The time after which the service is automatically deregistered when in the `critical` state. Defaults to `30s`. Setting to `0` will disable.
        """
        return pulumi.get(self, "deregister_critical_service_after")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.ServiceCheckHeader']]:
        """
        The headers to send for an HTTP check. The attributes of each header is given below.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def http(self) -> Optional[_builtins.str]:
        """
        The HTTP endpoint to call for an HTTP check.
        """
        return pulumi.get(self, "http")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        The method to use for HTTP health-checks. Defaults to `GET`.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def notes(self) -> Optional[_builtins.str]:
        """
        An opaque field meant to hold human readable text.
        """
        return pulumi.get(self, "notes")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The initial health-check status.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def tcp(self) -> Optional[_builtins.str]:
        """
        The TCP address and port to connect to for a TCP check.
        """
        return pulumi.get(self, "tcp")

    @_builtins.property
    @pulumi.getter(name="tlsSkipVerify")
    def tls_skip_verify(self) -> Optional[_builtins.bool]:
        """
        Whether to deactivate certificate verification for HTTP health-checks. Defaults to `false`.
        """
        return pulumi.get(self, "tls_skip_verify")


@pulumi.output_type
class ServiceCheckHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 values: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The name of the header.
        :param Sequence[_builtins.str] values: The header's list of values.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the header.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        The header's list of values.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetAclAuthMethodNamespaceRuleResult(dict):
    def __init__(__self__, *,
                 bind_namespace: _builtins.str,
                 selector: _builtins.str):
        pulumi.set(__self__, "bind_namespace", bind_namespace)
        pulumi.set(__self__, "selector", selector)

    @_builtins.property
    @pulumi.getter(name="bindNamespace")
    def bind_namespace(self) -> _builtins.str:
        return pulumi.get(self, "bind_namespace")

    @_builtins.property
    @pulumi.getter
    def selector(self) -> _builtins.str:
        return pulumi.get(self, "selector")


@pulumi.output_type
class GetAclRoleNodeIdentityResult(dict):
    def __init__(__self__, *,
                 datacenter: _builtins.str,
                 node_name: _builtins.str):
        """
        :param _builtins.str datacenter: Specifies the nodes datacenter. This will result in effective policy only being valid in that datacenter.
        :param _builtins.str node_name: The name of the node.
        """
        pulumi.set(__self__, "datacenter", datacenter)
        pulumi.set(__self__, "node_name", node_name)

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> _builtins.str:
        """
        Specifies the nodes datacenter. This will result in effective policy only being valid in that datacenter.
        """
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> _builtins.str:
        """
        The name of the node.
        """
        return pulumi.get(self, "node_name")


@pulumi.output_type
class GetAclRolePolicyResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str id: The ID of the policy.
        :param _builtins.str name: The name of the policy.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the policy.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the policy.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAclRoleServiceIdentityResult(dict):
    def __init__(__self__, *,
                 datacenters: Optional[Sequence[_builtins.str]] = None,
                 service_name: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] datacenters: Specifies the datacenters the effective policy is valid within.
        :param _builtins.str service_name: The name of the service.
        """
        if datacenters is not None:
            pulumi.set(__self__, "datacenters", datacenters)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @_builtins.property
    @pulumi.getter
    def datacenters(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies the datacenters the effective policy is valid within.
        """
        return pulumi.get(self, "datacenters")

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[_builtins.str]:
        """
        The name of the service.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class GetAclRoleTemplatedPolicyResult(dict):
    def __init__(__self__, *,
                 datacenters: Sequence[_builtins.str],
                 template_name: _builtins.str,
                 template_variables: Sequence['outputs.GetAclRoleTemplatedPolicyTemplateVariableResult']):
        """
        :param Sequence[_builtins.str] datacenters: Specifies the datacenters the effective policy is valid within.
        :param _builtins.str template_name: The name of the templated policies.
        :param Sequence['GetAclRoleTemplatedPolicyTemplateVariableArgs'] template_variables: The templated policy variables.
        """
        pulumi.set(__self__, "datacenters", datacenters)
        pulumi.set(__self__, "template_name", template_name)
        pulumi.set(__self__, "template_variables", template_variables)

    @_builtins.property
    @pulumi.getter
    def datacenters(self) -> Sequence[_builtins.str]:
        """
        Specifies the datacenters the effective policy is valid within.
        """
        return pulumi.get(self, "datacenters")

    @_builtins.property
    @pulumi.getter(name="templateName")
    def template_name(self) -> _builtins.str:
        """
        The name of the templated policies.
        """
        return pulumi.get(self, "template_name")

    @_builtins.property
    @pulumi.getter(name="templateVariables")
    def template_variables(self) -> Sequence['outputs.GetAclRoleTemplatedPolicyTemplateVariableResult']:
        """
        The templated policy variables.
        """
        return pulumi.get(self, "template_variables")


@pulumi.output_type
class GetAclRoleTemplatedPolicyTemplateVariableResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: The name of node, workload identity or service.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of node, workload identity or service.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAclTokenNodeIdentityResult(dict):
    def __init__(__self__, *,
                 datacenter: _builtins.str,
                 node_name: _builtins.str):
        """
        :param _builtins.str datacenter: Specifies the node's datacenter.
        :param _builtins.str node_name: The list of node identities that should be applied to the token.
        """
        pulumi.set(__self__, "datacenter", datacenter)
        pulumi.set(__self__, "node_name", node_name)

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> _builtins.str:
        """
        Specifies the node's datacenter.
        """
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> _builtins.str:
        """
        The list of node identities that should be applied to the token.
        """
        return pulumi.get(self, "node_name")


@pulumi.output_type
class GetAclTokenPolicyResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAclTokenRoleResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAclTokenServiceIdentityResult(dict):
    def __init__(__self__, *,
                 datacenters: Sequence[_builtins.str],
                 service_name: _builtins.str):
        """
        :param Sequence[_builtins.str] datacenters: Specifies the datacenters the effective policy is valid within.
        :param _builtins.str service_name: The name of the service.
        """
        pulumi.set(__self__, "datacenters", datacenters)
        pulumi.set(__self__, "service_name", service_name)

    @_builtins.property
    @pulumi.getter
    def datacenters(self) -> Sequence[_builtins.str]:
        """
        Specifies the datacenters the effective policy is valid within.
        """
        return pulumi.get(self, "datacenters")

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> _builtins.str:
        """
        The name of the service.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class GetAclTokenTemplatedPolicyResult(dict):
    def __init__(__self__, *,
                 datacenters: Sequence[_builtins.str],
                 template_name: _builtins.str,
                 template_variables: Sequence['outputs.GetAclTokenTemplatedPolicyTemplateVariableResult']):
        """
        :param Sequence[_builtins.str] datacenters: Specifies the datacenters the effective policy is valid within.
        :param _builtins.str template_name: The name of the templated policies.
        :param Sequence['GetAclTokenTemplatedPolicyTemplateVariableArgs'] template_variables: The templated policy variables.
        """
        pulumi.set(__self__, "datacenters", datacenters)
        pulumi.set(__self__, "template_name", template_name)
        pulumi.set(__self__, "template_variables", template_variables)

    @_builtins.property
    @pulumi.getter
    def datacenters(self) -> Sequence[_builtins.str]:
        """
        Specifies the datacenters the effective policy is valid within.
        """
        return pulumi.get(self, "datacenters")

    @_builtins.property
    @pulumi.getter(name="templateName")
    def template_name(self) -> _builtins.str:
        """
        The name of the templated policies.
        """
        return pulumi.get(self, "template_name")

    @_builtins.property
    @pulumi.getter(name="templateVariables")
    def template_variables(self) -> Sequence['outputs.GetAclTokenTemplatedPolicyTemplateVariableResult']:
        """
        The templated policy variables.
        """
        return pulumi.get(self, "template_variables")


@pulumi.output_type
class GetAclTokenTemplatedPolicyTemplateVariableResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: The name of node, workload identity or service.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of node, workload identity or service.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAutopilotHealthServerResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 healthy: _builtins.bool,
                 id: _builtins.str,
                 last_contact: _builtins.str,
                 last_index: _builtins.int,
                 last_term: _builtins.int,
                 leader: _builtins.bool,
                 name: _builtins.str,
                 serf_status: _builtins.str,
                 stable_since: _builtins.str,
                 version: _builtins.str,
                 voter: _builtins.bool):
        """
        :param _builtins.str address: The address of the server
        :param _builtins.bool healthy: Whether the server is healthy according to the current Autopilot
               configuration
        :param _builtins.str id: The Raft ID of the server
        :param _builtins.str last_contact: The time elapsed since the server's last contact with
               the leader
        :param _builtins.int last_index: The index of the server's last committed Raft log entry
        :param _builtins.int last_term: The server's last known Raft leader term
        :param _builtins.bool leader: Whether the server is currently leader
        :param _builtins.str name: The node name of the server
        :param _builtins.str serf_status: The status of the SerfHealth check of the server
        :param _builtins.str stable_since: The time this server has been in its current ``Healthy``
               state
        :param _builtins.str version: The Consul version of the server
        :param _builtins.bool voter: Whether the server is a voting member of the Raft cluster
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "healthy", healthy)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "last_contact", last_contact)
        pulumi.set(__self__, "last_index", last_index)
        pulumi.set(__self__, "last_term", last_term)
        pulumi.set(__self__, "leader", leader)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "serf_status", serf_status)
        pulumi.set(__self__, "stable_since", stable_since)
        pulumi.set(__self__, "version", version)
        pulumi.set(__self__, "voter", voter)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        The address of the server
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def healthy(self) -> _builtins.bool:
        """
        Whether the server is healthy according to the current Autopilot
        configuration
        """
        return pulumi.get(self, "healthy")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The Raft ID of the server
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="lastContact")
    def last_contact(self) -> _builtins.str:
        """
        The time elapsed since the server's last contact with
        the leader
        """
        return pulumi.get(self, "last_contact")

    @_builtins.property
    @pulumi.getter(name="lastIndex")
    def last_index(self) -> _builtins.int:
        """
        The index of the server's last committed Raft log entry
        """
        return pulumi.get(self, "last_index")

    @_builtins.property
    @pulumi.getter(name="lastTerm")
    def last_term(self) -> _builtins.int:
        """
        The server's last known Raft leader term
        """
        return pulumi.get(self, "last_term")

    @_builtins.property
    @pulumi.getter
    def leader(self) -> _builtins.bool:
        """
        Whether the server is currently leader
        """
        return pulumi.get(self, "leader")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The node name of the server
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="serfStatus")
    def serf_status(self) -> _builtins.str:
        """
        The status of the SerfHealth check of the server
        """
        return pulumi.get(self, "serf_status")

    @_builtins.property
    @pulumi.getter(name="stableSince")
    def stable_since(self) -> _builtins.str:
        """
        The time this server has been in its current ``Healthy``
        state
        """
        return pulumi.get(self, "stable_since")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        The Consul version of the server
        """
        return pulumi.get(self, "version")

    @_builtins.property
    @pulumi.getter
    def voter(self) -> _builtins.bool:
        """
        Whether the server is a voting member of the Raft cluster
        """
        return pulumi.get(self, "voter")


@pulumi.output_type
class GetCatalogNodesNodeResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 id: _builtins.str,
                 meta: Mapping[str, _builtins.str],
                 name: _builtins.str,
                 tagged_addresses: Mapping[str, _builtins.str]):
        """
        :param _builtins.str id: The Node ID of the Consul agent.
               * [`meta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Node meta
               data tag information, if any.
               * [`name`](https://www.consul.io/docs/agent/http/catalog.html#Node) - The name
               of the Consul node.
               * [`address`](https://www.consul.io/docs/agent/http/catalog.html#Address) - The
               IP address the node is advertising to the Consul cluster.
               * [`tagged_addresses`](https://www.consul.io/docs/agent/http/catalog.html#TaggedAddresses) -
               List of explicit LAN and WAN IP addresses for the agent.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tagged_addresses", tagged_addresses)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The Node ID of the Consul agent.
        * [`meta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Node meta
        data tag information, if any.
        * [`name`](https://www.consul.io/docs/agent/http/catalog.html#Node) - The name
        of the Consul node.
        * [`address`](https://www.consul.io/docs/agent/http/catalog.html#Address) - The
        IP address the node is advertising to the Consul cluster.
        * [`tagged_addresses`](https://www.consul.io/docs/agent/http/catalog.html#TaggedAddresses) -
        List of explicit LAN and WAN IP addresses for the agent.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def meta(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "meta")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="taggedAddresses")
    def tagged_addresses(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "tagged_addresses")


@pulumi.output_type
class GetCatalogNodesQueryOptionResult(dict):
    def __init__(__self__, *,
                 allow_stale: Optional[_builtins.bool] = None,
                 datacenter: Optional[_builtins.str] = None,
                 near: Optional[_builtins.str] = None,
                 node_meta: Optional[Mapping[str, _builtins.str]] = None,
                 partition: Optional[_builtins.str] = None,
                 require_consistent: Optional[_builtins.bool] = None,
                 token: Optional[_builtins.str] = None,
                 wait_index: Optional[_builtins.int] = None,
                 wait_time: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_stale: When `true`, the default, allow responses from
               Consul servers that are followers.
        :param _builtins.str datacenter: The Consul datacenter to query.  Defaults to the
               same value found in `query_options` parameter specified below, or if that is
               empty, the `datacenter` value found in the Consul agent that this provider is
               configured to talk to then the datacenter in the provider setup.
        :param _builtins.bool require_consistent: When `true` force the client to perform a
               read on at least quorum servers and verify the result is the same.  Defaults
               to `false`.
        :param _builtins.str token: Specify the Consul ACL token to use when performing the
               request.  This defaults to the same API token configured by the `consul`
               provider but may be overridden if necessary.
        :param _builtins.int wait_index: Index number used to enable blocking queries.
        :param _builtins.str wait_time: Max time the client should wait for a blocking query
               to return.
        """
        if allow_stale is not None:
            pulumi.set(__self__, "allow_stale", allow_stale)
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if near is not None:
            pulumi.set(__self__, "near", near)
        if node_meta is not None:
            pulumi.set(__self__, "node_meta", node_meta)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if require_consistent is not None:
            pulumi.set(__self__, "require_consistent", require_consistent)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if wait_index is not None:
            pulumi.set(__self__, "wait_index", wait_index)
        if wait_time is not None:
            pulumi.set(__self__, "wait_time", wait_time)

    @_builtins.property
    @pulumi.getter(name="allowStale")
    def allow_stale(self) -> Optional[_builtins.bool]:
        """
        When `true`, the default, allow responses from
        Consul servers that are followers.
        """
        return pulumi.get(self, "allow_stale")

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> Optional[_builtins.str]:
        """
        The Consul datacenter to query.  Defaults to the
        same value found in `query_options` parameter specified below, or if that is
        empty, the `datacenter` value found in the Consul agent that this provider is
        configured to talk to then the datacenter in the provider setup.
        """
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter
    def near(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "near")

    @_builtins.property
    @pulumi.getter(name="nodeMeta")
    def node_meta(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "node_meta")

    @_builtins.property
    @pulumi.getter
    def partition(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "partition")

    @_builtins.property
    @pulumi.getter(name="requireConsistent")
    def require_consistent(self) -> Optional[_builtins.bool]:
        """
        When `true` force the client to perform a
        read on at least quorum servers and verify the result is the same.  Defaults
        to `false`.
        """
        return pulumi.get(self, "require_consistent")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        Specify the Consul ACL token to use when performing the
        request.  This defaults to the same API token configured by the `consul`
        provider but may be overridden if necessary.
        """
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="waitIndex")
    def wait_index(self) -> Optional[_builtins.int]:
        """
        Index number used to enable blocking queries.
        """
        return pulumi.get(self, "wait_index")

    @_builtins.property
    @pulumi.getter(name="waitTime")
    def wait_time(self) -> Optional[_builtins.str]:
        """
        Max time the client should wait for a blocking query
        to return.
        """
        return pulumi.get(self, "wait_time")


@pulumi.output_type
class GetCatalogServiceQueryOptionResult(dict):
    def __init__(__self__, *,
                 allow_stale: Optional[_builtins.bool] = None,
                 datacenter: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 near: Optional[_builtins.str] = None,
                 node_meta: Optional[Mapping[str, _builtins.str]] = None,
                 partition: Optional[_builtins.str] = None,
                 require_consistent: Optional[_builtins.bool] = None,
                 token: Optional[_builtins.str] = None,
                 wait_index: Optional[_builtins.int] = None,
                 wait_time: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_stale: When `true`, the default, allow responses from
               Consul servers that are followers.
        :param _builtins.str datacenter: The Consul datacenter to query.  Defaults to the
               same value found in `query_options` parameter specified below, or if that is
               empty, the `datacenter` value found in the Consul agent that this provider is
               configured to talk to.
        :param _builtins.str namespace: The namespace to lookup the service.
        :param _builtins.bool require_consistent: When `true` force the client to perform a
               read on at least quorum servers and verify the result is the same.  Defaults
               to `false`.
        :param _builtins.str token: Specify the Consul ACL token to use when performing the
               request.  This defaults to the same API token configured by the `consul`
               provider but may be overridden if necessary.
        :param _builtins.int wait_index: Index number used to enable blocking queries.
        :param _builtins.str wait_time: Max time the client should wait for a blocking query
               to return.
        """
        if allow_stale is not None:
            pulumi.set(__self__, "allow_stale", allow_stale)
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if near is not None:
            pulumi.set(__self__, "near", near)
        if node_meta is not None:
            pulumi.set(__self__, "node_meta", node_meta)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if require_consistent is not None:
            pulumi.set(__self__, "require_consistent", require_consistent)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if wait_index is not None:
            pulumi.set(__self__, "wait_index", wait_index)
        if wait_time is not None:
            pulumi.set(__self__, "wait_time", wait_time)

    @_builtins.property
    @pulumi.getter(name="allowStale")
    def allow_stale(self) -> Optional[_builtins.bool]:
        """
        When `true`, the default, allow responses from
        Consul servers that are followers.
        """
        return pulumi.get(self, "allow_stale")

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> Optional[_builtins.str]:
        """
        The Consul datacenter to query.  Defaults to the
        same value found in `query_options` parameter specified below, or if that is
        empty, the `datacenter` value found in the Consul agent that this provider is
        configured to talk to.
        """
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to lookup the service.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def near(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "near")

    @_builtins.property
    @pulumi.getter(name="nodeMeta")
    def node_meta(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "node_meta")

    @_builtins.property
    @pulumi.getter
    def partition(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "partition")

    @_builtins.property
    @pulumi.getter(name="requireConsistent")
    def require_consistent(self) -> Optional[_builtins.bool]:
        """
        When `true` force the client to perform a
        read on at least quorum servers and verify the result is the same.  Defaults
        to `false`.
        """
        return pulumi.get(self, "require_consistent")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        Specify the Consul ACL token to use when performing the
        request.  This defaults to the same API token configured by the `consul`
        provider but may be overridden if necessary.
        """
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="waitIndex")
    def wait_index(self) -> Optional[_builtins.int]:
        """
        Index number used to enable blocking queries.
        """
        return pulumi.get(self, "wait_index")

    @_builtins.property
    @pulumi.getter(name="waitTime")
    def wait_time(self) -> Optional[_builtins.str]:
        """
        Max time the client should wait for a blocking query
        to return.
        """
        return pulumi.get(self, "wait_time")


@pulumi.output_type
class GetCatalogServiceServiceResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 create_index: _builtins.str,
                 enable_tag_override: _builtins.str,
                 id: _builtins.str,
                 meta: Mapping[str, _builtins.str],
                 modify_index: _builtins.str,
                 name: _builtins.str,
                 node_address: _builtins.str,
                 node_id: _builtins.str,
                 node_meta: Mapping[str, _builtins.str],
                 node_name: _builtins.str,
                 port: _builtins.str,
                 tagged_addresses: Mapping[str, _builtins.str],
                 tags: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The service name to select.
        :param _builtins.str node_id: The Node ID of the Consul agent advertising the service.
               * [`node_meta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Node
               meta data tag information, if any.
               * [`node_name`](https://www.consul.io/docs/agent/http/catalog.html#Node) - The
               name of the Consul node.
               * [`address`](https://www.consul.io/docs/agent/http/catalog.html#ServiceAddress) -
               The IP address of the service.  If the `ServiceAddress` in the Consul catalog
               is empty, this value is automatically populated with the `node_address` (the
               `Address` in the Consul Catalog).
               * [`enable_tag_override`](https://www.consul.io/docs/agent/http/catalog.html#ServiceEnableTagOverride) -
               Whether service tags can be overridden on this service.
               * [`id`](https://www.consul.io/docs/agent/http/catalog.html#ServiceID) - A
               unique service instance identifier.
               * [`name`](https://www.consul.io/docs/agent/http/catalog.html#ServiceName) - The
               name of the service.
               * [`port`](https://www.consul.io/docs/agent/http/catalog.html#ServicePort) -
               Port number of the service.
               * [`tagged_addresses`](https://www.consul.io/docs/agent/http/catalog.html#TaggedAddresses) -
               List of explicit LAN and WAN IP addresses for the agent.
               * [`tags`](https://www.consul.io/docs/agent/http/catalog.html#ServiceTags) -
               List of tags for the service.
               * [`meta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Service meta
               data tag information, if any.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "create_index", create_index)
        pulumi.set(__self__, "enable_tag_override", enable_tag_override)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "modify_index", modify_index)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_address", node_address)
        pulumi.set(__self__, "node_id", node_id)
        pulumi.set(__self__, "node_meta", node_meta)
        pulumi.set(__self__, "node_name", node_name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "tagged_addresses", tagged_addresses)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="createIndex")
    def create_index(self) -> _builtins.str:
        return pulumi.get(self, "create_index")

    @_builtins.property
    @pulumi.getter(name="enableTagOverride")
    def enable_tag_override(self) -> _builtins.str:
        return pulumi.get(self, "enable_tag_override")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def meta(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "meta")

    @_builtins.property
    @pulumi.getter(name="modifyIndex")
    def modify_index(self) -> _builtins.str:
        return pulumi.get(self, "modify_index")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The service name to select.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeAddress")
    def node_address(self) -> _builtins.str:
        return pulumi.get(self, "node_address")

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> _builtins.str:
        """
        The Node ID of the Consul agent advertising the service.
        * [`node_meta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Node
        meta data tag information, if any.
        * [`node_name`](https://www.consul.io/docs/agent/http/catalog.html#Node) - The
        name of the Consul node.
        * [`address`](https://www.consul.io/docs/agent/http/catalog.html#ServiceAddress) -
        The IP address of the service.  If the `ServiceAddress` in the Consul catalog
        is empty, this value is automatically populated with the `node_address` (the
        `Address` in the Consul Catalog).
        * [`enable_tag_override`](https://www.consul.io/docs/agent/http/catalog.html#ServiceEnableTagOverride) -
        Whether service tags can be overridden on this service.
        * [`id`](https://www.consul.io/docs/agent/http/catalog.html#ServiceID) - A
        unique service instance identifier.
        * [`name`](https://www.consul.io/docs/agent/http/catalog.html#ServiceName) - The
        name of the service.
        * [`port`](https://www.consul.io/docs/agent/http/catalog.html#ServicePort) -
        Port number of the service.
        * [`tagged_addresses`](https://www.consul.io/docs/agent/http/catalog.html#TaggedAddresses) -
        List of explicit LAN and WAN IP addresses for the agent.
        * [`tags`](https://www.consul.io/docs/agent/http/catalog.html#ServiceTags) -
        List of tags for the service.
        * [`meta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Service meta
        data tag information, if any.
        """
        return pulumi.get(self, "node_id")

    @_builtins.property
    @pulumi.getter(name="nodeMeta")
    def node_meta(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "node_meta")

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> _builtins.str:
        return pulumi.get(self, "node_name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="taggedAddresses")
    def tagged_addresses(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "tagged_addresses")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetCatalogServicesQueryOptionResult(dict):
    def __init__(__self__, *,
                 allow_stale: Optional[_builtins.bool] = None,
                 datacenter: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 near: Optional[_builtins.str] = None,
                 node_meta: Optional[Mapping[str, _builtins.str]] = None,
                 partition: Optional[_builtins.str] = None,
                 require_consistent: Optional[_builtins.bool] = None,
                 token: Optional[_builtins.str] = None,
                 wait_index: Optional[_builtins.int] = None,
                 wait_time: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_stale: When `true`, the default, allow responses from
               Consul servers that are followers.
        :param _builtins.str datacenter: The Consul datacenter to query.  Defaults to the
               same value found in `query_options` parameter specified below, or if that is
               empty, the `datacenter` value found in the Consul agent that this provider is
               configured to talk to.
        :param _builtins.str namespace: The namespace to lookup the services.
        :param _builtins.bool require_consistent: When `true` force the client to perform a
               read on at least quorum servers and verify the result is the same.  Defaults
               to `false`.
        :param _builtins.str token: Specify the Consul ACL token to use when performing the
               request.  This defaults to the same API token configured by the `consul`
               provider but may be overridden if necessary.
        :param _builtins.int wait_index: Index number used to enable blocking queries.
        :param _builtins.str wait_time: Max time the client should wait for a blocking query
               to return.
        """
        if allow_stale is not None:
            pulumi.set(__self__, "allow_stale", allow_stale)
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if near is not None:
            pulumi.set(__self__, "near", near)
        if node_meta is not None:
            pulumi.set(__self__, "node_meta", node_meta)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if require_consistent is not None:
            pulumi.set(__self__, "require_consistent", require_consistent)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if wait_index is not None:
            pulumi.set(__self__, "wait_index", wait_index)
        if wait_time is not None:
            pulumi.set(__self__, "wait_time", wait_time)

    @_builtins.property
    @pulumi.getter(name="allowStale")
    def allow_stale(self) -> Optional[_builtins.bool]:
        """
        When `true`, the default, allow responses from
        Consul servers that are followers.
        """
        return pulumi.get(self, "allow_stale")

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> Optional[_builtins.str]:
        """
        The Consul datacenter to query.  Defaults to the
        same value found in `query_options` parameter specified below, or if that is
        empty, the `datacenter` value found in the Consul agent that this provider is
        configured to talk to.
        """
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to lookup the services.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def near(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "near")

    @_builtins.property
    @pulumi.getter(name="nodeMeta")
    def node_meta(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "node_meta")

    @_builtins.property
    @pulumi.getter
    def partition(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "partition")

    @_builtins.property
    @pulumi.getter(name="requireConsistent")
    def require_consistent(self) -> Optional[_builtins.bool]:
        """
        When `true` force the client to perform a
        read on at least quorum servers and verify the result is the same.  Defaults
        to `false`.
        """
        return pulumi.get(self, "require_consistent")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        Specify the Consul ACL token to use when performing the
        request.  This defaults to the same API token configured by the `consul`
        provider but may be overridden if necessary.
        """
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="waitIndex")
    def wait_index(self) -> Optional[_builtins.int]:
        """
        Index number used to enable blocking queries.
        """
        return pulumi.get(self, "wait_index")

    @_builtins.property
    @pulumi.getter(name="waitTime")
    def wait_time(self) -> Optional[_builtins.str]:
        """
        Max time the client should wait for a blocking query
        to return.
        """
        return pulumi.get(self, "wait_time")


@pulumi.output_type
class GetKeyPrefixSubkeyCollectionResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 path: _builtins.str,
                 default: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: This is the name of the key. This value of the
               key is exposed as `var.<name>`. This is not the path of the subkey
               in Consul.
        :param _builtins.str path: This is the subkey path in Consul (which will be appended
               to the given `path_prefix`) to construct the full key that will be used
               to read the value.
        :param _builtins.str default: This is the default value to set for `var.<name>`
               if the key does not exist in Consul. Defaults to an empty string.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        This is the name of the key. This value of the
        key is exposed as `var.<name>`. This is not the path of the subkey
        in Consul.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        This is the subkey path in Consul (which will be appended
        to the given `path_prefix`) to construct the full key that will be used
        to read the value.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        """
        This is the default value to set for `var.<name>`
        if the key does not exist in Consul. Defaults to an empty string.
        """
        return pulumi.get(self, "default")


@pulumi.output_type
class GetKeysKeyResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 path: _builtins.str,
                 default: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: This is the name of the key. This value of the key is exposed as `var.<name>`. This is not the path of the key in Consul.
        :param _builtins.str path: This is the path in Consul that should be read or written to.
        :param _builtins.str default: This is the default value to set for `var.<name>` if the key does not exist in Consul. Defaults to an empty string.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        if default is not None:
            pulumi.set(__self__, "default", default)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        This is the name of the key. This value of the key is exposed as `var.<name>`. This is not the path of the key in Consul.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        This is the path in Consul that should be read or written to.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        """
        This is the default value to set for `var.<name>` if the key does not exist in Consul. Defaults to an empty string.
        """
        return pulumi.get(self, "default")


@pulumi.output_type
class GetNetworkAreaMembersMemberResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 build: _builtins.str,
                 datacenter: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 protocol: _builtins.int,
                 role: _builtins.str,
                 rtt: _builtins.int,
                 status: _builtins.str):
        """
        :param _builtins.str address: The IP address of the server.
        :param _builtins.str build: The Consul version running on the node.
        :param _builtins.str datacenter: The datacenter to use. This overrides the
               agent's default datacenter and the datacenter in the provider setup.
        :param _builtins.str id: The node ID of the server.
        :param _builtins.str name: The node name of the server, with its datacenter appended.
        :param _builtins.int port: The server RPC port the node.
        :param _builtins.int protocol: The protocol version being spoken by the node.
        :param _builtins.str role: Role is always `"server"` since only Consul servers can participate
               in network areas.
        :param _builtins.int rtt: An estimated network round trip time from the server answering the
               query to the given server, in nanoseconds. This is computed using network
               coordinates.
        :param _builtins.str status: The current health status of the node, as determined by the
               network area distributed failure detector. This will be `"alive"`, `"leaving"`,
               or `"failed"`. A `"failed"` status means that other servers are not able to
               probe this server over its server RPC interface.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "build", build)
        pulumi.set(__self__, "datacenter", datacenter)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "rtt", rtt)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        The IP address of the server.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def build(self) -> _builtins.str:
        """
        The Consul version running on the node.
        """
        return pulumi.get(self, "build")

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> _builtins.str:
        """
        The datacenter to use. This overrides the
        agent's default datacenter and the datacenter in the provider setup.
        """
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The node ID of the server.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The node name of the server, with its datacenter appended.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The server RPC port the node.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.int:
        """
        The protocol version being spoken by the node.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        Role is always `"server"` since only Consul servers can participate
        in network areas.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def rtt(self) -> _builtins.int:
        """
        An estimated network round trip time from the server answering the
        query to the given server, in nanoseconds. This is computed using network
        coordinates.
        """
        return pulumi.get(self, "rtt")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The current health status of the node, as determined by the
        network area distributed failure detector. This will be `"alive"`, `"leaving"`,
        or `"failed"`. A `"failed"` status means that other servers are not able to
        probe this server over its server RPC interface.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetNodesNodeResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 id: _builtins.str,
                 meta: Mapping[str, _builtins.str],
                 name: _builtins.str,
                 tagged_addresses: Mapping[str, _builtins.str]):
        """
        :param _builtins.str id: The Node ID of the Consul agent.
               * [`meta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Node meta
               data tag information, if any.
               * [`name`](https://www.consul.io/docs/agent/http/catalog.html#Node) - The name
               of the Consul node.
               * [`address`](https://www.consul.io/docs/agent/http/catalog.html#Address) - The
               IP address the node is advertising to the Consul cluster.
               * [`tagged_addresses`](https://www.consul.io/docs/agent/http/catalog.html#TaggedAddresses) -
               List of explicit LAN and WAN IP addresses for the agent.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tagged_addresses", tagged_addresses)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The Node ID of the Consul agent.
        * [`meta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Node meta
        data tag information, if any.
        * [`name`](https://www.consul.io/docs/agent/http/catalog.html#Node) - The name
        of the Consul node.
        * [`address`](https://www.consul.io/docs/agent/http/catalog.html#Address) - The
        IP address the node is advertising to the Consul cluster.
        * [`tagged_addresses`](https://www.consul.io/docs/agent/http/catalog.html#TaggedAddresses) -
        List of explicit LAN and WAN IP addresses for the agent.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def meta(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "meta")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="taggedAddresses")
    def tagged_addresses(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "tagged_addresses")


@pulumi.output_type
class GetNodesQueryOptionResult(dict):
    def __init__(__self__, *,
                 allow_stale: Optional[_builtins.bool] = None,
                 datacenter: Optional[_builtins.str] = None,
                 near: Optional[_builtins.str] = None,
                 node_meta: Optional[Mapping[str, _builtins.str]] = None,
                 partition: Optional[_builtins.str] = None,
                 require_consistent: Optional[_builtins.bool] = None,
                 token: Optional[_builtins.str] = None,
                 wait_index: Optional[_builtins.int] = None,
                 wait_time: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_stale: When `true`, the default, allow responses from
               Consul servers that are followers.
        :param _builtins.str datacenter: The Consul datacenter to query.  Defaults to the
               same value found in `query_options` parameter specified below, or if that is
               empty, the `datacenter` value found in the Consul agent that this provider is
               configured to talk to then the datacenter in the provider setup.
        :param _builtins.bool require_consistent: When `true` force the client to perform a
               read on at least quorum servers and verify the result is the same.  Defaults
               to `false`.
        :param _builtins.str token: Specify the Consul ACL token to use when performing the
               request.  This defaults to the same API token configured by the `consul`
               provider but may be overridden if necessary.
        :param _builtins.int wait_index: Index number used to enable blocking queries.
        :param _builtins.str wait_time: Max time the client should wait for a blocking query
               to return.
        """
        if allow_stale is not None:
            pulumi.set(__self__, "allow_stale", allow_stale)
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if near is not None:
            pulumi.set(__self__, "near", near)
        if node_meta is not None:
            pulumi.set(__self__, "node_meta", node_meta)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if require_consistent is not None:
            pulumi.set(__self__, "require_consistent", require_consistent)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if wait_index is not None:
            pulumi.set(__self__, "wait_index", wait_index)
        if wait_time is not None:
            pulumi.set(__self__, "wait_time", wait_time)

    @_builtins.property
    @pulumi.getter(name="allowStale")
    def allow_stale(self) -> Optional[_builtins.bool]:
        """
        When `true`, the default, allow responses from
        Consul servers that are followers.
        """
        return pulumi.get(self, "allow_stale")

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> Optional[_builtins.str]:
        """
        The Consul datacenter to query.  Defaults to the
        same value found in `query_options` parameter specified below, or if that is
        empty, the `datacenter` value found in the Consul agent that this provider is
        configured to talk to then the datacenter in the provider setup.
        """
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter
    def near(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "near")

    @_builtins.property
    @pulumi.getter(name="nodeMeta")
    def node_meta(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "node_meta")

    @_builtins.property
    @pulumi.getter
    def partition(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "partition")

    @_builtins.property
    @pulumi.getter(name="requireConsistent")
    def require_consistent(self) -> Optional[_builtins.bool]:
        """
        When `true` force the client to perform a
        read on at least quorum servers and verify the result is the same.  Defaults
        to `false`.
        """
        return pulumi.get(self, "require_consistent")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        Specify the Consul ACL token to use when performing the
        request.  This defaults to the same API token configured by the `consul`
        provider but may be overridden if necessary.
        """
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="waitIndex")
    def wait_index(self) -> Optional[_builtins.int]:
        """
        Index number used to enable blocking queries.
        """
        return pulumi.get(self, "wait_index")

    @_builtins.property
    @pulumi.getter(name="waitTime")
    def wait_time(self) -> Optional[_builtins.str]:
        """
        Max time the client should wait for a blocking query
        to return.
        """
        return pulumi.get(self, "wait_time")


@pulumi.output_type
class GetPeeringsPeerResult(dict):
    def __init__(__self__, *,
                 deleted_at: _builtins.str,
                 id: _builtins.str,
                 meta: Mapping[str, _builtins.str],
                 name: _builtins.str,
                 partition: _builtins.str,
                 peer_ca_pems: Sequence[_builtins.str],
                 peer_id: _builtins.str,
                 peer_server_addresses: Sequence[_builtins.str],
                 peer_server_name: _builtins.str,
                 state: _builtins.str):
        pulumi.set(__self__, "deleted_at", deleted_at)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "partition", partition)
        pulumi.set(__self__, "peer_ca_pems", peer_ca_pems)
        pulumi.set(__self__, "peer_id", peer_id)
        pulumi.set(__self__, "peer_server_addresses", peer_server_addresses)
        pulumi.set(__self__, "peer_server_name", peer_server_name)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def meta(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "meta")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def partition(self) -> _builtins.str:
        return pulumi.get(self, "partition")

    @_builtins.property
    @pulumi.getter(name="peerCaPems")
    def peer_ca_pems(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "peer_ca_pems")

    @_builtins.property
    @pulumi.getter(name="peerId")
    def peer_id(self) -> _builtins.str:
        return pulumi.get(self, "peer_id")

    @_builtins.property
    @pulumi.getter(name="peerServerAddresses")
    def peer_server_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "peer_server_addresses")

    @_builtins.property
    @pulumi.getter(name="peerServerName")
    def peer_server_name(self) -> _builtins.str:
        return pulumi.get(self, "peer_server_name")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetServiceHealthResultResult(dict):
    def __init__(__self__, *,
                 checks: Sequence['outputs.GetServiceHealthResultCheckResult'],
                 nodes: Sequence['outputs.GetServiceHealthResultNodeResult'],
                 services: Sequence['outputs.GetServiceHealthResultServiceResult']):
        """
        :param Sequence['GetServiceHealthResultNodeArgs'] nodes: The name of the node associated with this health-check.
        """
        pulumi.set(__self__, "checks", checks)
        pulumi.set(__self__, "nodes", nodes)
        pulumi.set(__self__, "services", services)

    @_builtins.property
    @pulumi.getter
    def checks(self) -> Sequence['outputs.GetServiceHealthResultCheckResult']:
        return pulumi.get(self, "checks")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.GetServiceHealthResultNodeResult']:
        """
        The name of the node associated with this health-check.
        """
        return pulumi.get(self, "nodes")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Sequence['outputs.GetServiceHealthResultServiceResult']:
        return pulumi.get(self, "services")


@pulumi.output_type
class GetServiceHealthResultCheckResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 node: _builtins.str,
                 notes: _builtins.str,
                 output: _builtins.str,
                 service_id: _builtins.str,
                 service_name: _builtins.str,
                 service_tags: Sequence[_builtins.str],
                 status: _builtins.str):
        """
        :param _builtins.str id: The ID of this health-check.
        :param _builtins.str name: The service name to select.
        :param _builtins.str node: The name of the node associated with this health-check.
        :param _builtins.str notes: A human readable description of the current state of the health-check.
        :param _builtins.str output: The output of the health-check.
        :param _builtins.str service_id: The ID of the service associated to this health-check.
        :param _builtins.str service_name: The name of the service associated with this health-check.
        :param Sequence[_builtins.str] service_tags: The list of tags associated with this health-check.
        :param _builtins.str status: The status of this health-check.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node", node)
        pulumi.set(__self__, "notes", notes)
        pulumi.set(__self__, "output", output)
        pulumi.set(__self__, "service_id", service_id)
        pulumi.set(__self__, "service_name", service_name)
        pulumi.set(__self__, "service_tags", service_tags)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of this health-check.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The service name to select.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def node(self) -> _builtins.str:
        """
        The name of the node associated with this health-check.
        """
        return pulumi.get(self, "node")

    @_builtins.property
    @pulumi.getter
    def notes(self) -> _builtins.str:
        """
        A human readable description of the current state of the health-check.
        """
        return pulumi.get(self, "notes")

    @_builtins.property
    @pulumi.getter
    def output(self) -> _builtins.str:
        """
        The output of the health-check.
        """
        return pulumi.get(self, "output")

    @_builtins.property
    @pulumi.getter(name="serviceId")
    def service_id(self) -> _builtins.str:
        """
        The ID of the service associated to this health-check.
        """
        return pulumi.get(self, "service_id")

    @_builtins.property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> _builtins.str:
        """
        The name of the service associated with this health-check.
        """
        return pulumi.get(self, "service_name")

    @_builtins.property
    @pulumi.getter(name="serviceTags")
    def service_tags(self) -> Sequence[_builtins.str]:
        """
        The list of tags associated with this health-check.
        """
        return pulumi.get(self, "service_tags")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of this health-check.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetServiceHealthResultNodeResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 datacenter: _builtins.str,
                 id: _builtins.str,
                 meta: Mapping[str, _builtins.str],
                 name: _builtins.str,
                 tagged_addresses: Mapping[str, _builtins.str]):
        """
        :param _builtins.str address: The address of this instance.
        :param _builtins.str datacenter: The Consul datacenter to query.
        :param _builtins.str id: The ID of this health-check.
        :param Mapping[str, _builtins.str] meta: Service metadata tag information, if any.
        :param _builtins.str name: The service name to select.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "datacenter", datacenter)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tagged_addresses", tagged_addresses)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        The address of this instance.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> _builtins.str:
        """
        The Consul datacenter to query.
        """
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of this health-check.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def meta(self) -> Mapping[str, _builtins.str]:
        """
        Service metadata tag information, if any.
        """
        return pulumi.get(self, "meta")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The service name to select.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="taggedAddresses")
    def tagged_addresses(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "tagged_addresses")


@pulumi.output_type
class GetServiceHealthResultServiceResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 id: _builtins.str,
                 meta: Mapping[str, _builtins.str],
                 name: _builtins.str,
                 port: _builtins.int,
                 tags: Sequence[_builtins.str]):
        """
        :param _builtins.str address: The address of this instance.
        :param _builtins.str id: The ID of this health-check.
        :param Mapping[str, _builtins.str] meta: Service metadata tag information, if any.
        :param _builtins.str name: The service name to select.
        :param _builtins.int port: The port of this instance.
        :param Sequence[_builtins.str] tags: The list of tags associated with this instance.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        """
        The address of this instance.
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of this health-check.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def meta(self) -> Mapping[str, _builtins.str]:
        """
        Service metadata tag information, if any.
        """
        return pulumi.get(self, "meta")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The service name to select.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port of this instance.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        The list of tags associated with this instance.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetServiceQueryOptionResult(dict):
    def __init__(__self__, *,
                 allow_stale: Optional[_builtins.bool] = None,
                 datacenter: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 near: Optional[_builtins.str] = None,
                 node_meta: Optional[Mapping[str, _builtins.str]] = None,
                 partition: Optional[_builtins.str] = None,
                 require_consistent: Optional[_builtins.bool] = None,
                 token: Optional[_builtins.str] = None,
                 wait_index: Optional[_builtins.int] = None,
                 wait_time: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_stale: When `true`, the default, allow responses from
               Consul servers that are followers.
        :param _builtins.str datacenter: The Consul datacenter to query.  Defaults to the
               same value found in `query_options` parameter specified below, or if that is
               empty, the `datacenter` value found in the Consul agent that this provider is
               configured to talk to.
        :param _builtins.str namespace: The namespace to lookup the service.
        :param _builtins.bool require_consistent: When `true` force the client to perform a
               read on at least quorum servers and verify the result is the same.  Defaults
               to `false`.
        :param _builtins.str token: Specify the Consul ACL token to use when performing the
               request.  This defaults to the same API token configured by the `consul`
               provider but may be overridden if necessary.
        :param _builtins.int wait_index: Index number used to enable blocking queries.
        :param _builtins.str wait_time: Max time the client should wait for a blocking query
               to return.
        """
        if allow_stale is not None:
            pulumi.set(__self__, "allow_stale", allow_stale)
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if near is not None:
            pulumi.set(__self__, "near", near)
        if node_meta is not None:
            pulumi.set(__self__, "node_meta", node_meta)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if require_consistent is not None:
            pulumi.set(__self__, "require_consistent", require_consistent)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if wait_index is not None:
            pulumi.set(__self__, "wait_index", wait_index)
        if wait_time is not None:
            pulumi.set(__self__, "wait_time", wait_time)

    @_builtins.property
    @pulumi.getter(name="allowStale")
    def allow_stale(self) -> Optional[_builtins.bool]:
        """
        When `true`, the default, allow responses from
        Consul servers that are followers.
        """
        return pulumi.get(self, "allow_stale")

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> Optional[_builtins.str]:
        """
        The Consul datacenter to query.  Defaults to the
        same value found in `query_options` parameter specified below, or if that is
        empty, the `datacenter` value found in the Consul agent that this provider is
        configured to talk to.
        """
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to lookup the service.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def near(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "near")

    @_builtins.property
    @pulumi.getter(name="nodeMeta")
    def node_meta(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "node_meta")

    @_builtins.property
    @pulumi.getter
    def partition(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "partition")

    @_builtins.property
    @pulumi.getter(name="requireConsistent")
    def require_consistent(self) -> Optional[_builtins.bool]:
        """
        When `true` force the client to perform a
        read on at least quorum servers and verify the result is the same.  Defaults
        to `false`.
        """
        return pulumi.get(self, "require_consistent")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        Specify the Consul ACL token to use when performing the
        request.  This defaults to the same API token configured by the `consul`
        provider but may be overridden if necessary.
        """
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="waitIndex")
    def wait_index(self) -> Optional[_builtins.int]:
        """
        Index number used to enable blocking queries.
        """
        return pulumi.get(self, "wait_index")

    @_builtins.property
    @pulumi.getter(name="waitTime")
    def wait_time(self) -> Optional[_builtins.str]:
        """
        Max time the client should wait for a blocking query
        to return.
        """
        return pulumi.get(self, "wait_time")


@pulumi.output_type
class GetServiceServiceResult(dict):
    def __init__(__self__, *,
                 address: _builtins.str,
                 create_index: _builtins.str,
                 enable_tag_override: _builtins.str,
                 id: _builtins.str,
                 meta: Mapping[str, _builtins.str],
                 modify_index: _builtins.str,
                 name: _builtins.str,
                 node_address: _builtins.str,
                 node_id: _builtins.str,
                 node_meta: Mapping[str, _builtins.str],
                 node_name: _builtins.str,
                 port: _builtins.str,
                 tagged_addresses: Mapping[str, _builtins.str],
                 tags: Sequence[_builtins.str]):
        """
        :param _builtins.str name: The service name to select.
        :param _builtins.str node_id: The Node ID of the Consul agent advertising the service.
               * [`node_meta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Node
               meta data tag information, if any.
               * [`node_name`](https://www.consul.io/docs/agent/http/catalog.html#Node) - The
               name of the Consul node.
               * [`address`](https://www.consul.io/docs/agent/http/catalog.html#ServiceAddress) -
               The IP address of the service.  If the `ServiceAddress` in the Consul catalog
               is empty, this value is automatically populated with the `node_address` (the
               `Address` in the Consul Catalog).
               * [`enable_tag_override`](https://www.consul.io/docs/agent/http/catalog.html#ServiceEnableTagOverride) -
               Whether service tags can be overridden on this service.
               * [`id`](https://www.consul.io/docs/agent/http/catalog.html#ServiceID) - A
               unique service instance identifier.
               * [`name`](https://www.consul.io/docs/agent/http/catalog.html#ServiceName) - The
               name of the service.
               * [`port`](https://www.consul.io/docs/agent/http/catalog.html#ServicePort) -
               Port number of the service.
               * [`tagged_addresses`](https://www.consul.io/docs/agent/http/catalog.html#TaggedAddresses) -
               List of explicit LAN and WAN IP addresses for the agent.
               * [`tags`](https://www.consul.io/docs/agent/http/catalog.html#ServiceTags) -
               List of tags for the service.
               * [`meta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Service meta
               data tag information, if any.
        """
        pulumi.set(__self__, "address", address)
        pulumi.set(__self__, "create_index", create_index)
        pulumi.set(__self__, "enable_tag_override", enable_tag_override)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "modify_index", modify_index)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_address", node_address)
        pulumi.set(__self__, "node_id", node_id)
        pulumi.set(__self__, "node_meta", node_meta)
        pulumi.set(__self__, "node_name", node_name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "tagged_addresses", tagged_addresses)
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def address(self) -> _builtins.str:
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="createIndex")
    def create_index(self) -> _builtins.str:
        return pulumi.get(self, "create_index")

    @_builtins.property
    @pulumi.getter(name="enableTagOverride")
    def enable_tag_override(self) -> _builtins.str:
        return pulumi.get(self, "enable_tag_override")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def meta(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "meta")

    @_builtins.property
    @pulumi.getter(name="modifyIndex")
    def modify_index(self) -> _builtins.str:
        return pulumi.get(self, "modify_index")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The service name to select.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeAddress")
    def node_address(self) -> _builtins.str:
        return pulumi.get(self, "node_address")

    @_builtins.property
    @pulumi.getter(name="nodeId")
    def node_id(self) -> _builtins.str:
        """
        The Node ID of the Consul agent advertising the service.
        * [`node_meta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Node
        meta data tag information, if any.
        * [`node_name`](https://www.consul.io/docs/agent/http/catalog.html#Node) - The
        name of the Consul node.
        * [`address`](https://www.consul.io/docs/agent/http/catalog.html#ServiceAddress) -
        The IP address of the service.  If the `ServiceAddress` in the Consul catalog
        is empty, this value is automatically populated with the `node_address` (the
        `Address` in the Consul Catalog).
        * [`enable_tag_override`](https://www.consul.io/docs/agent/http/catalog.html#ServiceEnableTagOverride) -
        Whether service tags can be overridden on this service.
        * [`id`](https://www.consul.io/docs/agent/http/catalog.html#ServiceID) - A
        unique service instance identifier.
        * [`name`](https://www.consul.io/docs/agent/http/catalog.html#ServiceName) - The
        name of the service.
        * [`port`](https://www.consul.io/docs/agent/http/catalog.html#ServicePort) -
        Port number of the service.
        * [`tagged_addresses`](https://www.consul.io/docs/agent/http/catalog.html#TaggedAddresses) -
        List of explicit LAN and WAN IP addresses for the agent.
        * [`tags`](https://www.consul.io/docs/agent/http/catalog.html#ServiceTags) -
        List of tags for the service.
        * [`meta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Service meta
        data tag information, if any.
        """
        return pulumi.get(self, "node_id")

    @_builtins.property
    @pulumi.getter(name="nodeMeta")
    def node_meta(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "node_meta")

    @_builtins.property
    @pulumi.getter(name="nodeName")
    def node_name(self) -> _builtins.str:
        return pulumi.get(self, "node_name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.str:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="taggedAddresses")
    def tagged_addresses(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "tagged_addresses")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetServicesQueryOptionResult(dict):
    def __init__(__self__, *,
                 allow_stale: Optional[_builtins.bool] = None,
                 datacenter: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 near: Optional[_builtins.str] = None,
                 node_meta: Optional[Mapping[str, _builtins.str]] = None,
                 partition: Optional[_builtins.str] = None,
                 require_consistent: Optional[_builtins.bool] = None,
                 token: Optional[_builtins.str] = None,
                 wait_index: Optional[_builtins.int] = None,
                 wait_time: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_stale: When `true`, the default, allow responses from
               Consul servers that are followers.
        :param _builtins.str datacenter: The Consul datacenter to query.  Defaults to the
               same value found in `query_options` parameter specified below, or if that is
               empty, the `datacenter` value found in the Consul agent that this provider is
               configured to talk to.
        :param _builtins.str namespace: The namespace to lookup the services.
        :param _builtins.bool require_consistent: When `true` force the client to perform a
               read on at least quorum servers and verify the result is the same.  Defaults
               to `false`.
        :param _builtins.str token: Specify the Consul ACL token to use when performing the
               request.  This defaults to the same API token configured by the `consul`
               provider but may be overridden if necessary.
        :param _builtins.int wait_index: Index number used to enable blocking queries.
        :param _builtins.str wait_time: Max time the client should wait for a blocking query
               to return.
        """
        if allow_stale is not None:
            pulumi.set(__self__, "allow_stale", allow_stale)
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if near is not None:
            pulumi.set(__self__, "near", near)
        if node_meta is not None:
            pulumi.set(__self__, "node_meta", node_meta)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if require_consistent is not None:
            pulumi.set(__self__, "require_consistent", require_consistent)
        if token is not None:
            pulumi.set(__self__, "token", token)
        if wait_index is not None:
            pulumi.set(__self__, "wait_index", wait_index)
        if wait_time is not None:
            pulumi.set(__self__, "wait_time", wait_time)

    @_builtins.property
    @pulumi.getter(name="allowStale")
    def allow_stale(self) -> Optional[_builtins.bool]:
        """
        When `true`, the default, allow responses from
        Consul servers that are followers.
        """
        return pulumi.get(self, "allow_stale")

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> Optional[_builtins.str]:
        """
        The Consul datacenter to query.  Defaults to the
        same value found in `query_options` parameter specified below, or if that is
        empty, the `datacenter` value found in the Consul agent that this provider is
        configured to talk to.
        """
        return pulumi.get(self, "datacenter")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        The namespace to lookup the services.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def near(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "near")

    @_builtins.property
    @pulumi.getter(name="nodeMeta")
    def node_meta(self) -> Optional[Mapping[str, _builtins.str]]:
        return pulumi.get(self, "node_meta")

    @_builtins.property
    @pulumi.getter
    def partition(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "partition")

    @_builtins.property
    @pulumi.getter(name="requireConsistent")
    def require_consistent(self) -> Optional[_builtins.bool]:
        """
        When `true` force the client to perform a
        read on at least quorum servers and verify the result is the same.  Defaults
        to `false`.
        """
        return pulumi.get(self, "require_consistent")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        Specify the Consul ACL token to use when performing the
        request.  This defaults to the same API token configured by the `consul`
        provider but may be overridden if necessary.
        """
        return pulumi.get(self, "token")

    @_builtins.property
    @pulumi.getter(name="waitIndex")
    def wait_index(self) -> Optional[_builtins.int]:
        """
        Index number used to enable blocking queries.
        """
        return pulumi.get(self, "wait_index")

    @_builtins.property
    @pulumi.getter(name="waitTime")
    def wait_time(self) -> Optional[_builtins.str]:
        """
        Max time the client should wait for a blocking query
        to return.
        """
        return pulumi.get(self, "wait_time")


