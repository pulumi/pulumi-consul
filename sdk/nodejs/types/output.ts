// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface AclAuthMethodNamespaceRule {
    /**
     * If the namespace rule's `selector` matches then
     * this is used to control the namespace where the token is created.
     */
    bindNamespace: string;
    /**
     * Specifies the expression used to match this namespace
     * rule against valid identities returned from an auth method validation.
     * Defaults to `""`.
     */
    selector?: string;
}

export interface AclRoleNodeIdentity {
    /**
     * The datacenter of the node.
     */
    datacenter: string;
    /**
     * The name of the node.
     */
    nodeName: string;
}

export interface AclRoleServiceIdentity {
    /**
     * The datacenters the effective policy is valid within.
     */
    datacenters?: string[];
    /**
     * The name of the service.
     */
    serviceName: string;
}

export interface AclTokenNodeIdentity {
    /**
     * The datacenter of the node.
     */
    datacenter: string;
    /**
     * The name of the node.
     */
    nodeName: string;
}

export interface AclTokenServiceIdentity {
    /**
     * The list of datacenters the policy is valid within.
     */
    datacenters?: string[];
    /**
     * The name of the service.
     */
    serviceName: string;
}

export interface CatalogEntryService {
    /**
     * The address of the service. Defaults to the
     * node address.
     */
    address?: string;
    /**
     * The ID of the service. Defaults to the `name`.
     */
    id: string;
    /**
     * The name of the service
     */
    name: string;
    /**
     * The port of the service.
     */
    port?: number;
    /**
     * A list of values that are opaque to Consul,
     * but can be used to distinguish between services or nodes.
     */
    tags?: string[];
}

export interface GetAclAuthMethodNamespaceRule {
    bindNamespace: string;
    selector: string;
}

export interface GetAclRoleNodeIdentity {
    datacenter: string;
    nodeName: string;
}

export interface GetAclRolePolicy {
    id: string;
    /**
     * The name of the ACL Role.
     */
    name: string;
}

export interface GetAclRoleServiceIdentity {
    datacenters?: string[];
    serviceName?: string;
}

export interface GetAclTokenNodeIdentity {
    datacenter: string;
    nodeName: string;
}

export interface GetAclTokenPolicy {
    id: string;
    name: string;
}

export interface GetAclTokenRole {
    id: string;
    name: string;
}

export interface GetAclTokenServiceIdentity {
    datacenters: string[];
    serviceName: string;
}

export interface GetAutopilotHealthServer {
    /**
     * The address of the server
     */
    address: string;
    /**
     * Whether the server is healthy according to the current Autopilot
     * configuration
     */
    healthy: boolean;
    /**
     * The Raft ID of the server
     */
    id: string;
    /**
     * The time elapsed since the server's last contact with
     * the leader
     */
    lastContact: string;
    /**
     * The index of the server's last committed Raft log entry
     */
    lastIndex: number;
    /**
     * The server's last known Raft leader term
     */
    lastTerm: number;
    /**
     * Whether the server is currently leader
     */
    leader: boolean;
    /**
     * The node name of the server
     */
    name: string;
    /**
     * The status of the SerfHealth check of the server
     */
    serfStatus: string;
    /**
     * The time this server has been in its current ``Healthy``
     * state
     */
    stableSince: string;
    /**
     * The Consul version of the server
     */
    version: string;
    /**
     * Whether the server is a voting member of the Raft cluster
     */
    voter: boolean;
}

export interface GetCatalogNodesNode {
    address: string;
    id: string;
    meta: {[key: string]: string};
    name: string;
    taggedAddresses: {[key: string]: string};
}

export interface GetCatalogNodesQueryOption {
    allowStale?: boolean;
    datacenter?: string;
    near?: string;
    nodeMeta?: {[key: string]: string};
    partition?: string;
    requireConsistent?: boolean;
    token?: string;
    waitIndex?: number;
    waitTime?: string;
}

export interface GetCatalogServiceQueryOption {
    allowStale?: boolean;
    datacenter?: string;
    namespace?: string;
    near?: string;
    nodeMeta?: {[key: string]: string};
    partition?: string;
    requireConsistent?: boolean;
    token?: string;
    waitIndex?: number;
    waitTime?: string;
}

export interface GetCatalogServiceService {
    address: string;
    createIndex: string;
    enableTagOverride: string;
    id: string;
    meta: {[key: string]: string};
    modifyIndex: string;
    name: string;
    nodeAddress: string;
    nodeId: string;
    nodeMeta: {[key: string]: string};
    nodeName: string;
    port: string;
    taggedAddresses: {[key: string]: string};
    tags: string[];
}

export interface GetCatalogServicesQueryOption {
    allowStale?: boolean;
    datacenter?: string;
    namespace?: string;
    near?: string;
    nodeMeta?: {[key: string]: string};
    partition?: string;
    requireConsistent?: boolean;
    token?: string;
    waitIndex?: number;
    waitTime?: string;
}

export interface GetKeyPrefixSubkeyCollection {
    /**
     * This is the default value to set for `var.<name>`
     * if the key does not exist in Consul. Defaults to an empty string.
     */
    default?: string;
    /**
     * This is the name of the key. This value of the
     * key is exposed as `var.<name>`. This is not the path of the subkey
     * in Consul.
     */
    name: string;
    /**
     * This is the subkey path in Consul (which will be appended
     * to the given `pathPrefix`) to construct the full key that will be used
     * to read the value.
     */
    path: string;
}

export interface GetKeysKey {
    /**
     * This is the default value to set for `var.<name>`
     * if the key does not exist in Consul. Defaults to an empty string.
     */
    default?: string;
    /**
     * This is the name of the key. This value of the
     * key is exposed as `var.<name>`. This is not the path of the key
     * in Consul.
     */
    name: string;
    /**
     * This is the path in Consul that should be read
     * or written to.
     */
    path: string;
}

export interface GetNetworkAreaMembersMember {
    /**
     * The IP address of the server.
     */
    address: string;
    /**
     * The Consul version running on the node.
     */
    build: string;
    /**
     * The datacenter to use. This overrides the
     * agent's default datacenter and the datacenter in the provider setup.
     */
    datacenter: string;
    /**
     * The node ID of the server.
     */
    id: string;
    /**
     * The node name of the server, with its datacenter appended.
     */
    name: string;
    /**
     * The server RPC port the node.
     */
    port: number;
    /**
     * The protocol version being spoken by the node.
     */
    protocol: number;
    /**
     * Role is always `"server"` since only Consul servers can participate
     * in network areas.
     */
    role: string;
    /**
     * An estimated network round trip time from the server answering the
     * query to the given server, in nanoseconds. This is computed using network
     * coordinates.
     */
    rtt: number;
    /**
     * The current health status of the node, as determined by the
     * network area distributed failure detector. This will be `"alive"`, `"leaving"`,
     * or `"failed"`. A `"failed"` status means that other servers are not able to
     * probe this server over its server RPC interface.
     */
    status: string;
}

export interface GetNodesNode {
    address: string;
    /**
     * The Node ID of the Consul agent.
     * * [`meta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Node meta
     * data tag information, if any.
     * * [`name`](https://www.consul.io/docs/agent/http/catalog.html#Node) - The name
     * of the Consul node.
     * * [`address`](https://www.consul.io/docs/agent/http/catalog.html#Address) - The
     * IP address the node is advertising to the Consul cluster.
     * * [`taggedAddresses`](https://www.consul.io/docs/agent/http/catalog.html#TaggedAddresses) -
     * List of explicit LAN and WAN IP addresses for the agent.
     */
    id: string;
    meta: {[key: string]: string};
    name: string;
    taggedAddresses: {[key: string]: string};
}

export interface GetNodesQueryOption {
    /**
     * When `true`, the default, allow responses from
     * Consul servers that are followers.
     */
    allowStale?: boolean;
    /**
     * The Consul datacenter to query.  Defaults to the
     * same value found in `queryOptions` parameter specified below, or if that is
     * empty, the `datacenter` value found in the Consul agent that this provider is
     * configured to talk to then the datacenter in the provider setup.
     */
    datacenter?: string;
    near?: string;
    nodeMeta?: {[key: string]: string};
    partition?: string;
    /**
     * When `true` force the client to perform a
     * read on at least quorum servers and verify the result is the same.  Defaults
     * to `false`.
     */
    requireConsistent?: boolean;
    /**
     * Specify the Consul ACL token to use when performing the
     * request.  This defaults to the same API token configured by the `consul`
     * provider but may be overridden if necessary.
     */
    token?: string;
    /**
     * Index number used to enable blocking queries.
     */
    waitIndex?: number;
    /**
     * Max time the client should wait for a blocking query
     * to return.
     */
    waitTime?: string;
}

export interface GetServiceHealthResult {
    checks: outputs.GetServiceHealthResultCheck[];
    /**
     * The name of the node associated with this health-check.
     */
    nodes: outputs.GetServiceHealthResultNode[];
    services: outputs.GetServiceHealthResultService[];
}

export interface GetServiceHealthResultCheck {
    /**
     * The ID of this health-check.
     */
    id: string;
    /**
     * The service name to select.
     */
    name: string;
    /**
     * The name of the node associated with this health-check.
     */
    node: string;
    /**
     * A human readable description of the current state of the health-check.
     */
    notes: string;
    /**
     * The output of the health-check.
     */
    output: string;
    /**
     * The ID of the service associated to this health-check.
     */
    serviceId: string;
    /**
     * The name of the service associated with this health-check.
     */
    serviceName: string;
    /**
     * The list of tags associated with this health-check.
     */
    serviceTags: string[];
    /**
     * The status of this health-check.
     */
    status: string;
}

export interface GetServiceHealthResultNode {
    /**
     * The address of this instance.
     */
    address: string;
    /**
     * The Consul datacenter to query.
     */
    datacenter: string;
    /**
     * The ID of this health-check.
     */
    id: string;
    /**
     * Service metadata tag information, if any.
     */
    meta: {[key: string]: string};
    /**
     * The service name to select.
     */
    name: string;
    taggedAddresses: {[key: string]: string};
}

export interface GetServiceHealthResultService {
    /**
     * The address of this instance.
     */
    address: string;
    /**
     * The ID of this health-check.
     */
    id: string;
    /**
     * Service metadata tag information, if any.
     */
    meta: {[key: string]: string};
    /**
     * The service name to select.
     */
    name: string;
    /**
     * The port of this instance.
     */
    port: number;
    /**
     * The list of tags associated with this instance.
     */
    tags: string[];
}

export interface GetServiceQueryOption {
    /**
     * When `true`, the default, allow responses from
     * Consul servers that are followers.
     */
    allowStale?: boolean;
    /**
     * The Consul datacenter to query.  Defaults to the
     * same value found in `queryOptions` parameter specified below, or if that is
     * empty, the `datacenter` value found in the Consul agent that this provider is
     * configured to talk to.
     */
    datacenter?: string;
    /**
     * The namespace to lookup the service.
     */
    namespace?: string;
    near?: string;
    nodeMeta?: {[key: string]: string};
    partition?: string;
    /**
     * When `true` force the client to perform a
     * read on at least quorum servers and verify the result is the same.  Defaults
     * to `false`.
     */
    requireConsistent?: boolean;
    /**
     * Specify the Consul ACL token to use when performing the
     * request.  This defaults to the same API token configured by the `consul`
     * provider but may be overridden if necessary.
     */
    token?: string;
    /**
     * Index number used to enable blocking queries.
     */
    waitIndex?: number;
    /**
     * Max time the client should wait for a blocking query
     * to return.
     */
    waitTime?: string;
}

export interface GetServiceService {
    address: string;
    createIndex: string;
    enableTagOverride: string;
    id: string;
    meta: {[key: string]: string};
    modifyIndex: string;
    /**
     * The service name to select.
     */
    name: string;
    nodeAddress: string;
    /**
     * The Node ID of the Consul agent advertising the service.
     * * [`nodeMeta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Node
     * meta data tag information, if any.
     * * [`nodeName`](https://www.consul.io/docs/agent/http/catalog.html#Node) - The
     * name of the Consul node.
     * * [`address`](https://www.consul.io/docs/agent/http/catalog.html#ServiceAddress) -
     * The IP address of the service.  If the `ServiceAddress` in the Consul catalog
     * is empty, this value is automatically populated with the `nodeAddress` (the
     * `Address` in the Consul Catalog).
     * * [`enableTagOverride`](https://www.consul.io/docs/agent/http/catalog.html#ServiceEnableTagOverride) -
     * Whether service tags can be overridden on this service.
     * * [`id`](https://www.consul.io/docs/agent/http/catalog.html#ServiceID) - A
     * unique service instance identifier.
     * * [`name`](https://www.consul.io/docs/agent/http/catalog.html#ServiceName) - The
     * name of the service.
     * * [`port`](https://www.consul.io/docs/agent/http/catalog.html#ServicePort) -
     * Port number of the service.
     * * [`taggedAddresses`](https://www.consul.io/docs/agent/http/catalog.html#TaggedAddresses) -
     * List of explicit LAN and WAN IP addresses for the agent.
     * * [`tags`](https://www.consul.io/docs/agent/http/catalog.html#ServiceTags) -
     * List of tags for the service.
     * * [`meta`](https://www.consul.io/docs/agent/http/catalog.html#Meta) - Service meta
     * data tag information, if any.
     */
    nodeId: string;
    nodeMeta: {[key: string]: string};
    nodeName: string;
    port: string;
    taggedAddresses: {[key: string]: string};
    tags: string[];
}

export interface GetServicesQueryOption {
    /**
     * When `true`, the default, allow responses from
     * Consul servers that are followers.
     */
    allowStale?: boolean;
    /**
     * The Consul datacenter to query.  Defaults to the
     * same value found in `queryOptions` parameter specified below, or if that is
     * empty, the `datacenter` value found in the Consul agent that this provider is
     * configured to talk to.
     */
    datacenter?: string;
    /**
     * The namespace to lookup the services.
     */
    namespace?: string;
    near?: string;
    nodeMeta?: {[key: string]: string};
    partition?: string;
    /**
     * When `true` force the client to perform a
     * read on at least quorum servers and verify the result is the same.  Defaults
     * to `false`.
     */
    requireConsistent?: boolean;
    /**
     * Specify the Consul ACL token to use when performing the
     * request.  This defaults to the same API token configured by the `consul`
     * provider but may be overridden if necessary.
     */
    token?: string;
    /**
     * Index number used to enable blocking queries.
     */
    waitIndex?: number;
    /**
     * Max time the client should wait for a blocking query
     * to return.
     */
    waitTime?: string;
}

export interface KeyPrefixSubkeyCollection {
    /**
     * An [unsigned integer value](https://www.consul.io/api/kv.html#flags-1)
     * to attach to the key (defaults to 0).
     */
    flags?: number;
    /**
     * This is the path (which will be appended to the given
     * `pathPrefix`) in Consul that should be written to.
     */
    path: string;
    /**
     * The value to write to the given path.
     */
    value: string;
}

export interface KeysKey {
    default?: string;
    /**
     * If true, then the key will be deleted when
     * either its configuration block is removed from the configuration or
     * the entire resource is destroyed. Otherwise, it will be left in Consul.
     * Defaults to false.
     */
    delete?: boolean;
    /**
     * An [unsigned integer value](https://www.consul.io/api/kv.html#flags-1)
     * to attach to the key (defaults to 0).
     */
    flags?: number;
    /**
     * @deprecated Using consul_keys resource to *read* is deprecated; please use consul_keys data source instead
     */
    name?: string;
    /**
     * This is the path in Consul that should be written to.
     */
    path: string;
    /**
     * The value to write to the given path.
     */
    value: string;
}

export interface PreparedQueryDns {
    /**
     * The TTL to send when returning DNS results.
     */
    ttl?: string;
}

export interface PreparedQueryFailover {
    /**
     * Remote datacenters to return results from.
     */
    datacenters?: string[];
    /**
     * Return results from this many datacenters,
     * sorted in ascending order of estimated RTT.
     */
    nearestN?: number;
}

export interface PreparedQueryTemplate {
    /**
     * The regular expression to match with. When using
     * `namePrefixMatch`, this regex is applied against the query name.
     */
    regexp: string;
    /**
     * The type of template matching to perform. Currently
     * only `namePrefixMatch` is supported.
     */
    type: string;
}

export interface ServiceCheck {
    /**
     * An ID, *unique per agent*. Will default to *name*
     * if not set.
     */
    checkId: string;
    /**
     * The time after which
     * the service is automatically deregistered when in the `critical` state.
     * Defaults to `30s`.
     */
    deregisterCriticalServiceAfter?: string;
    /**
     * The headers to send for an HTTP check.
     * The attributes of each header is given below.
     */
    headers?: outputs.ServiceCheckHeader[];
    /**
     * The HTTP endpoint to call for an HTTP check.
     */
    http?: string;
    /**
     * The interval to wait between each health-check
     * invocation.
     */
    interval: string;
    /**
     * The method to use for HTTP health-checks. Defaults
     * to `GET`.
     */
    method?: string;
    /**
     * The name of the health-check.
     */
    name: string;
    /**
     * An opaque field meant to hold human readable text.
     */
    notes?: string;
    /**
     * The initial health-check status.
     */
    status: string;
    /**
     * The TCP address and port to connect to for a TCP check.
     */
    tcp?: string;
    /**
     * The timeout value for HTTP checks.
     */
    timeout: string;
    /**
     * Whether to deactivate certificate
     * verification for HTTP health-checks. Defaults to `false`.
     */
    tlsSkipVerify?: boolean;
}

export interface ServiceCheckHeader {
    /**
     * The name of the header.
     */
    name: string;
    /**
     * The header's list of values.
     */
    values: string[];
}
export namespace config {
    export interface Headers {
        name: string;
        value: string;
    }

}
